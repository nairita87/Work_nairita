   subroutine ocn_generate_state_subpool_tracers(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'tracers', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'tracers', newSubPool)

! Define var array activeTracers
      allocate(r3Ptr(2))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group activeGRP
! Define constituent var temperature
! My Packages are activeTracersPKG
      if (activeTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperature', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_temperature', -1)
           end if
      end if
! Define constituent var salinity
! My packages are activeTracersPKG
      if (activeTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinity', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'activeGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_activeTracers', numConstituents)
      end if
! Defining time level 1
      allocate( r3Ptr(1) % constituentNames(numConstituents) )
      r3Ptr(1) % fieldName = 'activeTracers'
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isVarArray = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperature', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'temperature'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinity', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'salinity'
      end if

! Setup dimensions for       
      r3Ptr(1) % dimNames(1) = 'num_activeTracers'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nCells'

      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(size(r3Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r3Ptr(1) % constituentNames, dim=1)
         allocate(r3Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperature', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'potential temperature')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'degrees Celsius')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'temperature'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'salinity')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'grams salt per kilogram seawater')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'salinity'
      end if
      r3Ptr(1) % block => block
! Defining time level 2
      allocate( r3Ptr(2) % constituentNames(numConstituents) )
      r3Ptr(2) % fieldName = 'activeTracers'
      r3Ptr(2) % isDecomposed = .true.
      r3Ptr(2) % hasTimeDimension = .true.
      r3Ptr(2) % isVarArray = .true.
      r3Ptr(2) % isPersistent = .true.
      r3Ptr(2) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperature', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(2) % constituentNames(const_index) = 'temperature'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinity', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(2) % constituentNames(const_index) = 'salinity'
      end if

! Setup dimensions for       
      r3Ptr(2) % dimNames(1) = 'num_activeTracers'
      r3Ptr(2) % dimNames(2) = 'nVertLevels'
      r3Ptr(2) % dimNames(3) = 'nCells'

      r3Ptr(2) % defaultValue = 0.0
      allocate(r3Ptr(2) % attLists(size(r3Ptr(2) % constituentNames, dim=1)))
      do index_counter = 1, size(r3Ptr(2) % constituentNames, dim=1)
         allocate(r3Ptr(2) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperature', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'long_name', 'potential temperature')
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'units', 'degrees Celsius')
         r3Ptr(2) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(2) % constituentNames(const_index) = 'temperature'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'long_name', 'salinity')
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'units', 'grams salt per kilogram seawater')
         r3Ptr(2) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(2) % constituentNames(const_index) = 'salinity'
      end if
      r3Ptr(2) % block => block

      if (activeTracersPKGActive) then
         r3Ptr(1) % isActive = .true.
         r3Ptr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'activeTracers', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'activeTracers', r3Ptr)

! Define var array debugTracers
      allocate(r3Ptr(2))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group debugGRP
! Define constituent var tracer1
! My Packages are debugTracersPKG
      if (debugTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_tracer1', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'debugGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_tracer1', -1)
           end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'debugGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'debugGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'debugGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_debugTracers', numConstituents)
      end if
! Defining time level 1
      allocate( r3Ptr(1) % constituentNames(numConstituents) )
      r3Ptr(1) % fieldName = 'debugTracers'
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isVarArray = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_tracer1', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'tracer1'
      end if

! Setup dimensions for       
      r3Ptr(1) % dimNames(1) = 'num_debugTracers'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nCells'

      r3Ptr(1) % defaultValue = 1.0
      allocate(r3Ptr(1) % attLists(size(r3Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r3Ptr(1) % constituentNames, dim=1)
         allocate(r3Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_tracer1', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'tracer for debugging purposes')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'tracer1')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'tracer1'
      end if
      r3Ptr(1) % block => block
! Defining time level 2
      allocate( r3Ptr(2) % constituentNames(numConstituents) )
      r3Ptr(2) % fieldName = 'debugTracers'
      r3Ptr(2) % isDecomposed = .true.
      r3Ptr(2) % hasTimeDimension = .true.
      r3Ptr(2) % isVarArray = .true.
      r3Ptr(2) % isPersistent = .true.
      r3Ptr(2) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_tracer1', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(2) % constituentNames(const_index) = 'tracer1'
      end if

! Setup dimensions for       
      r3Ptr(2) % dimNames(1) = 'num_debugTracers'
      r3Ptr(2) % dimNames(2) = 'nVertLevels'
      r3Ptr(2) % dimNames(3) = 'nCells'

      r3Ptr(2) % defaultValue = 1.0
      allocate(r3Ptr(2) % attLists(size(r3Ptr(2) % constituentNames, dim=1)))
      do index_counter = 1, size(r3Ptr(2) % constituentNames, dim=1)
         allocate(r3Ptr(2) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_tracer1', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'long_name', 'tracer for debugging purposes')
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'units', 'tracer1')
         r3Ptr(2) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(2) % constituentNames(const_index) = 'tracer1'
      end if
      r3Ptr(2) % block => block

      if (debugTracersPKGActive) then
         r3Ptr(1) % isActive = .true.
         r3Ptr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'debugTracers', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'debugTracers', r3Ptr)

! Define var array ecosysTracers
      allocate(r3Ptr(2))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group ecosysGRP
! Define constituent var PO4
! My Packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_PO4', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_PO4', -1)
           end if
      end if
! Define constituent var NO3
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_NO3', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_NO3', -1)
         end if
      end if
! Define constituent var SiO3
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_SiO3', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_SiO3', -1)
         end if
      end if
! Define constituent var NH4
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_NH4', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_NH4', -1)
         end if
      end if
! Define constituent var Fe
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_Fe', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_Fe', -1)
         end if
      end if
! Define constituent var O2
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_O2', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_O2', -1)
         end if
      end if
! Define constituent var DIC
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DIC', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DIC', -1)
         end if
      end if
! Define constituent var DIC_ALT_CO2
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DIC_ALT_CO2', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DIC_ALT_CO2', -1)
         end if
      end if
! Define constituent var ALK
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_ALK', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_ALK', -1)
         end if
      end if
! Define constituent var DOC
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOC', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOC', -1)
         end if
      end if
! Define constituent var DON
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DON', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DON', -1)
         end if
      end if
! Define constituent var DOFe
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOFe', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOFe', -1)
         end if
      end if
! Define constituent var DOP
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOP', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOP', -1)
         end if
      end if
! Define constituent var DOPr
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOPr', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOPr', -1)
         end if
      end if
! Define constituent var DONr
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DONr', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DONr', -1)
         end if
      end if
! Define constituent var zooC
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_zooC', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_zooC', -1)
         end if
      end if
! Define constituent var spChl
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spChl', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spChl', -1)
         end if
      end if
! Define constituent var spC
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spC', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spC', -1)
         end if
      end if
! Define constituent var spFe
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spFe', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spFe', -1)
         end if
      end if
! Define constituent var spCaCO3
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spCaCO3', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spCaCO3', -1)
         end if
      end if
! Define constituent var diatChl
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatChl', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatChl', -1)
         end if
      end if
! Define constituent var diatC
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatC', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatC', -1)
         end if
      end if
! Define constituent var diatFe
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatFe', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatFe', -1)
         end if
      end if
! Define constituent var diatSi
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatSi', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatSi', -1)
         end if
      end if
! Define constituent var diazChl
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazChl', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazChl', -1)
         end if
      end if
! Define constituent var diazC
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazC', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazC', -1)
         end if
      end if
! Define constituent var diazFe
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazFe', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazFe', -1)
         end if
      end if
! Define constituent var phaeoChl
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoChl', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoChl', -1)
         end if
      end if
! Define constituent var phaeoC
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoC', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoC', -1)
         end if
      end if
! Define constituent var phaeoFe
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoFe', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoFe', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_ecosysTracers', numConstituents)
      end if
! Defining time level 1
      allocate( r3Ptr(1) % constituentNames(numConstituents) )
      r3Ptr(1) % fieldName = 'ecosysTracers'
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isVarArray = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_PO4', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'PO4'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_NO3', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'NO3'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_SiO3', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'SiO3'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_NH4', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'NH4'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_Fe', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'Fe'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_O2', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'O2'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DIC', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'DIC'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DIC_ALT_CO2', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'DIC_ALT_CO2'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_ALK', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'ALK'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOC', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'DOC'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DON', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'DON'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOFe', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'DOFe'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOP', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'DOP'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOPr', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'DOPr'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DONr', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'DONr'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_zooC', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'zooC'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spChl', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'spChl'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spC', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'spC'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spFe', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'spFe'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spCaCO3', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'spCaCO3'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatChl', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'diatChl'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatC', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'diatC'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatFe', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'diatFe'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatSi', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'diatSi'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazChl', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'diazChl'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazC', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'diazC'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazFe', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'diazFe'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoChl', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'phaeoChl'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoC', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'phaeoC'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoFe', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'phaeoFe'
      end if

! Setup dimensions for       
      r3Ptr(1) % dimNames(1) = 'num_ecosysTracers'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nCells'

      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(size(r3Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r3Ptr(1) % constituentNames, dim=1)
         allocate(r3Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_PO4', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Inorganic Phosphate')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol P m^{-3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'PO4'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_NO3', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Inorganic Nitrate')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol N m^{-3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'NO3'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_SiO3', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Inorganic Silicate')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol Si m^{-3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'SiO3'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_NH4', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Ammonia')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol N m^{-3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'NH4'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_Fe', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Inorganic Iron')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol Fe m^{-3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'Fe'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_O2', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Oxygen')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol O2 m^{-3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'O2'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DIC', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Inorganic Carbon')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol C m^{-3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'DIC'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DIC_ALT_CO2', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Inorganic Carbon, Alternative CO2')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol C m^{-3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'DIC_ALT_CO2'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_ALK', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Alkalinity')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'meq m^{-3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'ALK'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOC', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Organic Carbon')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol C m^{-3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'DOC'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DON', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Organic Nitrogen')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol N m^{-3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'DON'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOFe', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Organic Iron')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol Fe m^{-3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'DOFe'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOP', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Organic Phosphorus')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol P m^{-3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'DOP'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOPr', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Refractory DOP')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol P m^{-3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'DOPr'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DONr', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Refractory DON')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol N m^{-3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'DONr'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_zooC', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Zooplankton Carbon')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol C m^{-3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'zooC'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spChl', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Small Phytoplankton Chlorophyll')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mg m^{-3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'spChl'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spC', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Small Phytoplankton Carbon')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol C m^{-3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'spC'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spFe', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Small Phytoplankton Iron')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol Fe m^{-3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'spFe'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spCaCO3', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Small Phytoplankton Calcium Carbonate')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol C m^{-3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'spCaCO3'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatChl', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Diatom Chlorophyll')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mg m^{-3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'diatChl'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatC', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Diatom Carbon')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol C m^{-3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'diatC'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatFe', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Diatom Iron')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol Fe m^{-3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'diatFe'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatSi', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Diatom Silicate')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol Si m^{-3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'diatSi'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazChl', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Diazotroph Chlorophyll')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mg m^{-3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'diazChl'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazC', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Diazotroph Carbon')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol C m^{-3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'diazC'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazFe', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Diazotroph Iron')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol Fe m^{-3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'diazFe'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoChl', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Phaeocystis Chlorophyll')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mg m^{-3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'phaeoChl'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoC', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Phaeocystis Carbon')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol C m^{-3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'phaeoC'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoFe', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Phaeocystis Iron')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol Fe m^{-3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'phaeoFe'
      end if
      r3Ptr(1) % block => block
! Defining time level 2
      allocate( r3Ptr(2) % constituentNames(numConstituents) )
      r3Ptr(2) % fieldName = 'ecosysTracers'
      r3Ptr(2) % isDecomposed = .true.
      r3Ptr(2) % hasTimeDimension = .true.
      r3Ptr(2) % isVarArray = .true.
      r3Ptr(2) % isPersistent = .true.
      r3Ptr(2) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_PO4', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(2) % constituentNames(const_index) = 'PO4'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_NO3', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(2) % constituentNames(const_index) = 'NO3'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_SiO3', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(2) % constituentNames(const_index) = 'SiO3'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_NH4', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(2) % constituentNames(const_index) = 'NH4'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_Fe', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(2) % constituentNames(const_index) = 'Fe'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_O2', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(2) % constituentNames(const_index) = 'O2'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DIC', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(2) % constituentNames(const_index) = 'DIC'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DIC_ALT_CO2', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(2) % constituentNames(const_index) = 'DIC_ALT_CO2'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_ALK', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(2) % constituentNames(const_index) = 'ALK'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOC', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(2) % constituentNames(const_index) = 'DOC'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DON', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(2) % constituentNames(const_index) = 'DON'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOFe', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(2) % constituentNames(const_index) = 'DOFe'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOP', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(2) % constituentNames(const_index) = 'DOP'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOPr', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(2) % constituentNames(const_index) = 'DOPr'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DONr', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(2) % constituentNames(const_index) = 'DONr'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_zooC', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(2) % constituentNames(const_index) = 'zooC'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spChl', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(2) % constituentNames(const_index) = 'spChl'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spC', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(2) % constituentNames(const_index) = 'spC'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spFe', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(2) % constituentNames(const_index) = 'spFe'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spCaCO3', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(2) % constituentNames(const_index) = 'spCaCO3'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatChl', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(2) % constituentNames(const_index) = 'diatChl'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatC', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(2) % constituentNames(const_index) = 'diatC'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatFe', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(2) % constituentNames(const_index) = 'diatFe'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatSi', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(2) % constituentNames(const_index) = 'diatSi'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazChl', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(2) % constituentNames(const_index) = 'diazChl'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazC', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(2) % constituentNames(const_index) = 'diazC'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazFe', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(2) % constituentNames(const_index) = 'diazFe'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoChl', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(2) % constituentNames(const_index) = 'phaeoChl'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoC', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(2) % constituentNames(const_index) = 'phaeoC'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoFe', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(2) % constituentNames(const_index) = 'phaeoFe'
      end if

! Setup dimensions for       
      r3Ptr(2) % dimNames(1) = 'num_ecosysTracers'
      r3Ptr(2) % dimNames(2) = 'nVertLevels'
      r3Ptr(2) % dimNames(3) = 'nCells'

      r3Ptr(2) % defaultValue = 0.0
      allocate(r3Ptr(2) % attLists(size(r3Ptr(2) % constituentNames, dim=1)))
      do index_counter = 1, size(r3Ptr(2) % constituentNames, dim=1)
         allocate(r3Ptr(2) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_PO4', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'long_name', 'Dissolved Inorganic Phosphate')
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'units', 'mmol P m^{-3}')
         r3Ptr(2) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(2) % constituentNames(const_index) = 'PO4'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_NO3', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'long_name', 'Dissolved Inorganic Nitrate')
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'units', 'mmol N m^{-3}')
         r3Ptr(2) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(2) % constituentNames(const_index) = 'NO3'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_SiO3', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'long_name', 'Dissolved Inorganic Silicate')
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'units', 'mmol Si m^{-3}')
         r3Ptr(2) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(2) % constituentNames(const_index) = 'SiO3'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_NH4', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'long_name', 'Dissolved Ammonia')
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'units', 'mmol N m^{-3}')
         r3Ptr(2) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(2) % constituentNames(const_index) = 'NH4'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_Fe', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'long_name', 'Dissolved Inorganic Iron')
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'units', 'mmol Fe m^{-3}')
         r3Ptr(2) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(2) % constituentNames(const_index) = 'Fe'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_O2', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'long_name', 'Dissolved Oxygen')
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'units', 'mmol O2 m^{-3}')
         r3Ptr(2) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(2) % constituentNames(const_index) = 'O2'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DIC', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'long_name', 'Dissolved Inorganic Carbon')
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'units', 'mmol C m^{-3}')
         r3Ptr(2) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(2) % constituentNames(const_index) = 'DIC'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DIC_ALT_CO2', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'long_name', 'Dissolved Inorganic Carbon, Alternative CO2')
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'units', 'mmol C m^{-3}')
         r3Ptr(2) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(2) % constituentNames(const_index) = 'DIC_ALT_CO2'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_ALK', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'long_name', 'Alkalinity')
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'units', 'meq m^{-3}')
         r3Ptr(2) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(2) % constituentNames(const_index) = 'ALK'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOC', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'long_name', 'Dissolved Organic Carbon')
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'units', 'mmol C m^{-3}')
         r3Ptr(2) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(2) % constituentNames(const_index) = 'DOC'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DON', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'long_name', 'Dissolved Organic Nitrogen')
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'units', 'mmol N m^{-3}')
         r3Ptr(2) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(2) % constituentNames(const_index) = 'DON'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOFe', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'long_name', 'Dissolved Organic Iron')
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'units', 'mmol Fe m^{-3}')
         r3Ptr(2) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(2) % constituentNames(const_index) = 'DOFe'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOP', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'long_name', 'Dissolved Organic Phosphorus')
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'units', 'mmol P m^{-3}')
         r3Ptr(2) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(2) % constituentNames(const_index) = 'DOP'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOPr', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'long_name', 'Refractory DOP')
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'units', 'mmol P m^{-3}')
         r3Ptr(2) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(2) % constituentNames(const_index) = 'DOPr'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DONr', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'long_name', 'Refractory DON')
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'units', 'mmol N m^{-3}')
         r3Ptr(2) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(2) % constituentNames(const_index) = 'DONr'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_zooC', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'long_name', 'Zooplankton Carbon')
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'units', 'mmol C m^{-3}')
         r3Ptr(2) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(2) % constituentNames(const_index) = 'zooC'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spChl', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'long_name', 'Small Phytoplankton Chlorophyll')
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'units', 'mg m^{-3}')
         r3Ptr(2) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(2) % constituentNames(const_index) = 'spChl'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spC', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'long_name', 'Small Phytoplankton Carbon')
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'units', 'mmol C m^{-3}')
         r3Ptr(2) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(2) % constituentNames(const_index) = 'spC'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spFe', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'long_name', 'Small Phytoplankton Iron')
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'units', 'mmol Fe m^{-3}')
         r3Ptr(2) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(2) % constituentNames(const_index) = 'spFe'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spCaCO3', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'long_name', 'Small Phytoplankton Calcium Carbonate')
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'units', 'mmol C m^{-3}')
         r3Ptr(2) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(2) % constituentNames(const_index) = 'spCaCO3'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatChl', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'long_name', 'Diatom Chlorophyll')
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'units', 'mg m^{-3}')
         r3Ptr(2) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(2) % constituentNames(const_index) = 'diatChl'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatC', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'long_name', 'Diatom Carbon')
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'units', 'mmol C m^{-3}')
         r3Ptr(2) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(2) % constituentNames(const_index) = 'diatC'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatFe', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'long_name', 'Diatom Iron')
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'units', 'mmol Fe m^{-3}')
         r3Ptr(2) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(2) % constituentNames(const_index) = 'diatFe'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatSi', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'long_name', 'Diatom Silicate')
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'units', 'mmol Si m^{-3}')
         r3Ptr(2) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(2) % constituentNames(const_index) = 'diatSi'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazChl', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'long_name', 'Diazotroph Chlorophyll')
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'units', 'mg m^{-3}')
         r3Ptr(2) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(2) % constituentNames(const_index) = 'diazChl'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazC', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'long_name', 'Diazotroph Carbon')
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'units', 'mmol C m^{-3}')
         r3Ptr(2) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(2) % constituentNames(const_index) = 'diazC'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazFe', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'long_name', 'Diazotroph Iron')
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'units', 'mmol Fe m^{-3}')
         r3Ptr(2) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(2) % constituentNames(const_index) = 'diazFe'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoChl', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'long_name', 'Phaeocystis Chlorophyll')
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'units', 'mg m^{-3}')
         r3Ptr(2) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(2) % constituentNames(const_index) = 'phaeoChl'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoC', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'long_name', 'Phaeocystis Carbon')
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'units', 'mmol C m^{-3}')
         r3Ptr(2) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(2) % constituentNames(const_index) = 'phaeoC'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoFe', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'long_name', 'Phaeocystis Iron')
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'units', 'mmol Fe m^{-3}')
         r3Ptr(2) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(2) % constituentNames(const_index) = 'phaeoFe'
      end if
      r3Ptr(2) % block => block

      if (ecosysTracersPKGActive) then
         r3Ptr(1) % isActive = .true.
         r3Ptr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosysTracers', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosysTracers', r3Ptr)

! Define var array DMSTracers
      allocate(r3Ptr(2))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group DMSGRP
! Define constituent var DMS
! My Packages are DMSTracersPKG
      if (DMSTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DMS', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'DMSGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_DMS', -1)
           end if
      end if
! Define constituent var DMSP
! My packages are DMSTracersPKG
      if (DMSTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DMSP', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'DMSGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DMSP', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'DMSGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'DMSGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'DMSGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_DMSTracers', numConstituents)
      end if
! Defining time level 1
      allocate( r3Ptr(1) % constituentNames(numConstituents) )
      r3Ptr(1) % fieldName = 'DMSTracers'
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isVarArray = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DMS', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'DMS'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DMSP', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'DMSP'
      end if

! Setup dimensions for       
      r3Ptr(1) % dimNames(1) = 'num_DMSTracers'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nCells'

      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(size(r3Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r3Ptr(1) % constituentNames, dim=1)
         allocate(r3Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DMS', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dimethyl Sulfide')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol m^{-3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'DMS'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DMSP', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dimethyl Sulfoniopropionate')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol m^{-3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'DMSP'
      end if
      r3Ptr(1) % block => block
! Defining time level 2
      allocate( r3Ptr(2) % constituentNames(numConstituents) )
      r3Ptr(2) % fieldName = 'DMSTracers'
      r3Ptr(2) % isDecomposed = .true.
      r3Ptr(2) % hasTimeDimension = .true.
      r3Ptr(2) % isVarArray = .true.
      r3Ptr(2) % isPersistent = .true.
      r3Ptr(2) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DMS', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(2) % constituentNames(const_index) = 'DMS'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DMSP', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(2) % constituentNames(const_index) = 'DMSP'
      end if

! Setup dimensions for       
      r3Ptr(2) % dimNames(1) = 'num_DMSTracers'
      r3Ptr(2) % dimNames(2) = 'nVertLevels'
      r3Ptr(2) % dimNames(3) = 'nCells'

      r3Ptr(2) % defaultValue = 0.0
      allocate(r3Ptr(2) % attLists(size(r3Ptr(2) % constituentNames, dim=1)))
      do index_counter = 1, size(r3Ptr(2) % constituentNames, dim=1)
         allocate(r3Ptr(2) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DMS', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'long_name', 'Dimethyl Sulfide')
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'units', 'mmol m^{-3}')
         r3Ptr(2) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(2) % constituentNames(const_index) = 'DMS'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DMSP', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'long_name', 'Dimethyl Sulfoniopropionate')
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'units', 'mmol m^{-3}')
         r3Ptr(2) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(2) % constituentNames(const_index) = 'DMSP'
      end if
      r3Ptr(2) % block => block

      if (DMSTracersPKGActive) then
         r3Ptr(1) % isActive = .true.
         r3Ptr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'DMSTracers', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'DMSTracers', r3Ptr)

! Define var array MacroMoleculesTracers
      allocate(r3Ptr(2))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group MacroMoleculesGRP
! Define constituent var PROT
! My Packages are MacroMoleculesTracersPKG
      if (MacroMoleculesTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_PROT', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_PROT', -1)
           end if
      end if
! Define constituent var POLY
! My packages are MacroMoleculesTracersPKG
      if (MacroMoleculesTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_POLY', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_POLY', -1)
         end if
      end if
! Define constituent var LIP
! My packages are MacroMoleculesTracersPKG
      if (MacroMoleculesTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_LIP', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_LIP', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_MacroMoleculesTracers', numConstituents)
      end if
! Defining time level 1
      allocate( r3Ptr(1) % constituentNames(numConstituents) )
      r3Ptr(1) % fieldName = 'MacroMoleculesTracers'
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isVarArray = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_PROT', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'PROT'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_POLY', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'POLY'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_LIP', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'LIP'
      end if

! Setup dimensions for       
      r3Ptr(1) % dimNames(1) = 'num_MacroMoleculesTracers'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nCells'

      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(size(r3Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r3Ptr(1) % constituentNames, dim=1)
         allocate(r3Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_PROT', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Proteins')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol m^{-3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'PROT'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_POLY', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Polysaccharides')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol m^{-3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'POLY'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_LIP', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Lipids')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol m^{-3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'LIP'
      end if
      r3Ptr(1) % block => block
! Defining time level 2
      allocate( r3Ptr(2) % constituentNames(numConstituents) )
      r3Ptr(2) % fieldName = 'MacroMoleculesTracers'
      r3Ptr(2) % isDecomposed = .true.
      r3Ptr(2) % hasTimeDimension = .true.
      r3Ptr(2) % isVarArray = .true.
      r3Ptr(2) % isPersistent = .true.
      r3Ptr(2) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_PROT', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(2) % constituentNames(const_index) = 'PROT'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_POLY', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(2) % constituentNames(const_index) = 'POLY'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_LIP', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(2) % constituentNames(const_index) = 'LIP'
      end if

! Setup dimensions for       
      r3Ptr(2) % dimNames(1) = 'num_MacroMoleculesTracers'
      r3Ptr(2) % dimNames(2) = 'nVertLevels'
      r3Ptr(2) % dimNames(3) = 'nCells'

      r3Ptr(2) % defaultValue = 0.0
      allocate(r3Ptr(2) % attLists(size(r3Ptr(2) % constituentNames, dim=1)))
      do index_counter = 1, size(r3Ptr(2) % constituentNames, dim=1)
         allocate(r3Ptr(2) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_PROT', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'long_name', 'Proteins')
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'units', 'mmol m^{-3}')
         r3Ptr(2) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(2) % constituentNames(const_index) = 'PROT'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_POLY', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'long_name', 'Polysaccharides')
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'units', 'mmol m^{-3}')
         r3Ptr(2) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(2) % constituentNames(const_index) = 'POLY'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_LIP', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'long_name', 'Lipids')
         call mpas_add_att(r3Ptr(2) % attLists(const_index) % attList, 'units', 'mmol m^{-3}')
         r3Ptr(2) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(2) % constituentNames(const_index) = 'LIP'
      end if
      r3Ptr(2) % block => block

      if (MacroMoleculesTracersPKGActive) then
         r3Ptr(1) % isActive = .true.
         r3Ptr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'MacroMoleculesTracers', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'MacroMoleculesTracers', r3Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_state_subpool_tracers


   subroutine ocn_generate_pool_state(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'state', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'state', newSubPool)

! Define variable normalVelocity
      allocate(r2Ptr(2))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'normalVelocity'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nEdges'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'horizonal velocity, normal component to an edge')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

! Setting up time level 2
      r2Ptr(2) % fieldName = 'normalVelocity'
      r2Ptr(2) % isVarArray = .false.
      r2Ptr(2) % isDecomposed = .true.
      r2Ptr(2) % hasTimeDimension = .true.
      r2Ptr(2) % isPersistent = .true.
      r2Ptr(2) % isActive = .false.
! Setting up dimensions
      r2Ptr(2) % dimNames(1) = 'nVertLevels'
      r2Ptr(2) % dimNames(2) = 'nEdges'
      r2Ptr(2) % defaultValue = 0.0
      allocate(r2Ptr(2) % attLists(1))
      allocate(r2Ptr(2) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(2) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(2) % attLists(1) % attList, 'long_name', 'horizonal velocity, normal component to an edge')
      r2Ptr(2) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(2) % block => block

      r2Ptr(1) % isActive = .true.
      r2Ptr(2) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'normalVelocity', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'normalVelocity', r2Ptr)

! Define variable layerThickness
      allocate(r2Ptr(2))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'layerThickness'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'layer thickness')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

! Setting up time level 2
      r2Ptr(2) % fieldName = 'layerThickness'
      r2Ptr(2) % isVarArray = .false.
      r2Ptr(2) % isDecomposed = .true.
      r2Ptr(2) % hasTimeDimension = .true.
      r2Ptr(2) % isPersistent = .true.
      r2Ptr(2) % isActive = .false.
! Setting up dimensions
      r2Ptr(2) % dimNames(1) = 'nVertLevels'
      r2Ptr(2) % dimNames(2) = 'nCells'
      r2Ptr(2) % defaultValue = 0.0
      allocate(r2Ptr(2) % attLists(1))
      allocate(r2Ptr(2) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(2) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r2Ptr(2) % attLists(1) % attList, 'long_name', 'layer thickness')
      r2Ptr(2) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(2) % block => block

      r2Ptr(1) % isActive = .true.
      r2Ptr(2) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'layerThickness', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'layerThickness', r2Ptr)

! Define variable ssh
      allocate(r1Ptr(2))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'ssh'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'sea surface height')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

! Setting up time level 2
      r1Ptr(2) % fieldName = 'ssh'
      r1Ptr(2) % isVarArray = .false.
      r1Ptr(2) % isDecomposed = .true.
      r1Ptr(2) % hasTimeDimension = .true.
      r1Ptr(2) % isPersistent = .true.
      r1Ptr(2) % isActive = .false.
! Setting up dimensions
      r1Ptr(2) % dimNames(1) = 'nCells'
      r1Ptr(2) % defaultValue = 0.0
      allocate(r1Ptr(2) % attLists(1))
      allocate(r1Ptr(2) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(2) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r1Ptr(2) % attLists(1) % attList, 'long_name', 'sea surface height')
      r1Ptr(2) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(2) % block => block

      r1Ptr(1) % isActive = .true.
      r1Ptr(2) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'ssh', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'ssh', r1Ptr)

! Define variable highFreqThickness
      allocate(r2Ptr(2))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'highFreqThickness'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'high frequency-filtered layer thickness')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

! Setting up time level 2
      r2Ptr(2) % fieldName = 'highFreqThickness'
      r2Ptr(2) % isVarArray = .false.
      r2Ptr(2) % isDecomposed = .true.
      r2Ptr(2) % hasTimeDimension = .true.
      r2Ptr(2) % isPersistent = .true.
      r2Ptr(2) % isActive = .false.
! Setting up dimensions
      r2Ptr(2) % dimNames(1) = 'nVertLevels'
      r2Ptr(2) % dimNames(2) = 'nCells'
      r2Ptr(2) % defaultValue = 0.0
      allocate(r2Ptr(2) % attLists(1))
      allocate(r2Ptr(2) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(2) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r2Ptr(2) % attLists(1) % attList, 'long_name', 'high frequency-filtered layer thickness')
      r2Ptr(2) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(2) % block => block

      if (thicknessFilterActive) then
         r2Ptr(1) % isActive = .true.
         r2Ptr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'highFreqThickness', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'highFreqThickness', r2Ptr)

! Define variable lowFreqDivergence
      allocate(r2Ptr(2))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'lowFreqDivergence'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 's^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'low frequency-filtered divergence')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

! Setting up time level 2
      r2Ptr(2) % fieldName = 'lowFreqDivergence'
      r2Ptr(2) % isVarArray = .false.
      r2Ptr(2) % isDecomposed = .true.
      r2Ptr(2) % hasTimeDimension = .true.
      r2Ptr(2) % isPersistent = .true.
      r2Ptr(2) % isActive = .false.
! Setting up dimensions
      r2Ptr(2) % dimNames(1) = 'nVertLevels'
      r2Ptr(2) % dimNames(2) = 'nCells'
      r2Ptr(2) % defaultValue = 0.0
      allocate(r2Ptr(2) % attLists(1))
      allocate(r2Ptr(2) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(2) % attLists(1) % attList, 'units', 's^{-1}')
      call mpas_add_att(r2Ptr(2) % attLists(1) % attList, 'long_name', 'low frequency-filtered divergence')
      r2Ptr(2) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(2) % block => block

      if (thicknessFilterActive) then
         r2Ptr(1) % isActive = .true.
         r2Ptr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'lowFreqDivergence', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'lowFreqDivergence', r2Ptr)

! Define variable accumulatedFrazilIceMass
      allocate(r1Ptr(2))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'accumulatedFrazilIceMass'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'kg m^{-2}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Mass per unit area of frazil ice produced. Reset to zero '&
//'at each coupling interval')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

! Setting up time level 2
      r1Ptr(2) % fieldName = 'accumulatedFrazilIceMass'
      r1Ptr(2) % isVarArray = .false.
      r1Ptr(2) % isDecomposed = .true.
      r1Ptr(2) % hasTimeDimension = .true.
      r1Ptr(2) % isPersistent = .true.
      r1Ptr(2) % isActive = .false.
! Setting up dimensions
      r1Ptr(2) % dimNames(1) = 'nCells'
      r1Ptr(2) % defaultValue = 0.0
      allocate(r1Ptr(2) % attLists(1))
      allocate(r1Ptr(2) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(2) % attLists(1) % attList, 'units', 'kg m^{-2}')
      call mpas_add_att(r1Ptr(2) % attLists(1) % attList, 'long_name', 'Mass per unit area of frazil ice produced. Reset to zero '&
//'at each coupling interval')
      r1Ptr(2) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(2) % block => block

      if (frazilIceActive) then
         r1Ptr(1) % isActive = .true.
         r1Ptr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'accumulatedFrazilIceMass', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'accumulatedFrazilIceMass', r1Ptr)

! Define variable accumulatedFrazilIceSalinity
      allocate(r1Ptr(2))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'accumulatedFrazilIceSalinity'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'kg m^{-2}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Salinity associated with accumulatedFrazilIceMass. Reset '&
//'to zero at each coupling interval')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

! Setting up time level 2
      r1Ptr(2) % fieldName = 'accumulatedFrazilIceSalinity'
      r1Ptr(2) % isVarArray = .false.
      r1Ptr(2) % isDecomposed = .true.
      r1Ptr(2) % hasTimeDimension = .true.
      r1Ptr(2) % isPersistent = .true.
      r1Ptr(2) % isActive = .false.
! Setting up dimensions
      r1Ptr(2) % dimNames(1) = 'nCells'
      r1Ptr(2) % defaultValue = 0.0
      allocate(r1Ptr(2) % attLists(1))
      allocate(r1Ptr(2) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(2) % attLists(1) % attList, 'units', 'kg m^{-2}')
      call mpas_add_att(r1Ptr(2) % attLists(1) % attList, 'long_name', 'Salinity associated with accumulatedFrazilIceMass. Reset '&
//'to zero at each coupling interval')
      r1Ptr(2) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(2) % block => block

      if (frazilIceActive) then
         r1Ptr(1) % isActive = .true.
         r1Ptr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'accumulatedFrazilIceSalinity', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'accumulatedFrazilIceSalinity', r1Ptr)

! Define variable accumulatedLandIceMass
      allocate(r1Ptr(2))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'accumulatedLandIceMass'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'kg m^{-2}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Mass per unit area of land ice produced at land ice-ocean '&
//'interface. Only computed in ''standalone'' mode where land-ice fluxes are computed in MPAS-O.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

! Setting up time level 2
      r1Ptr(2) % fieldName = 'accumulatedLandIceMass'
      r1Ptr(2) % isVarArray = .false.
      r1Ptr(2) % isDecomposed = .true.
      r1Ptr(2) % hasTimeDimension = .true.
      r1Ptr(2) % isPersistent = .true.
      r1Ptr(2) % isActive = .false.
! Setting up dimensions
      r1Ptr(2) % dimNames(1) = 'nCells'
      r1Ptr(2) % defaultValue = 0.0
      allocate(r1Ptr(2) % attLists(1))
      allocate(r1Ptr(2) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(2) % attLists(1) % attList, 'units', 'kg m^{-2}')
      call mpas_add_att(r1Ptr(2) % attLists(1) % attList, 'long_name', 'Mass per unit area of land ice produced at land ice-ocean '&
//'interface. Only computed in ''standalone'' mode where land-ice fluxes are computed in MPAS-O.')
      r1Ptr(2) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(2) % block => block

      if (landIceFluxesPKGActive) then
         r1Ptr(1) % isActive = .true.
         r1Ptr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'accumulatedLandIceMass', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'accumulatedLandIceMass', r1Ptr)

! Define variable accumulatedLandIceHeat
      allocate(r1Ptr(2))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'accumulatedLandIceHeat'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'J m^{-2}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Heat per unit area stored in land ice produced at land '&
//'ice-ocean interface. Only computed in ''standalone'' mode where land-ice fluxes are computed in MPAS-O.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

! Setting up time level 2
      r1Ptr(2) % fieldName = 'accumulatedLandIceHeat'
      r1Ptr(2) % isVarArray = .false.
      r1Ptr(2) % isDecomposed = .true.
      r1Ptr(2) % hasTimeDimension = .true.
      r1Ptr(2) % isPersistent = .true.
      r1Ptr(2) % isActive = .false.
! Setting up dimensions
      r1Ptr(2) % dimNames(1) = 'nCells'
      r1Ptr(2) % defaultValue = 0.0
      allocate(r1Ptr(2) % attLists(1))
      allocate(r1Ptr(2) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(2) % attLists(1) % attList, 'units', 'J m^{-2}')
      call mpas_add_att(r1Ptr(2) % attLists(1) % attList, 'long_name', 'Heat per unit area stored in land ice produced at land '&
//'ice-ocean interface. Only computed in ''standalone'' mode where land-ice fluxes are computed in MPAS-O.')
      r1Ptr(2) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(2) % block => block

      if (landIceFluxesPKGActive) then
         r1Ptr(1) % isActive = .true.
         r1Ptr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'accumulatedLandIceHeat', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'accumulatedLandIceHeat', r1Ptr)

! Define variable accumulatedLandIceFrazilMass
      allocate(r1Ptr(2))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'accumulatedLandIceFrazilMass'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'kg m^{-2}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Mass per unit area of frazil ice produced under land ice.  '&
//'Only computed when not coupled to a dynamic land-ice model.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

! Setting up time level 2
      r1Ptr(2) % fieldName = 'accumulatedLandIceFrazilMass'
      r1Ptr(2) % isVarArray = .false.
      r1Ptr(2) % isDecomposed = .true.
      r1Ptr(2) % hasTimeDimension = .true.
      r1Ptr(2) % isPersistent = .true.
      r1Ptr(2) % isActive = .false.
! Setting up dimensions
      r1Ptr(2) % dimNames(1) = 'nCells'
      r1Ptr(2) % defaultValue = 0.0
      allocate(r1Ptr(2) % attLists(1))
      allocate(r1Ptr(2) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(2) % attLists(1) % attList, 'units', 'kg m^{-2}')
      call mpas_add_att(r1Ptr(2) % attLists(1) % attList, 'long_name', 'Mass per unit area of frazil ice produced under land ice.  '&
//'Only computed when not coupled to a dynamic land-ice model.')
      r1Ptr(2) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(2) % block => block

      if (frazilIceActive) then
         r1Ptr(1) % isActive = .true.
         r1Ptr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'accumulatedLandIceFrazilMass', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'accumulatedLandIceFrazilMass', r1Ptr)

! Define variable normalBarotropicVelocity
      allocate(r1Ptr(2))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'normalBarotropicVelocity'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'barotropic velocity, used in split-explicit time-stepping')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

! Setting up time level 2
      r1Ptr(2) % fieldName = 'normalBarotropicVelocity'
      r1Ptr(2) % isVarArray = .false.
      r1Ptr(2) % isDecomposed = .true.
      r1Ptr(2) % hasTimeDimension = .true.
      r1Ptr(2) % isPersistent = .true.
      r1Ptr(2) % isActive = .false.
! Setting up dimensions
      r1Ptr(2) % dimNames(1) = 'nEdges'
      r1Ptr(2) % defaultValue = 0.0
      allocate(r1Ptr(2) % attLists(1))
      allocate(r1Ptr(2) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(2) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(2) % attLists(1) % attList, 'long_name', 'barotropic velocity, used in split-explicit time-stepping')
      r1Ptr(2) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(2) % block => block

      if (splitTimeIntegratorActive) then
         r1Ptr(1) % isActive = .true.
         r1Ptr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'normalBarotropicVelocity', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'normalBarotropicVelocity', r1Ptr)

! Define variable normalBarotropicVelocitySubcycle
      allocate(r1Ptr(2))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'normalBarotropicVelocitySubcycle'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'barotropic velocity, used in subcycling in stage 2 of '&
//'split-explicit time-stepping')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

! Setting up time level 2
      r1Ptr(2) % fieldName = 'normalBarotropicVelocitySubcycle'
      r1Ptr(2) % isVarArray = .false.
      r1Ptr(2) % isDecomposed = .true.
      r1Ptr(2) % hasTimeDimension = .true.
      r1Ptr(2) % isPersistent = .true.
      r1Ptr(2) % isActive = .false.
! Setting up dimensions
      r1Ptr(2) % dimNames(1) = 'nEdges'
      r1Ptr(2) % defaultValue = 0.0
      allocate(r1Ptr(2) % attLists(1))
      allocate(r1Ptr(2) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(2) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(2) % attLists(1) % attList, 'long_name', 'barotropic velocity, used in subcycling in stage 2 of '&
//'split-explicit time-stepping')
      r1Ptr(2) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(2) % block => block

      if (splitTimeIntegratorActive) then
         r1Ptr(1) % isActive = .true.
         r1Ptr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'normalBarotropicVelocitySubcycle', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'normalBarotropicVelocitySubcycle', r1Ptr)

! Define variable sshSubcycle
      allocate(r1Ptr(2))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'sshSubcycle'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'sea surface height, used in subcycling in stage 2 of '&
//'split-explicit time-stepping')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

! Setting up time level 2
      r1Ptr(2) % fieldName = 'sshSubcycle'
      r1Ptr(2) % isVarArray = .false.
      r1Ptr(2) % isDecomposed = .true.
      r1Ptr(2) % hasTimeDimension = .true.
      r1Ptr(2) % isPersistent = .true.
      r1Ptr(2) % isActive = .false.
! Setting up dimensions
      r1Ptr(2) % dimNames(1) = 'nCells'
      r1Ptr(2) % defaultValue = 0.0
      allocate(r1Ptr(2) % attLists(1))
      allocate(r1Ptr(2) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(2) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r1Ptr(2) % attLists(1) % attList, 'long_name', 'sea surface height, used in subcycling in stage 2 of '&
//'split-explicit time-stepping')
      r1Ptr(2) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(2) % block => block

      if (splitTimeIntegratorActive) then
         r1Ptr(1) % isActive = .true.
         r1Ptr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'sshSubcycle', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'sshSubcycle', r1Ptr)

! Define variable normalBaroclinicVelocity
      allocate(r2Ptr(2))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'normalBaroclinicVelocity'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nEdges'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'baroclinic velocity, used in split-explicit time-stepping')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

! Setting up time level 2
      r2Ptr(2) % fieldName = 'normalBaroclinicVelocity'
      r2Ptr(2) % isVarArray = .false.
      r2Ptr(2) % isDecomposed = .true.
      r2Ptr(2) % hasTimeDimension = .true.
      r2Ptr(2) % isPersistent = .true.
      r2Ptr(2) % isActive = .false.
! Setting up dimensions
      r2Ptr(2) % dimNames(1) = 'nVertLevels'
      r2Ptr(2) % dimNames(2) = 'nEdges'
      r2Ptr(2) % defaultValue = 0.0
      allocate(r2Ptr(2) % attLists(1))
      allocate(r2Ptr(2) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(2) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(2) % attLists(1) % attList, 'long_name', 'baroclinic velocity, used in split-explicit time-stepping')
      r2Ptr(2) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(2) % block => block

      if (splitTimeIntegratorActive) then
         r2Ptr(1) % isActive = .true.
         r2Ptr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'normalBaroclinicVelocity', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'normalBaroclinicVelocity', r2Ptr)

! Define variable effectiveDensityInLandIce
      allocate(r1Ptr(2))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'effectiveDensityInLandIce'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'kg m^{-3}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'The effective ocean density within ice shelves based on '&
//'Archimedes'' principle.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

! Setting up time level 2
      r1Ptr(2) % fieldName = 'effectiveDensityInLandIce'
      r1Ptr(2) % isVarArray = .false.
      r1Ptr(2) % isDecomposed = .true.
      r1Ptr(2) % hasTimeDimension = .true.
      r1Ptr(2) % isPersistent = .true.
      r1Ptr(2) % isActive = .false.
! Setting up dimensions
      r1Ptr(2) % dimNames(1) = 'nCells'
      r1Ptr(2) % defaultValue = 0.0
      allocate(r1Ptr(2) % attLists(1))
      allocate(r1Ptr(2) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(2) % attLists(1) % attList, 'units', 'kg m^{-3}')
      call mpas_add_att(r1Ptr(2) % attLists(1) % attList, 'long_name', 'The effective ocean density within ice shelves based on '&
//'Archimedes'' principle.')
      r1Ptr(2) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(2) % block => block

      if (landIceCouplingPKGActive) then
         r1Ptr(1) % isActive = .true.
         r1Ptr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'effectiveDensityInLandIce', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'effectiveDensityInLandIce', r1Ptr)


      call ocn_generate_state_subpool_tracers(block, newSubPool, dimensionPool, packagePool)

      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_pool_state


   subroutine ocn_generate_pool_mesh(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'mesh', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'mesh', newSubPool)

! Define variable latCell
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'latCell'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'radians')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Latitude location of cell centers in radians.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'latCell', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'latCell', r1Ptr)

! Define variable lonCell
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'lonCell'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'radians')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Longitude location of cell centers in radians.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'lonCell', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'lonCell', r1Ptr)

! Define variable xCell
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'xCell'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'X Coordinate in cartesian space of cell centers.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'xCell', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'xCell', r1Ptr)

! Define variable yCell
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'yCell'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Y Coordinate in cartesian space of cell centers.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'yCell', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'yCell', r1Ptr)

! Define variable zCell
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'zCell'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Z Coordinate in cartesian space of cell centers.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'zCell', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'zCell', r1Ptr)

! Define variable indexToCellID
      allocate(i1Ptr(1))

! Setting up time level 1
      i1Ptr(1) % fieldName = 'indexToCellID'
      i1Ptr(1) % isVarArray = .false.
      i1Ptr(1) % isDecomposed = .true.
      i1Ptr(1) % hasTimeDimension = .false.
      i1Ptr(1) % isPersistent = .true.
      i1Ptr(1) % isActive = .false.
! Setting up dimensions
      i1Ptr(1) % dimNames(1) = 'nCells'
      i1Ptr(1) % defaultValue = 0
      allocate(i1Ptr(1) % attLists(1))
      allocate(i1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'long_name', 'List of global cell IDs.')
      i1Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i1Ptr(1) % block => block

      i1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'indexToCellID', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'indexToCellID', i1Ptr)

! Define variable latEdge
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'latEdge'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'radians')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Latitude location of edge midpoints in radians.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'latEdge', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'latEdge', r1Ptr)

! Define variable lonEdge
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'lonEdge'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'radians')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Longitude location of edge midpoints in radians.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'lonEdge', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'lonEdge', r1Ptr)

! Define variable xEdge
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'xEdge'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'X Coordinate in cartesian space of edge midpoints.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'xEdge', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'xEdge', r1Ptr)

! Define variable yEdge
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'yEdge'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Y Coordinate in cartesian space of edge midpoints.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'yEdge', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'yEdge', r1Ptr)

! Define variable zEdge
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'zEdge'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Z Coordinate in cartesian space of edge midpoints.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'zEdge', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'zEdge', r1Ptr)

! Define variable indexToEdgeID
      allocate(i1Ptr(1))

! Setting up time level 1
      i1Ptr(1) % fieldName = 'indexToEdgeID'
      i1Ptr(1) % isVarArray = .false.
      i1Ptr(1) % isDecomposed = .true.
      i1Ptr(1) % hasTimeDimension = .false.
      i1Ptr(1) % isPersistent = .true.
      i1Ptr(1) % isActive = .false.
! Setting up dimensions
      i1Ptr(1) % dimNames(1) = 'nEdges'
      i1Ptr(1) % defaultValue = 0
      allocate(i1Ptr(1) % attLists(1))
      allocate(i1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'long_name', 'List of global edge IDs.')
      i1Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i1Ptr(1) % block => block

      i1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'indexToEdgeID', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'indexToEdgeID', i1Ptr)

! Define variable latVertex
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'latVertex'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nVertices'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'radians')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Latitude location of vertices in radians.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'latVertex', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'latVertex', r1Ptr)

! Define variable lonVertex
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'lonVertex'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nVertices'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'radians')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Longitude location of vertices in radians.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'lonVertex', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'lonVertex', r1Ptr)

! Define variable xVertex
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'xVertex'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nVertices'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'X Coordinate in cartesian space of vertices.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'xVertex', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'xVertex', r1Ptr)

! Define variable yVertex
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'yVertex'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nVertices'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Y Coordinate in cartesian space of vertices.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'yVertex', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'yVertex', r1Ptr)

! Define variable zVertex
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'zVertex'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nVertices'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Z Coordinate in cartesian space of vertices.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'zVertex', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'zVertex', r1Ptr)

! Define variable indexToVertexID
      allocate(i1Ptr(1))

! Setting up time level 1
      i1Ptr(1) % fieldName = 'indexToVertexID'
      i1Ptr(1) % isVarArray = .false.
      i1Ptr(1) % isDecomposed = .true.
      i1Ptr(1) % hasTimeDimension = .false.
      i1Ptr(1) % isPersistent = .true.
      i1Ptr(1) % isActive = .false.
! Setting up dimensions
      i1Ptr(1) % dimNames(1) = 'nVertices'
      i1Ptr(1) % defaultValue = 0
      allocate(i1Ptr(1) % attLists(1))
      allocate(i1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'long_name', 'List of global vertex IDs.')
      i1Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i1Ptr(1) % block => block

      i1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'indexToVertexID', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'indexToVertexID', i1Ptr)

! Define variable meshDensity
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'meshDensity'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Value of density function used to generate a particular '&
//'mesh at cell centers.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'meshDensity', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'meshDensity', r1Ptr)

! Define variable meshScalingDel2
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'meshScalingDel2'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Coefficient to Laplacian mixing terms in momentum and '&
//'tracer equations, so that viscosity and diffusion scale with mesh.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'meshScalingDel2', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'meshScalingDel2', r1Ptr)

! Define variable meshScalingDel4
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'meshScalingDel4'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Coefficient to biharmonic mixing terms in momentum and '&
//'tracer equations, so that biharmonic viscosity and diffusion coefficients scale with mesh.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'meshScalingDel4', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'meshScalingDel4', r1Ptr)

! Define variable meshScaling
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'meshScaling'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Coefficient used for mesh scaling, such as the Leith '&
//'parameter.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'meshScaling', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'meshScaling', r1Ptr)

! Define variable cellsOnEdge
      allocate(i2Ptr(1))

! Setting up time level 1
      i2Ptr(1) % fieldName = 'cellsOnEdge'
      i2Ptr(1) % isVarArray = .false.
      i2Ptr(1) % isDecomposed = .true.
      i2Ptr(1) % hasTimeDimension = .false.
      i2Ptr(1) % isPersistent = .true.
      i2Ptr(1) % isActive = .false.
! Setting up dimensions
      i2Ptr(1) % dimNames(1) = 'TWO'
      i2Ptr(1) % dimNames(2) = 'nEdges'
      i2Ptr(1) % defaultValue = 0
      allocate(i2Ptr(1) % attLists(1))
      allocate(i2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'long_name', 'List of cells that straddle each edge.')
      i2Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i2Ptr(1) % block => block

      i2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'cellsOnEdge', i2Ptr)
      call mpas_pool_add_field(block % allFields, 'cellsOnEdge', i2Ptr)

! Define variable nEdgesOnCell
      allocate(i1Ptr(1))

! Setting up time level 1
      i1Ptr(1) % fieldName = 'nEdgesOnCell'
      i1Ptr(1) % isVarArray = .false.
      i1Ptr(1) % isDecomposed = .true.
      i1Ptr(1) % hasTimeDimension = .false.
      i1Ptr(1) % isPersistent = .true.
      i1Ptr(1) % isActive = .false.
! Setting up dimensions
      i1Ptr(1) % dimNames(1) = 'nCells'
      i1Ptr(1) % defaultValue = 0
      allocate(i1Ptr(1) % attLists(1))
      allocate(i1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'long_name', 'Number of edges that border each cell.')
      i1Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i1Ptr(1) % block => block

      i1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'nEdgesOnCell', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'nEdgesOnCell', i1Ptr)

! Define variable nEdgesOnEdge
      allocate(i1Ptr(1))

! Setting up time level 1
      i1Ptr(1) % fieldName = 'nEdgesOnEdge'
      i1Ptr(1) % isVarArray = .false.
      i1Ptr(1) % isDecomposed = .true.
      i1Ptr(1) % hasTimeDimension = .false.
      i1Ptr(1) % isPersistent = .true.
      i1Ptr(1) % isActive = .false.
! Setting up dimensions
      i1Ptr(1) % dimNames(1) = 'nEdges'
      i1Ptr(1) % defaultValue = 0
      allocate(i1Ptr(1) % attLists(1))
      allocate(i1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'long_name', 'Number of edges that surround each of the cells that '&
//'straddle each edge. These edges are used to reconstruct the tangential velocities.')
      i1Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i1Ptr(1) % block => block

      i1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'nEdgesOnEdge', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'nEdgesOnEdge', i1Ptr)

! Define variable edgesOnCell
      allocate(i2Ptr(1))

! Setting up time level 1
      i2Ptr(1) % fieldName = 'edgesOnCell'
      i2Ptr(1) % isVarArray = .false.
      i2Ptr(1) % isDecomposed = .true.
      i2Ptr(1) % hasTimeDimension = .false.
      i2Ptr(1) % isPersistent = .true.
      i2Ptr(1) % isActive = .false.
! Setting up dimensions
      i2Ptr(1) % dimNames(1) = 'maxEdges'
      i2Ptr(1) % dimNames(2) = 'nCells'
      i2Ptr(1) % defaultValue = 0
      allocate(i2Ptr(1) % attLists(1))
      allocate(i2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'long_name', 'List of edges that border each cell.')
      i2Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i2Ptr(1) % block => block

      i2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'edgesOnCell', i2Ptr)
      call mpas_pool_add_field(block % allFields, 'edgesOnCell', i2Ptr)

! Define variable edgesOnEdge
      allocate(i2Ptr(1))

! Setting up time level 1
      i2Ptr(1) % fieldName = 'edgesOnEdge'
      i2Ptr(1) % isVarArray = .false.
      i2Ptr(1) % isDecomposed = .true.
      i2Ptr(1) % hasTimeDimension = .false.
      i2Ptr(1) % isPersistent = .true.
      i2Ptr(1) % isActive = .false.
! Setting up dimensions
      i2Ptr(1) % dimNames(1) = 'maxEdges2'
      i2Ptr(1) % dimNames(2) = 'nEdges'
      i2Ptr(1) % defaultValue = 0
      allocate(i2Ptr(1) % attLists(1))
      allocate(i2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'long_name', 'List of edges that border each of the cells that straddle '&
//'each edge.')
      i2Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i2Ptr(1) % block => block

      i2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'edgesOnEdge', i2Ptr)
      call mpas_pool_add_field(block % allFields, 'edgesOnEdge', i2Ptr)

! Define variable weightsOnEdge
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'weightsOnEdge'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'maxEdges2'
      r2Ptr(1) % dimNames(2) = 'nEdges'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Reconstruction weights associated with each of the '&
//'edgesOnEdge.')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'weightsOnEdge', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'weightsOnEdge', r2Ptr)

! Define variable dvEdge
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'dvEdge'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Length of each edge, computed as the distance between '&
//'verticesOnEdge.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'dvEdge', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'dvEdge', r1Ptr)

! Define variable dcEdge
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'dcEdge'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Length of each edge, computed as the distance between '&
//'cellsOnEdge.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'dcEdge', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'dcEdge', r1Ptr)

! Define variable angleEdge
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'angleEdge'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'radians')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Angle the edge normal makes with local eastward '&
//'direction.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'angleEdge', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'angleEdge', r1Ptr)

! Define variable areaCell
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'areaCell'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm^2')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Area of each cell in the primary grid.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'areaCell', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'areaCell', r1Ptr)

! Define variable areaTriangle
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'areaTriangle'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nVertices'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm^2')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Area of each cell (triangle) in the dual grid.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'areaTriangle', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'areaTriangle', r1Ptr)

! Define variable edgeNormalVectors
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'edgeNormalVectors'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'R3'
      r2Ptr(1) % dimNames(2) = 'nEdges'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Normal unit vector defined at an edge.')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'edgeNormalVectors', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'edgeNormalVectors', r2Ptr)

! Define variable edgeTangentVectors
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'edgeTangentVectors'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'R3'
      r2Ptr(1) % dimNames(2) = 'nEdges'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Tangent unit vector defined at an edge.')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'edgeTangentVectors', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'edgeTangentVectors', r2Ptr)

! Define variable localVerticalUnitVectors
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'localVerticalUnitVectors'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'R3'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Unit surface normal vectors defined at cell centers.')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'localVerticalUnitVectors', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'localVerticalUnitVectors', r2Ptr)

! Define variable cellTangentPlane
      allocate(r3Ptr(1))

! Setting up time level 1
      r3Ptr(1) % fieldName = 'cellTangentPlane'
      r3Ptr(1) % isVarArray = .false.
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .false.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.
! Setting up dimensions
      r3Ptr(1) % dimNames(1) = 'R3'
      r3Ptr(1) % dimNames(2) = 'TWO'
      r3Ptr(1) % dimNames(3) = 'nCells'
      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(1))
      allocate(r3Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'long_name', 'The two vectors that define a tangent plane at a cell '&
//'center.')
      r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r3Ptr(1) % block => block

      r3Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'cellTangentPlane', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'cellTangentPlane', r3Ptr)

! Define variable cellsOnCell
      allocate(i2Ptr(1))

! Setting up time level 1
      i2Ptr(1) % fieldName = 'cellsOnCell'
      i2Ptr(1) % isVarArray = .false.
      i2Ptr(1) % isDecomposed = .true.
      i2Ptr(1) % hasTimeDimension = .false.
      i2Ptr(1) % isPersistent = .true.
      i2Ptr(1) % isActive = .false.
! Setting up dimensions
      i2Ptr(1) % dimNames(1) = 'maxEdges'
      i2Ptr(1) % dimNames(2) = 'nCells'
      i2Ptr(1) % defaultValue = 0
      allocate(i2Ptr(1) % attLists(1))
      allocate(i2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'long_name', 'List of cells that neighbor each cell.')
      i2Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i2Ptr(1) % block => block

      i2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'cellsOnCell', i2Ptr)
      call mpas_pool_add_field(block % allFields, 'cellsOnCell', i2Ptr)

! Define variable verticesOnCell
      allocate(i2Ptr(1))

! Setting up time level 1
      i2Ptr(1) % fieldName = 'verticesOnCell'
      i2Ptr(1) % isVarArray = .false.
      i2Ptr(1) % isDecomposed = .true.
      i2Ptr(1) % hasTimeDimension = .false.
      i2Ptr(1) % isPersistent = .true.
      i2Ptr(1) % isActive = .false.
! Setting up dimensions
      i2Ptr(1) % dimNames(1) = 'maxEdges'
      i2Ptr(1) % dimNames(2) = 'nCells'
      i2Ptr(1) % defaultValue = 0
      allocate(i2Ptr(1) % attLists(1))
      allocate(i2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'long_name', 'List of vertices that border each cell.')
      i2Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i2Ptr(1) % block => block

      i2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'verticesOnCell', i2Ptr)
      call mpas_pool_add_field(block % allFields, 'verticesOnCell', i2Ptr)

! Define variable verticesOnEdge
      allocate(i2Ptr(1))

! Setting up time level 1
      i2Ptr(1) % fieldName = 'verticesOnEdge'
      i2Ptr(1) % isVarArray = .false.
      i2Ptr(1) % isDecomposed = .true.
      i2Ptr(1) % hasTimeDimension = .false.
      i2Ptr(1) % isPersistent = .true.
      i2Ptr(1) % isActive = .false.
! Setting up dimensions
      i2Ptr(1) % dimNames(1) = 'TWO'
      i2Ptr(1) % dimNames(2) = 'nEdges'
      i2Ptr(1) % defaultValue = 0
      allocate(i2Ptr(1) % attLists(1))
      allocate(i2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'long_name', 'List of vertices that straddle each edge.')
      i2Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i2Ptr(1) % block => block

      i2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'verticesOnEdge', i2Ptr)
      call mpas_pool_add_field(block % allFields, 'verticesOnEdge', i2Ptr)

! Define variable edgesOnVertex
      allocate(i2Ptr(1))

! Setting up time level 1
      i2Ptr(1) % fieldName = 'edgesOnVertex'
      i2Ptr(1) % isVarArray = .false.
      i2Ptr(1) % isDecomposed = .true.
      i2Ptr(1) % hasTimeDimension = .false.
      i2Ptr(1) % isPersistent = .true.
      i2Ptr(1) % isActive = .false.
! Setting up dimensions
      i2Ptr(1) % dimNames(1) = 'vertexDegree'
      i2Ptr(1) % dimNames(2) = 'nVertices'
      i2Ptr(1) % defaultValue = 0
      allocate(i2Ptr(1) % attLists(1))
      allocate(i2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'long_name', 'List of edges that share a vertex as an endpoint.')
      i2Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i2Ptr(1) % block => block

      i2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'edgesOnVertex', i2Ptr)
      call mpas_pool_add_field(block % allFields, 'edgesOnVertex', i2Ptr)

! Define variable cellsOnVertex
      allocate(i2Ptr(1))

! Setting up time level 1
      i2Ptr(1) % fieldName = 'cellsOnVertex'
      i2Ptr(1) % isVarArray = .false.
      i2Ptr(1) % isDecomposed = .true.
      i2Ptr(1) % hasTimeDimension = .false.
      i2Ptr(1) % isPersistent = .true.
      i2Ptr(1) % isActive = .false.
! Setting up dimensions
      i2Ptr(1) % dimNames(1) = 'vertexDegree'
      i2Ptr(1) % dimNames(2) = 'nVertices'
      i2Ptr(1) % defaultValue = 0
      allocate(i2Ptr(1) % attLists(1))
      allocate(i2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'long_name', 'List of cells that share a vertex.')
      i2Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i2Ptr(1) % block => block

      i2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'cellsOnVertex', i2Ptr)
      call mpas_pool_add_field(block % allFields, 'cellsOnVertex', i2Ptr)

! Define variable kiteAreasOnVertex
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'kiteAreasOnVertex'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'vertexDegree'
      r2Ptr(1) % dimNames(2) = 'nVertices'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm^2')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Area of the portions of each dual cell that are part of '&
//'each cellsOnVertex.')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'kiteAreasOnVertex', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'kiteAreasOnVertex', r2Ptr)

! Define variable fEdge
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'fEdge'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 's^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Coriolis parameter at edges.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'fEdge', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'fEdge', r1Ptr)

! Define variable fVertex
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'fVertex'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nVertices'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 's^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Coriolis parameter at vertices.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'fVertex', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'fVertex', r1Ptr)

! Define variable fCell
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'fCell'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 's^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Coriolis parameter at cell centers.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'fCell', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'fCell', r1Ptr)

! Define variable bottomDepth
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'bottomDepth'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Depth of the bottom of the ocean. Given as a positive '&
//'distance from sea level.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'bottomDepth', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'bottomDepth', r1Ptr)

! Define variable bottomDepthObserved
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'bottomDepthObserved'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Depth of the bottom of the ocean, before any alterations '&
//'for modeling purposes. Given as a positive distance from sea level.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (initModeActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'bottomDepthObserved', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'bottomDepthObserved', r1Ptr)

! Define variable oceanFracObserved
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'oceanFracObserved'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'fraction of each cell containing ocean, used to determine '&
//'which cells are culled as land.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (initModeActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'oceanFracObserved', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanFracObserved', r1Ptr)

! Define variable derivTwo
      allocate(r3Ptr(1))

! Setting up time level 1
      r3Ptr(1) % fieldName = 'derivTwo'
      r3Ptr(1) % isVarArray = .false.
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .false.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.
! Setting up dimensions
      r3Ptr(1) % dimNames(1) = 'maxEdges2'
      r3Ptr(1) % dimNames(2) = 'TWO'
      r3Ptr(1) % dimNames(3) = 'nEdges'
      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(1))
      allocate(r3Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'units', 'm^{-2}')
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'long_name', 'Value of the second derivative of the polynomial used for '&
//'reconstruction of cell center quantities at edges.')
      r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r3Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'derivTwo', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'derivTwo', r3Ptr)

! Define variable advCoefs
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'advCoefs'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nAdvectionCells'
      r2Ptr(1) % dimNames(2) = 'nEdges'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Weighting coefficients used for reconstruction of cell '&
//'center quantities at edges. Used in advection routines.')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'advCoefs', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'advCoefs', r2Ptr)

! Define variable advCoefs3rd
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'advCoefs3rd'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nAdvectionCells'
      r2Ptr(1) % dimNames(2) = 'nEdges'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Wegihting coefficients used for reconstruction of cell '&
//'center quantities at edges. Used in advection routines.')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'advCoefs3rd', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'advCoefs3rd', r2Ptr)

! Define variable advCellsForEdge
      allocate(i2Ptr(1))

! Setting up time level 1
      i2Ptr(1) % fieldName = 'advCellsForEdge'
      i2Ptr(1) % isVarArray = .false.
      i2Ptr(1) % isDecomposed = .true.
      i2Ptr(1) % hasTimeDimension = .false.
      i2Ptr(1) % isPersistent = .true.
      i2Ptr(1) % isActive = .false.
! Setting up dimensions
      i2Ptr(1) % dimNames(1) = 'nAdvectionCells'
      i2Ptr(1) % dimNames(2) = 'nEdges'
      i2Ptr(1) % defaultValue = 0
      allocate(i2Ptr(1) % attLists(1))
      allocate(i2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'long_name', 'List of cells used to reconstruct a cell quantity at an '&
//'edge. Used in advection routines.')
      i2Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         i2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'advCellsForEdge', i2Ptr)
      call mpas_pool_add_field(block % allFields, 'advCellsForEdge', i2Ptr)

! Define variable nAdvCellsForEdge
      allocate(i1Ptr(1))

! Setting up time level 1
      i1Ptr(1) % fieldName = 'nAdvCellsForEdge'
      i1Ptr(1) % isVarArray = .false.
      i1Ptr(1) % isDecomposed = .true.
      i1Ptr(1) % hasTimeDimension = .false.
      i1Ptr(1) % isPersistent = .true.
      i1Ptr(1) % isActive = .false.
! Setting up dimensions
      i1Ptr(1) % dimNames(1) = 'nEdges'
      i1Ptr(1) % defaultValue = 0
      allocate(i1Ptr(1) % attLists(1))
      allocate(i1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'long_name', 'Number of cells used in reconstruction of cell center '&
//'quantities at an edge. Used in advection routines.')
      i1Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i1Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         i1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'nAdvCellsForEdge', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'nAdvCellsForEdge', i1Ptr)

! Define variable highOrderAdvectionMask
      allocate(i2Ptr(1))

! Setting up time level 1
      i2Ptr(1) % fieldName = 'highOrderAdvectionMask'
      i2Ptr(1) % isVarArray = .false.
      i2Ptr(1) % isDecomposed = .true.
      i2Ptr(1) % hasTimeDimension = .false.
      i2Ptr(1) % isPersistent = .true.
      i2Ptr(1) % isActive = .false.
! Setting up dimensions
      i2Ptr(1) % dimNames(1) = 'nVertLevels'
      i2Ptr(1) % dimNames(2) = 'nEdges'
      i2Ptr(1) % defaultValue = 0
      allocate(i2Ptr(1) % attLists(1))
      allocate(i2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'long_name', 'Mask for high order advection. Values are 1 if high order '&
//'is used, and 0 if not.')
      i2Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         i2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'highOrderAdvectionMask', i2Ptr)
      call mpas_pool_add_field(block % allFields, 'highOrderAdvectionMask', i2Ptr)

! Define variable coeffs_reconstruct
      allocate(r3Ptr(1))

! Setting up time level 1
      r3Ptr(1) % fieldName = 'coeffs_reconstruct'
      r3Ptr(1) % isVarArray = .false.
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .false.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.
! Setting up dimensions
      r3Ptr(1) % dimNames(1) = 'R3'
      r3Ptr(1) % dimNames(2) = 'maxEdges'
      r3Ptr(1) % dimNames(3) = 'nCells'
      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(1))
      allocate(r3Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'long_name', 'Coefficients to reconstruct velocity vectors at cells '&
//'centers.')
      r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r3Ptr(1) % block => block

      r3Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'coeffs_reconstruct', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'coeffs_reconstruct', r3Ptr)

! Define variable maxLevelCell
      allocate(i1Ptr(1))

! Setting up time level 1
      i1Ptr(1) % fieldName = 'maxLevelCell'
      i1Ptr(1) % isVarArray = .false.
      i1Ptr(1) % isDecomposed = .true.
      i1Ptr(1) % hasTimeDimension = .false.
      i1Ptr(1) % isPersistent = .true.
      i1Ptr(1) % isActive = .false.
! Setting up dimensions
      i1Ptr(1) % dimNames(1) = 'nCells'
      i1Ptr(1) % defaultValue = 0
      allocate(i1Ptr(1) % attLists(1))
      allocate(i1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'long_name', 'Index to the last active ocean cell in each column.')
      i1Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i1Ptr(1) % block => block

      i1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'maxLevelCell', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'maxLevelCell', i1Ptr)

! Define variable maxLevelEdgeTop
      allocate(i1Ptr(1))

! Setting up time level 1
      i1Ptr(1) % fieldName = 'maxLevelEdgeTop'
      i1Ptr(1) % isVarArray = .false.
      i1Ptr(1) % isDecomposed = .true.
      i1Ptr(1) % hasTimeDimension = .false.
      i1Ptr(1) % isPersistent = .true.
      i1Ptr(1) % isActive = .false.
! Setting up dimensions
      i1Ptr(1) % dimNames(1) = 'nEdges'
      i1Ptr(1) % defaultValue = 0
      allocate(i1Ptr(1) % attLists(1))
      allocate(i1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'long_name', 'Index to the last edge in a column with active ocean cells '&
//'on both sides of it.')
      i1Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i1Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         i1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'maxLevelEdgeTop', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'maxLevelEdgeTop', i1Ptr)

! Define variable maxLevelEdgeBot
      allocate(i1Ptr(1))

! Setting up time level 1
      i1Ptr(1) % fieldName = 'maxLevelEdgeBot'
      i1Ptr(1) % isVarArray = .false.
      i1Ptr(1) % isDecomposed = .true.
      i1Ptr(1) % hasTimeDimension = .false.
      i1Ptr(1) % isPersistent = .true.
      i1Ptr(1) % isActive = .false.
! Setting up dimensions
      i1Ptr(1) % dimNames(1) = 'nEdges'
      i1Ptr(1) % defaultValue = 0
      allocate(i1Ptr(1) % attLists(1))
      allocate(i1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'long_name', 'Index to the last edge in a column with at least one '&
//'active ocean cell on either side of it.')
      i1Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i1Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         i1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'maxLevelEdgeBot', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'maxLevelEdgeBot', i1Ptr)

! Define variable maxLevelVertexTop
      allocate(i1Ptr(1))

! Setting up time level 1
      i1Ptr(1) % fieldName = 'maxLevelVertexTop'
      i1Ptr(1) % isVarArray = .false.
      i1Ptr(1) % isDecomposed = .true.
      i1Ptr(1) % hasTimeDimension = .false.
      i1Ptr(1) % isPersistent = .true.
      i1Ptr(1) % isActive = .false.
! Setting up dimensions
      i1Ptr(1) % dimNames(1) = 'nVertices'
      i1Ptr(1) % defaultValue = 0
      allocate(i1Ptr(1) % attLists(1))
      allocate(i1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'long_name', 'Index to the last vertex in a column with all active cells '&
//'around it.')
      i1Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i1Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         i1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'maxLevelVertexTop', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'maxLevelVertexTop', i1Ptr)

! Define variable maxLevelVertexBot
      allocate(i1Ptr(1))

! Setting up time level 1
      i1Ptr(1) % fieldName = 'maxLevelVertexBot'
      i1Ptr(1) % isVarArray = .false.
      i1Ptr(1) % isDecomposed = .true.
      i1Ptr(1) % hasTimeDimension = .false.
      i1Ptr(1) % isPersistent = .true.
      i1Ptr(1) % isActive = .false.
! Setting up dimensions
      i1Ptr(1) % dimNames(1) = 'nVertices'
      i1Ptr(1) % defaultValue = 0
      allocate(i1Ptr(1) % attLists(1))
      allocate(i1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'long_name', 'Index to the last vertex in a column with at least one '&
//'active ocean cell around it.')
      i1Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i1Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         i1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'maxLevelVertexBot', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'maxLevelVertexBot', i1Ptr)

! Define variable refBottomDepth
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'refBottomDepth'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .false.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nVertLevels'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Reference depth of ocean for each vertical level. Used in '&
//'''z-level'' type runs.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'refBottomDepth', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'refBottomDepth', r1Ptr)

! Define variable refBottomDepthTopOfCell
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'refBottomDepthTopOfCell'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .false.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nVertLevelsP1'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Reference depth of ocean for each vertical interface. Used '&
//'in ''z-level'' type runs.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'refBottomDepthTopOfCell', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'refBottomDepthTopOfCell', r1Ptr)

! Define variable vertCoordMovementWeights
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'vertCoordMovementWeights'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .false.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nVertLevels'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Weights used for distribution of sea surface height '&
//'perturbations through multiple vertical levels.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'vertCoordMovementWeights', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'vertCoordMovementWeights', r1Ptr)

! Define variable boundaryEdge
      allocate(i2Ptr(1))

! Setting up time level 1
      i2Ptr(1) % fieldName = 'boundaryEdge'
      i2Ptr(1) % isVarArray = .false.
      i2Ptr(1) % isDecomposed = .true.
      i2Ptr(1) % hasTimeDimension = .false.
      i2Ptr(1) % isPersistent = .true.
      i2Ptr(1) % isActive = .false.
! Setting up dimensions
      i2Ptr(1) % dimNames(1) = 'nVertLevels'
      i2Ptr(1) % dimNames(2) = 'nEdges'
      i2Ptr(1) % defaultValue = 0
      allocate(i2Ptr(1) % attLists(1))
      allocate(i2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'long_name', 'Mask for determining boundary edges. A boundary edge has '&
//'only one active ocean cell neighboring it.')
      i2Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i2Ptr(1) % block => block

      i2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'boundaryEdge', i2Ptr)
      call mpas_pool_add_field(block % allFields, 'boundaryEdge', i2Ptr)

! Define variable boundaryVertex
      allocate(i2Ptr(1))

! Setting up time level 1
      i2Ptr(1) % fieldName = 'boundaryVertex'
      i2Ptr(1) % isVarArray = .false.
      i2Ptr(1) % isDecomposed = .true.
      i2Ptr(1) % hasTimeDimension = .false.
      i2Ptr(1) % isPersistent = .true.
      i2Ptr(1) % isActive = .false.
! Setting up dimensions
      i2Ptr(1) % dimNames(1) = 'nVertLevels'
      i2Ptr(1) % dimNames(2) = 'nVertices'
      i2Ptr(1) % defaultValue = 0
      allocate(i2Ptr(1) % attLists(1))
      allocate(i2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'long_name', 'Mask for determining boundary vertices. A boundary vertex '&
//'has at least one inactive cell neighboring it.')
      i2Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i2Ptr(1) % block => block

      i2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'boundaryVertex', i2Ptr)
      call mpas_pool_add_field(block % allFields, 'boundaryVertex', i2Ptr)

! Define variable boundaryCell
      allocate(i2Ptr(1))

! Setting up time level 1
      i2Ptr(1) % fieldName = 'boundaryCell'
      i2Ptr(1) % isVarArray = .false.
      i2Ptr(1) % isDecomposed = .true.
      i2Ptr(1) % hasTimeDimension = .false.
      i2Ptr(1) % isPersistent = .true.
      i2Ptr(1) % isActive = .false.
! Setting up dimensions
      i2Ptr(1) % dimNames(1) = 'nVertLevels'
      i2Ptr(1) % dimNames(2) = 'nCells'
      i2Ptr(1) % defaultValue = 0
      allocate(i2Ptr(1) % attLists(1))
      allocate(i2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'long_name', 'Mask for determining boundary cells. A boundary cell has '&
//'at least one inactive cell neighboring it.')
      i2Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i2Ptr(1) % block => block

      i2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'boundaryCell', i2Ptr)
      call mpas_pool_add_field(block % allFields, 'boundaryCell', i2Ptr)

! Define variable edgeMask
      allocate(i2Ptr(1))

! Setting up time level 1
      i2Ptr(1) % fieldName = 'edgeMask'
      i2Ptr(1) % isVarArray = .false.
      i2Ptr(1) % isDecomposed = .true.
      i2Ptr(1) % hasTimeDimension = .false.
      i2Ptr(1) % isPersistent = .true.
      i2Ptr(1) % isActive = .false.
! Setting up dimensions
      i2Ptr(1) % dimNames(1) = 'nVertLevels'
      i2Ptr(1) % dimNames(2) = 'nEdges'
      i2Ptr(1) % defaultValue = 0
      allocate(i2Ptr(1) % attLists(1))
      allocate(i2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'long_name', 'Mask on edges that determines if computations should be '&
//'done on edges.')
      i2Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i2Ptr(1) % block => block

      i2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'edgeMask', i2Ptr)
      call mpas_pool_add_field(block % allFields, 'edgeMask', i2Ptr)

! Define variable vertexMask
      allocate(i2Ptr(1))

! Setting up time level 1
      i2Ptr(1) % fieldName = 'vertexMask'
      i2Ptr(1) % isVarArray = .false.
      i2Ptr(1) % isDecomposed = .true.
      i2Ptr(1) % hasTimeDimension = .false.
      i2Ptr(1) % isPersistent = .true.
      i2Ptr(1) % isActive = .false.
! Setting up dimensions
      i2Ptr(1) % dimNames(1) = 'nVertLevels'
      i2Ptr(1) % dimNames(2) = 'nVertices'
      i2Ptr(1) % defaultValue = 0
      allocate(i2Ptr(1) % attLists(1))
      allocate(i2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'long_name', 'Mask on vertices that determines if computations should be '&
//'done on vertices.')
      i2Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i2Ptr(1) % block => block

      i2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'vertexMask', i2Ptr)
      call mpas_pool_add_field(block % allFields, 'vertexMask', i2Ptr)

! Define variable cellMask
      allocate(i2Ptr(1))

! Setting up time level 1
      i2Ptr(1) % fieldName = 'cellMask'
      i2Ptr(1) % isVarArray = .false.
      i2Ptr(1) % isDecomposed = .true.
      i2Ptr(1) % hasTimeDimension = .false.
      i2Ptr(1) % isPersistent = .true.
      i2Ptr(1) % isActive = .false.
! Setting up dimensions
      i2Ptr(1) % dimNames(1) = 'nVertLevels'
      i2Ptr(1) % dimNames(2) = 'nCells'
      i2Ptr(1) % defaultValue = 0
      allocate(i2Ptr(1) % attLists(1))
      allocate(i2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'long_name', 'Mask on cells that determines if computations should be '&
//'done on cells.')
      i2Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i2Ptr(1) % block => block

      i2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'cellMask', i2Ptr)
      call mpas_pool_add_field(block % allFields, 'cellMask', i2Ptr)

! Define variable edgeSignOnCell
      allocate(i2Ptr(1))

! Setting up time level 1
      i2Ptr(1) % fieldName = 'edgeSignOnCell'
      i2Ptr(1) % isVarArray = .false.
      i2Ptr(1) % isDecomposed = .true.
      i2Ptr(1) % hasTimeDimension = .false.
      i2Ptr(1) % isPersistent = .true.
      i2Ptr(1) % isActive = .false.
! Setting up dimensions
      i2Ptr(1) % dimNames(1) = 'maxEdges'
      i2Ptr(1) % dimNames(2) = 'nCells'
      i2Ptr(1) % defaultValue = 0
      allocate(i2Ptr(1) % attLists(1))
      allocate(i2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'long_name', 'Sign of edge contributions to a cell for each edge on '&
//'cell. Used for bit-reproducible loops. Represents directionality of vector connecting cells.')
      i2Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i2Ptr(1) % block => block

      i2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'edgeSignOnCell', i2Ptr)
      call mpas_pool_add_field(block % allFields, 'edgeSignOnCell', i2Ptr)

! Define variable edgeSignOnVertex
      allocate(i2Ptr(1))

! Setting up time level 1
      i2Ptr(1) % fieldName = 'edgeSignOnVertex'
      i2Ptr(1) % isVarArray = .false.
      i2Ptr(1) % isDecomposed = .true.
      i2Ptr(1) % hasTimeDimension = .false.
      i2Ptr(1) % isPersistent = .true.
      i2Ptr(1) % isActive = .false.
! Setting up dimensions
      i2Ptr(1) % dimNames(1) = 'maxEdges'
      i2Ptr(1) % dimNames(2) = 'nVertices'
      i2Ptr(1) % defaultValue = 0
      allocate(i2Ptr(1) % attLists(1))
      allocate(i2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'long_name', 'Sign of edge contributions to a vertex for each edge on '&
//'vertex. Used for bit-reproducible loops. Represents directionality of vector connecting vertices.')
      i2Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i2Ptr(1) % block => block

      i2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'edgeSignOnVertex', i2Ptr)
      call mpas_pool_add_field(block % allFields, 'edgeSignOnVertex', i2Ptr)

! Define variable kiteIndexOnCell
      allocate(i2Ptr(1))

! Setting up time level 1
      i2Ptr(1) % fieldName = 'kiteIndexOnCell'
      i2Ptr(1) % isVarArray = .false.
      i2Ptr(1) % isDecomposed = .true.
      i2Ptr(1) % hasTimeDimension = .false.
      i2Ptr(1) % isPersistent = .true.
      i2Ptr(1) % isActive = .false.
! Setting up dimensions
      i2Ptr(1) % dimNames(1) = 'maxEdges'
      i2Ptr(1) % dimNames(2) = 'nCells'
      i2Ptr(1) % defaultValue = 0
      allocate(i2Ptr(1) % attLists(1))
      allocate(i2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'long_name', 'Index of kite in dual grid, based on verticesOnCell.')
      i2Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i2Ptr(1) % block => block

      i2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'kiteIndexOnCell', i2Ptr)
      call mpas_pool_add_field(block % allFields, 'kiteIndexOnCell', i2Ptr)

! Define variable cullCell
      allocate(i1Ptr(1))

! Setting up time level 1
      i1Ptr(1) % fieldName = 'cullCell'
      i1Ptr(1) % isVarArray = .false.
      i1Ptr(1) % isDecomposed = .true.
      i1Ptr(1) % hasTimeDimension = .false.
      i1Ptr(1) % isPersistent = .true.
      i1Ptr(1) % isActive = .false.
! Setting up dimensions
      i1Ptr(1) % dimNames(1) = 'nCells'
      i1Ptr(1) % defaultValue = 0
      allocate(i1Ptr(1) % attLists(1))
      allocate(i1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'long_name', 'Array to hold integers that represent logicals determining '&
//'if a cell should be culled or not by the MpasCellCuller tool.')
      i1Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i1Ptr(1) % block => block

      if (cullCellsActive) then
         i1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'cullCell', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'cullCell', i1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_pool_mesh


   subroutine ocn_generate_pool_verticalMesh(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'verticalMesh', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'verticalMesh', newSubPool)

! Define variable restingThickness
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'restingThickness'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Layer thickness when the ocean is at rest, i.e. without '&
//'SSH or internal perturbations.')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'restingThickness', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'restingThickness', r2Ptr)

! Define variable refZMid
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'refZMid'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .false.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nVertLevels'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Reference mid z-coordinate of ocean for each vertical '&
//'level. This has a negative value.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'refZMid', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'refZMid', r1Ptr)

! Define variable refLayerThickness
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'refLayerThickness'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .false.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nVertLevels'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Reference layerThickness of ocean for each vertical '&
//'level.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'refLayerThickness', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'refLayerThickness', r1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_pool_verticalMesh


   subroutine ocn_generate_tend_subpool_tracersTend(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'tracersTend', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'tracersTend', newSubPool)

! Define var array activeTracersTend
      allocate(r3Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group activeGRP
! Define constituent var temperatureTend
! My Packages are activeTracersPKG
      if (activeTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureTend', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_temperatureTend', -1)
           end if
      end if
! Define constituent var salinityTend
! My packages are activeTracersPKG
      if (activeTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityTend', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityTend', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'activeGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_activeTracersTend', numConstituents)
      end if
! Defining time level 1
      allocate( r3Ptr(1) % constituentNames(numConstituents) )
      r3Ptr(1) % fieldName = 'activeTracersTend'
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isVarArray = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureTend', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'temperatureTend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityTend', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'salinityTend'
      end if

! Setup dimensions for       
      r3Ptr(1) % dimNames(1) = 'num_activeTracersTend'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nCells'

      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(size(r3Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r3Ptr(1) % constituentNames, dim=1)
         allocate(r3Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureTend', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'time tendency of potential temperature')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', '^\circ C s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'temperatureTend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityTend', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'time tendency of salinity measured as change '&
//'in practical salinity units per second')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'PSU s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'salinityTend'
      end if
      r3Ptr(1) % block => block

      if (activeTracersPKGActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'activeTracersTend', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'activeTracersTend', r3Ptr)

! Define var array debugTracersTend
      allocate(r3Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group debugGRP
! Define constituent var tracer1Tend
! My Packages are debugTracersPKG
      if (debugTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_tracer1Tend', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'debugGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_tracer1Tend', -1)
           end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'debugGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'debugGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'debugGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_debugTracersTend', numConstituents)
      end if
! Defining time level 1
      allocate( r3Ptr(1) % constituentNames(numConstituents) )
      r3Ptr(1) % fieldName = 'debugTracersTend'
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isVarArray = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_tracer1Tend', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'tracer1Tend'
      end if

! Setup dimensions for       
      r3Ptr(1) % dimNames(1) = 'num_debugTracersTend'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nCells'

      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(size(r3Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r3Ptr(1) % constituentNames, dim=1)
         allocate(r3Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_tracer1Tend', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Tendency for tracer1')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'tracer1')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'tracer1Tend'
      end if
      r3Ptr(1) % block => block

      if (debugTracersPKGActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'debugTracersTend', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'debugTracersTend', r3Ptr)

! Define var array ecosysTracersTend
      allocate(r3Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group ecosysGRP
! Define constituent var PO4Tend
! My Packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_PO4Tend', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_PO4Tend', -1)
           end if
      end if
! Define constituent var NO3Tend
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_NO3Tend', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_NO3Tend', -1)
         end if
      end if
! Define constituent var SiO3Tend
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_SiO3Tend', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_SiO3Tend', -1)
         end if
      end if
! Define constituent var NH4Tend
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_NH4Tend', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_NH4Tend', -1)
         end if
      end if
! Define constituent var FeTend
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_FeTend', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_FeTend', -1)
         end if
      end if
! Define constituent var O2Tend
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_O2Tend', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_O2Tend', -1)
         end if
      end if
! Define constituent var DICTend
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DICTend', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DICTend', -1)
         end if
      end if
! Define constituent var DIC_ALT_CO2Tend
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DIC_ALT_CO2Tend', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DIC_ALT_CO2Tend', -1)
         end if
      end if
! Define constituent var ALKTend
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_ALKTend', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_ALKTend', -1)
         end if
      end if
! Define constituent var DOCTend
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOCTend', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOCTend', -1)
         end if
      end if
! Define constituent var DONTend
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DONTend', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DONTend', -1)
         end if
      end if
! Define constituent var DOFeTend
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOFeTend', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOFeTend', -1)
         end if
      end if
! Define constituent var DOPTend
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOPTend', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOPTend', -1)
         end if
      end if
! Define constituent var DOPrTend
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOPrTend', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOPrTend', -1)
         end if
      end if
! Define constituent var DONrTend
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DONrTend', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DONrTend', -1)
         end if
      end if
! Define constituent var zooCTend
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_zooCTend', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_zooCTend', -1)
         end if
      end if
! Define constituent var spChlTend
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spChlTend', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spChlTend', -1)
         end if
      end if
! Define constituent var spCTend
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spCTend', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spCTend', -1)
         end if
      end if
! Define constituent var spFeTend
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spFeTend', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spFeTend', -1)
         end if
      end if
! Define constituent var spCaCO3Tend
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spCaCO3Tend', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spCaCO3Tend', -1)
         end if
      end if
! Define constituent var diatChlTend
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatChlTend', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatChlTend', -1)
         end if
      end if
! Define constituent var diatCTend
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatCTend', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatCTend', -1)
         end if
      end if
! Define constituent var diatFeTend
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatFeTend', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatFeTend', -1)
         end if
      end if
! Define constituent var diatSiTend
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatSiTend', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatSiTend', -1)
         end if
      end if
! Define constituent var diazChlTend
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazChlTend', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazChlTend', -1)
         end if
      end if
! Define constituent var diazCTend
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazCTend', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazCTend', -1)
         end if
      end if
! Define constituent var diazFeTend
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazFeTend', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazFeTend', -1)
         end if
      end if
! Define constituent var phaeoChlTend
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoChlTend', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoChlTend', -1)
         end if
      end if
! Define constituent var phaeoCTend
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoCTend', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoCTend', -1)
         end if
      end if
! Define constituent var phaeoFeTend
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoFeTend', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoFeTend', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_ecosysTracersTend', numConstituents)
      end if
! Defining time level 1
      allocate( r3Ptr(1) % constituentNames(numConstituents) )
      r3Ptr(1) % fieldName = 'ecosysTracersTend'
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isVarArray = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_PO4Tend', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'PO4Tend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_NO3Tend', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'NO3Tend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_SiO3Tend', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'SiO3Tend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_NH4Tend', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'NH4Tend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_FeTend', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'FeTend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_O2Tend', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'O2Tend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DICTend', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'DICTend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DIC_ALT_CO2Tend', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'DIC_ALT_CO2Tend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_ALKTend', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'ALKTend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOCTend', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'DOCTend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DONTend', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'DONTend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOFeTend', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'DOFeTend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOPTend', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'DOPTend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOPrTend', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'DOPrTend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DONrTend', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'DONrTend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_zooCTend', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'zooCTend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spChlTend', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'spChlTend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spCTend', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'spCTend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spFeTend', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'spFeTend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spCaCO3Tend', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'spCaCO3Tend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatChlTend', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'diatChlTend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatCTend', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'diatCTend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatFeTend', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'diatFeTend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatSiTend', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'diatSiTend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazChlTend', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'diazChlTend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazCTend', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'diazCTend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazFeTend', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'diazFeTend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoChlTend', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'phaeoChlTend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoCTend', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'phaeoCTend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoFeTend', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'phaeoFeTend'
      end if

! Setup dimensions for       
      r3Ptr(1) % dimNames(1) = 'num_ecosysTracersTend'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nCells'

      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(size(r3Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r3Ptr(1) % constituentNames, dim=1)
         allocate(r3Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_PO4Tend', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Inorganic Phosphate Tendency')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol P m^{-3} s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'PO4Tend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_NO3Tend', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Inorganic Nitrate Tendency')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol N m^{-3} s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'NO3Tend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_SiO3Tend', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Inorganic Silicate Tendency')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol Si m^{-3} s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'SiO3Tend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_NH4Tend', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Ammonia Tendency')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol N m^{-3} s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'NH4Tend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_FeTend', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Inorganic Iron Tendency')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol Fe m^{-3} s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'FeTend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_O2Tend', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Oxygen Tendency')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol O2 m^{-3} s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'O2Tend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DICTend', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Inorganic Carbon Tendency')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol C m^{-3} s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'DICTend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DIC_ALT_CO2Tend', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Inorganic Carbon, Alternative CO2 '&
//'Tendency')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol C m^{-3} s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'DIC_ALT_CO2Tend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_ALKTend', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Alkalinity Tendency')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'meq m^{-3} s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'ALKTend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOCTend', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Organic Carbon Tendency')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol C m^{-3} s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'DOCTend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DONTend', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Organic Nitrogen Tendency')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol N m^{-3} s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'DONTend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOFeTend', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Organic Iron Tendency')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol Fe m^{-3} s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'DOFeTend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOPTend', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Organic Phosphorus Tendency')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol P m^{-3} s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'DOPTend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOPrTend', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Refractory DOP Tendency')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol P m^{-3} s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'DOPrTend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DONrTend', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Refractory DON Tendency')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol N m^{-3} s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'DONrTend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_zooCTend', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Zooplankton Carbon Tendency')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol C m^{-3} s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'zooCTend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spChlTend', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Small Phytoplankton Chlorophyll Tendency')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mg m^{-3} s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'spChlTend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spCTend', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Small Phytoplankton Carbon Tendency')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol C m^{-3} s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'spCTend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spFeTend', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Small Phytoplankton Iron Tendency')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol Fe m^{-3} s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'spFeTend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spCaCO3Tend', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Small Phytoplankton Calcium Carbonate '&
//'Tendency')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol C m^{-3} s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'spCaCO3Tend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatChlTend', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Diatom Chlorophyll Tendency')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mg m^{-3} s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'diatChlTend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatCTend', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Diatom Carbon Tendency')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol C m^{-3} s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'diatCTend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatFeTend', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Diatom Iron Tendency')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol Fe m^{-3} s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'diatFeTend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatSiTend', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Diatom Silicate Tendency')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol Si m^{-3} s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'diatSiTend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazChlTend', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Diazotroph Chlorophyll Tendency')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mg m^{-3} s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'diazChlTend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazCTend', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Diazotroph Carbon Tendency')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol C m^{-3} s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'diazCTend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazFeTend', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Diazotroph Iron Tendency')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol Fe m^{-3} s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'diazFeTend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoChlTend', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Phaeocystis Chlorophyll Tendency')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mg m^{-3} s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'phaeoChlTend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoCTend', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Phaeocystis Carbon Tendency')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol C m^{-3} s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'phaeoCTend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoFeTend', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Phaeocystis Iron Tendency')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol Fe m^{-3} s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'phaeoFeTend'
      end if
      r3Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosysTracersTend', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosysTracersTend', r3Ptr)

! Define var array DMSTracersTend
      allocate(r3Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group DMSGRP
! Define constituent var DMSTend
! My Packages are DMSTracersPKG
      if (DMSTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DMSTend', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'DMSGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_DMSTend', -1)
           end if
      end if
! Define constituent var DMSPTend
! My packages are DMSTracersPKG
      if (DMSTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DMSPTend', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'DMSGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DMSPTend', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'DMSGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'DMSGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'DMSGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_DMSTracersTend', numConstituents)
      end if
! Defining time level 1
      allocate( r3Ptr(1) % constituentNames(numConstituents) )
      r3Ptr(1) % fieldName = 'DMSTracersTend'
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isVarArray = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DMSTend', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'DMSTend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DMSPTend', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'DMSPTend'
      end if

! Setup dimensions for       
      r3Ptr(1) % dimNames(1) = 'num_DMSTracersTend'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nCells'

      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(size(r3Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r3Ptr(1) % constituentNames, dim=1)
         allocate(r3Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DMSTend', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dimethyl Sulfide Tendency')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol m^{-3} s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'DMSTend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DMSPTend', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dimethyl Sulfoniopropionate Tendency')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol m^{-3} s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'DMSPTend'
      end if
      r3Ptr(1) % block => block

      if (DMSTracersPKGActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'DMSTracersTend', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'DMSTracersTend', r3Ptr)

! Define var array MacroMoleculesTracersTend
      allocate(r3Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group MacroMoleculesGRP
! Define constituent var PROTTend
! My Packages are MacroMoleculesTracersPKG
      if (MacroMoleculesTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_PROTTend', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_PROTTend', -1)
           end if
      end if
! Define constituent var POLYTend
! My packages are MacroMoleculesTracersPKG
      if (MacroMoleculesTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_POLYTend', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_POLYTend', -1)
         end if
      end if
! Define constituent var LIPTend
! My packages are MacroMoleculesTracersPKG
      if (MacroMoleculesTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_LIPTend', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_LIPTend', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_MacroMoleculesTracersTend', numConstituents)
      end if
! Defining time level 1
      allocate( r3Ptr(1) % constituentNames(numConstituents) )
      r3Ptr(1) % fieldName = 'MacroMoleculesTracersTend'
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isVarArray = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_PROTTend', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'PROTTend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_POLYTend', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'POLYTend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_LIPTend', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'LIPTend'
      end if

! Setup dimensions for       
      r3Ptr(1) % dimNames(1) = 'num_MacroMoleculesTracersTend'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nCells'

      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(size(r3Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r3Ptr(1) % constituentNames, dim=1)
         allocate(r3Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_PROTTend', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Proteins Tendency')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol m^{-3} s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'PROTTend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_POLYTend', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Polysaccharides Tendency')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol m^{-3} s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'POLYTend'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_LIPTend', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Lipids Tendency')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol m^{-3} s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'LIPTend'
      end if
      r3Ptr(1) % block => block

      if (MacroMoleculesTracersPKGActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'MacroMoleculesTracersTend', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'MacroMoleculesTracersTend', r3Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_tend_subpool_tracersTend


   subroutine ocn_generate_pool_tend(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'tend', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'tend', newSubPool)

! Define variable tendNormalVelocity
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'tendNormalVelocity'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nEdges'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-2}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'time tendency of normal component of velocity')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'normalVelocity', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'tendNormalVelocity', r2Ptr)

! Define variable tendLayerThickness
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'tendLayerThickness'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'time tendency of layer thickness')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'layerThickness', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'tendLayerThickness', r2Ptr)

! Define variable tendSSH
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'tendSSH'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'time tendency of sea-surface height')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (forwardModeActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ssh', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'tendSSH', r1Ptr)

! Define variable tendHighFreqThickness
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'tendHighFreqThickness'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'time tendency of high frequency-filtered layer thickness')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (thicknessFilterActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'highFreqThickness', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'tendHighFreqThickness', r2Ptr)

! Define variable tendLowFreqDivergence
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'tendLowFreqDivergence'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'time tendency of low frequency-filtered divergence')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (thicknessFilterActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'lowFreqDivergence', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'tendLowFreqDivergence', r2Ptr)


      call ocn_generate_tend_subpool_tracersTend(block, newSubPool, dimensionPool, packagePool)

      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_pool_tend


   subroutine ocn_generate_pool_diagnostics(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'diagnostics', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'diagnostics', newSubPool)

! Define var array activeTracerSurfaceFluxTendency
      allocate(r3Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group activeTracerSfcFluxTendGroup
! Define constituent var temperatureSurfaceFluxTendency
! My Packages are tracerBudget
      if (tracerBudgetActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureSurfaceFluxTendency', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracerSfcFluxTendGroup_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_temperatureSurfaceFluxTendency', -1)
           end if
      end if
! Define constituent var salinitySurfaceFluxTendency
! My packages are tracerBudget
      if (tracerBudgetActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinitySurfaceFluxTendency', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracerSfcFluxTendGroup_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinitySurfaceFluxTendency', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracerSfcFluxTendGroup_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'activeTracerSfcFluxTendGroup_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracerSfcFluxTendGroup_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_activeTracerSurfaceFluxTendency', numConstituents)
      end if
! Defining time level 1
      allocate( r3Ptr(1) % constituentNames(numConstituents) )
      r3Ptr(1) % fieldName = 'activeTracerSurfaceFluxTendency'
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isVarArray = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureSurfaceFluxTendency', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'temperatureSurfaceFluxTendency'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinitySurfaceFluxTendency', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'salinitySurfaceFluxTendency'
      end if

! Setup dimensions for       
      r3Ptr(1) % dimNames(1) = 'num_activeTracerSurfaceFluxTendency'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nCells'

      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(size(r3Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r3Ptr(1) % constituentNames, dim=1)
         allocate(r3Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureSurfaceFluxTendency', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'potential temperature tendency due to surface '&
//'fluxes')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'degrees Celsius per second')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'temperatureSurfaceFluxTendency'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinitySurfaceFluxTendency', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'salinity tendency due to surface fluxes')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'PSU per second')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'salinitySurfaceFluxTendency'
      end if
      r3Ptr(1) % block => block

      if (tracerBudgetActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'activeTracerSurfaceFluxTendency', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'activeTracerSurfaceFluxTendency', r3Ptr)

! Define var array activeTracerNonLocalTendency
      allocate(r3Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group activeTracerNLTendGroup
! Define constituent var temperatureNonLocalTendency
! My Packages are tracerBudget
      if (tracerBudgetActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureNonLocalTendency', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracerNLTendGroup_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_temperatureNonLocalTendency', -1)
           end if
      end if
! Define constituent var salinityNonLocalTendency
! My packages are tracerBudget
      if (tracerBudgetActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityNonLocalTendency', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracerNLTendGroup_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityNonLocalTendency', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracerNLTendGroup_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'activeTracerNLTendGroup_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracerNLTendGroup_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_activeTracerNonLocalTendency', numConstituents)
      end if
! Defining time level 1
      allocate( r3Ptr(1) % constituentNames(numConstituents) )
      r3Ptr(1) % fieldName = 'activeTracerNonLocalTendency'
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isVarArray = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureNonLocalTendency', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'temperatureNonLocalTendency'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityNonLocalTendency', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'salinityNonLocalTendency'
      end if

! Setup dimensions for       
      r3Ptr(1) % dimNames(1) = 'num_activeTracerNonLocalTendency'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nCells'

      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(size(r3Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r3Ptr(1) % constituentNames, dim=1)
         allocate(r3Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureNonLocalTendency', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'potential temperature tendency due to kpp '&
//'non-local flux')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'degrees Celsius per second')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'temperatureNonLocalTendency'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityNonLocalTendency', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'salinity tendency due to kpp non-local flux')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'PSU per second')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'salinityNonLocalTendency'
      end if
      r3Ptr(1) % block => block

      if (tracerBudgetActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'activeTracerNonLocalTendency', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'activeTracerNonLocalTendency', r3Ptr)

! Define var array activeTracerVerticalAdvectionTopFlux
      allocate(r3Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group activeTracerVertTopFluxGroup
! Define constituent var temperatureVerticalAdvectionTopFlux
! My Packages are tracerBudget
      if (tracerBudgetActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureVerticalAdvectionTopFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracerVertTopFluxGroup_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_temperatureVerticalAdvectionTopFlux', -1)
           end if
      end if
! Define constituent var salinityVerticalAdvectionTopFlux
! My packages are tracerBudget
      if (tracerBudgetActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityVerticalAdvectionTopFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracerVertTopFluxGroup_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityVerticalAdvectionTopFlux', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracerVertTopFluxGroup_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'activeTracerVertTopFluxGroup_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracerVertTopFluxGroup_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_activeTracerVerticalAdvectionTopFlux', numConstituents)
      end if
! Defining time level 1
      allocate( r3Ptr(1) % constituentNames(numConstituents) )
      r3Ptr(1) % fieldName = 'activeTracerVerticalAdvectionTopFlux'
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isVarArray = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureVerticalAdvectionTopFlux', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'temperatureVerticalAdvectionTopFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityVerticalAdvectionTopFlux', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'salinityVerticalAdvectionTopFlux'
      end if

! Setup dimensions for       
      r3Ptr(1) % dimNames(1) = 'num_activeTracerVerticalAdvectionTopFlux'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nCells'

      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(size(r3Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r3Ptr(1) % constituentNames, dim=1)
         allocate(r3Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureVerticalAdvectionTopFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'potential temperature vertical advective flux '&
//'through top of cell')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'C m s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'temperatureVerticalAdvectionTopFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityVerticalAdvectionTopFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'salinity advective vertical advective flux '&
//'through top of cell')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'PSU m s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'salinityVerticalAdvectionTopFlux'
      end if
      r3Ptr(1) % block => block

      if (tracerBudgetActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'activeTracerVerticalAdvectionTopFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'activeTracerVerticalAdvectionTopFlux', r3Ptr)

! Define var array activeTracerHorizontalAdvectionEdgeFlux
      allocate(r3Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group activeTracerHorAdvEdgeFluxGroup
! Define constituent var temperatureHorizontalAdvectionEdgeFlux
! My Packages are tracerBudget
      if (tracerBudgetActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureHorizontalAdvectionEdgeFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracerHorAdvEdgeFluxGroup_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_temperatureHorizontalAdvectionEdgeFlux', -1)
           end if
      end if
! Define constituent var salinityHorizontalAdvectionEdgeFlux
! My packages are tracerBudget
      if (tracerBudgetActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityHorizontalAdvectionEdgeFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracerHorAdvEdgeFluxGroup_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityHorizontalAdvectionEdgeFlux', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracerHorAdvEdgeFluxGroup_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'activeTracerHorAdvEdgeFluxGroup_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracerHorAdvEdgeFluxGroup_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_activeTracerHorizontalAdvectionEdgeFlux', numConstituents)
      end if
! Defining time level 1
      allocate( r3Ptr(1) % constituentNames(numConstituents) )
      r3Ptr(1) % fieldName = 'activeTracerHorizontalAdvectionEdgeFlux'
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isVarArray = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureHorizontalAdvectionEdgeFlux', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'temperatureHorizontalAdvectionEdgeFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityHorizontalAdvectionEdgeFlux', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'salinityHorizontalAdvectionEdgeFlux'
      end if

! Setup dimensions for       
      r3Ptr(1) % dimNames(1) = 'num_activeTracerHorizontalAdvectionEdgeFlux'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nEdges'

      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(size(r3Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r3Ptr(1) % constituentNames, dim=1)
         allocate(r3Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureHorizontalAdvectionEdgeFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'potential temperature advective flux due to '&
//'horizontal advection through edges')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'C m s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'temperatureHorizontalAdvectionEdgeFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityHorizontalAdvectionEdgeFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'salinity advective flux due to horizontal '&
//'advection through edges')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'PSU m s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'salinityHorizontalAdvectionEdgeFlux'
      end if
      r3Ptr(1) % block => block

      if (tracerBudgetActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'activeTracerHorizontalAdvectionEdgeFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'activeTracerHorizontalAdvectionEdgeFlux', r3Ptr)

! Define var array activeTracerHorizontalAdvectionTendency
      allocate(r3Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group activeTracerHorAdvTendGroup
! Define constituent var temperatureHorizontalAdvectionTendency
! My Packages are tracerBudget
      if (tracerBudgetActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureHorizontaldvectionTendency', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracerHorAdvTendGroup_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_temperatureHorizontaldvectionTendency', -1)
           end if
      end if
! Define constituent var salinityHorizontalAdvectionTendency
! My packages are tracerBudget
      if (tracerBudgetActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityHorizontalAdvectionTendency', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracerHorAdvTendGroup_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityHorizontalAdvectionTendency', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracerHorAdvTendGroup_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'activeTracerHorAdvTendGroup_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracerHorAdvTendGroup_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_activeTracerHorizontalAdvectionTendency', numConstituents)
      end if
! Defining time level 1
      allocate( r3Ptr(1) % constituentNames(numConstituents) )
      r3Ptr(1) % fieldName = 'activeTracerHorizontalAdvectionTendency'
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isVarArray = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureHorizontaldvectionTendency', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'temperatureHorizontalAdvectionTendency'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityHorizontalAdvectionTendency', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'salinityHorizontalAdvectionTendency'
      end if

! Setup dimensions for       
      r3Ptr(1) % dimNames(1) = 'num_activeTracerHorizontalAdvectionTendency'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nCells'

      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(size(r3Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r3Ptr(1) % constituentNames, dim=1)
         allocate(r3Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureHorizontaldvectionTendency', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'potential temperature tendency due to '&
//'horizontal advection')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'degrees Celsius per second')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'temperatureHorizontalAdvectionTendency'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityHorizontalAdvectionTendency', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'salinity tendency due to horizontal '&
//'advection')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'PSU per second')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'salinityHorizontalAdvectionTendency'
      end if
      r3Ptr(1) % block => block

      if (tracerBudgetActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'activeTracerHorizontalAdvectionTendency', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'activeTracerHorizontalAdvectionTendency', r3Ptr)

! Define var array activeTracerVerticalAdvectionTendency
      allocate(r3Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group activeTracerVertAdvTendGroup
! Define constituent var temperatureVerticalAdvectionTendency
! My Packages are tracerBudget
      if (tracerBudgetActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureVerticalAdvectionTendency', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracerVertAdvTendGroup_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_temperatureVerticalAdvectionTendency', -1)
           end if
      end if
! Define constituent var salinityVerticalAdvectionTendency
! My packages are tracerBudget
      if (tracerBudgetActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityVerticalAdvectionTendency', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracerVertAdvTendGroup_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityVerticalAdvectionTendency', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracerVertAdvTendGroup_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'activeTracerVertAdvTendGroup_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracerVertAdvTendGroup_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_activeTracerVerticalAdvectionTendency', numConstituents)
      end if
! Defining time level 1
      allocate( r3Ptr(1) % constituentNames(numConstituents) )
      r3Ptr(1) % fieldName = 'activeTracerVerticalAdvectionTendency'
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isVarArray = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureVerticalAdvectionTendency', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'temperatureVerticalAdvectionTendency'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityVerticalAdvectionTendency', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'salinityVerticalAdvectionTendency'
      end if

! Setup dimensions for       
      r3Ptr(1) % dimNames(1) = 'num_activeTracerVerticalAdvectionTendency'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nCells'

      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(size(r3Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r3Ptr(1) % constituentNames, dim=1)
         allocate(r3Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureVerticalAdvectionTendency', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'potential temperature tendency due to '&
//'vertical advection')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'degrees Celsius per second')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'temperatureVerticalAdvectionTendency'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityVerticalAdvectionTendency', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'salinity tendency due to vertical advection')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'PSU per second')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'salinityVerticalAdvectionTendency'
      end if
      r3Ptr(1) % block => block

      if (tracerBudgetActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'activeTracerVerticalAdvectionTendency', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'activeTracerVerticalAdvectionTendency', r3Ptr)

! Define var array activeTracerVertMixTendency
      allocate(r3Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group activeTracerVertMixTendGroup
! Define constituent var temperatureVertMixTendency
! My Packages are tracerBudget
      if (tracerBudgetActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureVertMixTendency', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracerVertMixTendGroup_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_temperatureVertMixTendency', -1)
           end if
      end if
! Define constituent var salinityVertMixTendency
! My packages are tracerBudget
      if (tracerBudgetActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityVertMixTendency', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracerVertMixTendGroup_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityVertMixTendency', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracerVertMixTendGroup_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'activeTracerVertMixTendGroup_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracerVertMixTendGroup_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_activeTracerVertMixTendency', numConstituents)
      end if
! Defining time level 1
      allocate( r3Ptr(1) % constituentNames(numConstituents) )
      r3Ptr(1) % fieldName = 'activeTracerVertMixTendency'
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isVarArray = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureVertMixTendency', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'temperatureVertMixTendency'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityVertMixTendency', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'salinityVertMixTendency'
      end if

! Setup dimensions for       
      r3Ptr(1) % dimNames(1) = 'num_activeTracerVertMixTendency'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nCells'

      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(size(r3Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r3Ptr(1) % constituentNames, dim=1)
         allocate(r3Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureVertMixTendency', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'potential temperature tendency due to '&
//'vertical mixing')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'degrees Celsius per second')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'temperatureVertMixTendency'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityVertMixTendency', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'salinity tendency due to vertical mixing')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'PSU per second')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'salinityVertMixTendency'
      end if
      r3Ptr(1) % block => block

      if (tracerBudgetActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'activeTracerVertMixTendency', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'activeTracerVertMixTendency', r3Ptr)

! Define var array tracersSurfaceValue
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group surfaceValues
! Define constituent var temperatureSurfaceValue
! My Packages are (null)
      index_counter = index_counter + 1
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'index_temperatureSurfaceValue', index_counter)
      end if
      group_counter = group_counter + 1
      if (.not. group_started) then
         group_start = index_counter
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'surfaceValues_start', group_start)
         end if
         group_started = .true.
      end if
! Define constituent var salinitySurfaceValue
! My packages are (null)
      index_counter = index_counter + 1
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'index_salinitySurfaceValue', index_counter)
      end if
      group_counter = group_counter + 1
      if (.not. group_started) then
         group_start = index_counter
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'surfaceValues_start', group_start)
         end if
         group_started = .true.
      end if
      if (.not. group_started) then
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'surfaceValues_start', -1)
            call mpas_pool_add_dimension(newSubPool, 'surfaceValues_end', -1)
         end if
      else
         group_started = .false.
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'surfaceValues_end', index_counter)
         end if
      end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_tracersSurfaceValue', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'tracersSurfaceValue'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureSurfaceValue', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'temperatureSurfaceValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinitySurfaceValue', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'salinitySurfaceValue'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_tracersSurfaceValue'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureSurfaceValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'potential temperature extrapolated to ocean '&
//'surface')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'degrees Celsius')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'temperatureSurfaceValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinitySurfaceValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'salinity extrapolated to ocean surface')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'PSU')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'salinitySurfaceValue'
      end if
      r2Ptr(1) % block => block

            r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'tracersSurfaceValue', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'tracersSurfaceValue', r2Ptr)

! Define var array tracersSurfaceLayerValue
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group surfaceLayerValues
! Define constituent var temperatureSurfaceLayerValue
! My Packages are forwardMode;analysisMode
      if (forwardModeActive .or. analysisModeActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureSurfaceLayerValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'surfaceLayerValues_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_temperatureSurfaceLayerValue', -1)
           end if
      end if
! Define constituent var salinitySurfaceLayerValue
! My packages are forwardMode;analysisMode
      if (forwardModeActive .or. analysisModeActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinitySurfaceLayerValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'surfaceLayerValues_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinitySurfaceLayerValue', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'surfaceLayerValues_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'surfaceLayerValues_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'surfaceLayerValues_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_tracersSurfaceLayerValue', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'tracersSurfaceLayerValue'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureSurfaceLayerValue', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'temperatureSurfaceLayerValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinitySurfaceLayerValue', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'salinitySurfaceLayerValue'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_tracersSurfaceLayerValue'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureSurfaceLayerValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'potential temperature averaged over ocean '&
//'surface layer (generally 0.1 of the ocean boundary layer)')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'degrees Celsius')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'temperatureSurfaceLayerValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinitySurfaceLayerValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'salinity averaged over ocean surface layer '&
//'(generally 0.1 of the ocean boundary layer)')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'PSU')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'salinitySurfaceLayerValue'
      end if
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'tracersSurfaceLayerValue', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'tracersSurfaceLayerValue', r2Ptr)

! Define var array surfaceVelocity
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group vel_zonal
! Define constituent var surfaceVelocityZonal
! My Packages are forwardMode;analysisMode
      if (forwardModeActive .or. analysisModeActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_surfaceVelocityZonal', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vel_zonal_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_surfaceVelocityZonal', -1)
           end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vel_zonal_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'vel_zonal_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vel_zonal_end', index_counter)
            end if
         end if
! End of group       
! Starting group vel_meridional
! Define constituent var surfaceVelocityMeridional
! My Packages are forwardMode;analysisMode
      if (forwardModeActive .or. analysisModeActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_surfaceVelocityMeridional', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vel_meridional_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_surfaceVelocityMeridional', -1)
           end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vel_meridional_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'vel_meridional_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vel_meridional_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_surfaceVelocity', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'surfaceVelocity'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_surfaceVelocityZonal', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'surfaceVelocityZonal'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_surfaceVelocityMeridional', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'surfaceVelocityMeridional'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_surfaceVelocity'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_surfaceVelocityZonal', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Zonal surface velocity reconstructed at cell '&
//'centers')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'surfaceVelocityZonal'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_surfaceVelocityMeridional', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Meridional surface velocity reconstructed at '&
//'cell centers')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'surfaceVelocityMeridional'
      end if
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'surfaceVelocity', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'surfaceVelocity', r2Ptr)

! Define var array SSHGradient
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group ssh_zonal
! Define constituent var SSHGradientZonal
! My Packages are forwardMode;analysisMode
      if (forwardModeActive .or. analysisModeActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_SSHGradientZonal', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ssh_zonal_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_SSHGradientZonal', -1)
           end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ssh_zonal_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'ssh_zonal_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ssh_zonal_end', index_counter)
            end if
         end if
! End of group       
! Starting group ssh_meridional
! Define constituent var SSHGradientMeridional
! My Packages are forwardMode;analysisMode
      if (forwardModeActive .or. analysisModeActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_SSHGradientMeridional', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ssh_meridional_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_SSHGradientMeridional', -1)
           end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ssh_meridional_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'ssh_meridional_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ssh_meridional_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_SSHGradient', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'SSHGradient'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_SSHGradientZonal', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'SSHGradientZonal'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_SSHGradientMeridional', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'SSHGradientMeridional'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_SSHGradient'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_SSHGradientZonal', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Zonal gradient of SSH reconstructed at cell '&
//'centers')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm m^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'SSHGradientZonal'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_SSHGradientMeridional', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Meridional gradient of SSH reconstructed at '&
//'cell centers')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm m^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'SSHGradientMeridional'
      end if
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'SSHGradient', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'SSHGradient', r2Ptr)

! Define var array vertNonLocalFlux
      allocate(r3Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group vertNonLocalFlux
! Define constituent var vertNonLocalFluxTemp
! My Packages are forwardMode;analysisMode
      if (forwardModeActive .or. analysisModeActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_vertNonLocalFluxTemp', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertNonLocalFlux_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_vertNonLocalFluxTemp', -1)
           end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertNonLocalFlux_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'vertNonLocalFlux_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertNonLocalFlux_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_vertNonLocalFlux', numConstituents)
      end if
! Defining time level 1
      allocate( r3Ptr(1) % constituentNames(numConstituents) )
      r3Ptr(1) % fieldName = 'vertNonLocalFlux'
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isVarArray = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_vertNonLocalFluxTemp', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'vertNonLocalFluxTemp'
      end if

! Setup dimensions for       
      r3Ptr(1) % dimNames(1) = 'num_vertNonLocalFlux'
      r3Ptr(1) % dimNames(2) = 'nVertLevelsP1'
      r3Ptr(1) % dimNames(3) = 'nCells'

      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(size(r3Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r3Ptr(1) % constituentNames, dim=1)
         allocate(r3Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_vertNonLocalFluxTemp', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'CVMix/KPP: nonlocal boundary layer mixing '&
//'term for temperature')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'nondimensional')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'vertNonLocalFluxTemp'
      end if
      r3Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'vertNonLocalFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'vertNonLocalFlux', r3Ptr)

! Define var array landIceBoundaryLayerTracers
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group landIceBoundaryLayerValues
! Define constituent var landIceBoundaryLayerTemperature
! My Packages are landIceFluxesPKG
      if (landIceFluxesPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_landIceBoundaryLayerTemperature', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'landIceBoundaryLayerValues_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_landIceBoundaryLayerTemperature', -1)
           end if
      end if
! Define constituent var landIceBoundaryLayerSalinity
! My packages are landIceFluxesPKG
      if (landIceFluxesPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_landIceBoundaryLayerSalinity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'landIceBoundaryLayerValues_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_landIceBoundaryLayerSalinity', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'landIceBoundaryLayerValues_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'landIceBoundaryLayerValues_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'landIceBoundaryLayerValues_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_landIceBoundaryLayerTracers', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'landIceBoundaryLayerTracers'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_landIceBoundaryLayerTemperature', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'landIceBoundaryLayerTemperature'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_landIceBoundaryLayerSalinity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'landIceBoundaryLayerSalinity'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_landIceBoundaryLayerTracers'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_landIceBoundaryLayerTemperature', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'The temperature averaged over the '&
//'sub-ice-shelf boundary layer')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'C')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'landIceBoundaryLayerTemperature'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_landIceBoundaryLayerSalinity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'The salinity averaged over the sub-ice-shelf '&
//'boundary layer')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'PSU')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'landIceBoundaryLayerSalinity'
      end if
      r2Ptr(1) % block => block

      if (landIceFluxesPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'landIceBoundaryLayerTracers', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'landIceBoundaryLayerTracers', r2Ptr)

! Define var array landIceTracerTransferVelocities
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group landIceTransferVelocityValues
! Define constituent var landIceHeatTransferVelocity
! My Packages are landIceFluxesPKG
      if (landIceFluxesPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_landIceHeatTransferVelocity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'landIceTransferVelocityValues_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_landIceHeatTransferVelocity', -1)
           end if
      end if
! Define constituent var landIceSaltTransferVelocity
! My packages are landIceFluxesPKG
      if (landIceFluxesPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_landIceSaltTransferVelocity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'landIceTransferVelocityValues_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_landIceSaltTransferVelocity', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'landIceTransferVelocityValues_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'landIceTransferVelocityValues_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'landIceTransferVelocityValues_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_landIceTracerTransferVelocities', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'landIceTracerTransferVelocities'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_landIceHeatTransferVelocity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'landIceHeatTransferVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_landIceSaltTransferVelocity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'landIceSaltTransferVelocity'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_landIceTracerTransferVelocities'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_landIceHeatTransferVelocity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'friction velocity times nondimensional heat '&
//'transfer coefficient')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'landIceHeatTransferVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_landIceSaltTransferVelocity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'friction velocity times nondimensional salt '&
//'transfer coefficient')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'landIceSaltTransferVelocity'
      end if
      r2Ptr(1) % block => block

      if (landIceFluxesPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'landIceTracerTransferVelocities', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'landIceTracerTransferVelocities', r2Ptr)

! Define variable xtime
      allocate(c0Ptr(1))

! Setting up time level 1
      c0Ptr(1) % fieldName = 'xtime'
      c0Ptr(1) % isVarArray = .false.
      c0Ptr(1) % isDecomposed = .false.
      c0Ptr(1) % hasTimeDimension = .true.
      c0Ptr(1) % defaultValue = ''
      c0Ptr(1) % scalar = ''
      allocate(c0Ptr(1) % attLists(1))
      allocate(c0Ptr(1) % attLists(1) % attList)
      call mpas_add_att(c0Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(c0Ptr(1) % attLists(1) % attList, 'long_name', 'model time, with format ''YYYY-MM-DD_HH:MM:SS''')
      c0Ptr(1) % missingValue = MPAS_CHAR_FILLVAL
      c0Ptr(1) % block => block

      c0Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'xtime', c0Ptr)
      call mpas_pool_add_field(block % allFields, 'xtime', c0Ptr)

! Define variable simulationStartTime
      allocate(c0Ptr(1))

! Setting up time level 1
      c0Ptr(1) % fieldName = 'simulationStartTime'
      c0Ptr(1) % isVarArray = .false.
      c0Ptr(1) % isDecomposed = .false.
      c0Ptr(1) % hasTimeDimension = .false.
      c0Ptr(1) % defaultValue = 'no_date_available'
      c0Ptr(1) % scalar = 'no_date_available'
      allocate(c0Ptr(1) % attLists(1))
      allocate(c0Ptr(1) % attLists(1) % attList)
      call mpas_add_att(c0Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(c0Ptr(1) % attLists(1) % attList, 'long_name', 'start time of first simulation, with format '&
//'''YYYY-MM-DD_HH:MM:SS''')
      c0Ptr(1) % missingValue = MPAS_CHAR_FILLVAL
      c0Ptr(1) % block => block

      c0Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'simulationStartTime', c0Ptr)
      call mpas_pool_add_field(block % allFields, 'simulationStartTime', c0Ptr)

! Define variable daysSinceStartOfSim
      allocate(r0Ptr(1))

! Setting up time level 1
      r0Ptr(1) % fieldName = 'daysSinceStartOfSim'
      r0Ptr(1) % isVarArray = .false.
      r0Ptr(1) % isDecomposed = .false.
      r0Ptr(1) % hasTimeDimension = .true.
      r0Ptr(1) % defaultValue = 0.0
      r0Ptr(1) % scalar = 0.0
      allocate(r0Ptr(1) % attLists(1))
      allocate(r0Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r0Ptr(1) % attLists(1) % attList, 'units', 'days')
      call mpas_add_att(r0Ptr(1) % attLists(1) % attList, 'long_name', 'Time since simulationStartTime, for plotting')
      r0Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r0Ptr(1) % block => block

      r0Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'daysSinceStartOfSim', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'daysSinceStartOfSim', r0Ptr)

! Define variable salinitySurfaceRestoringTendency
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'salinitySurfaceRestoringTendency'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm PSU/s')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'salinity tendency due to surface restoring')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (activeTracersSurfaceRestoringPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'salinitySurfaceRestoringTendency', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'salinitySurfaceRestoringTendency', r1Ptr)

! Define variable temperatureShortWaveTendency
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'temperatureShortWaveTendency'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'degrees Celsius per second')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'potential temperature tendency due to penetrating '&
//'shortwave')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (tracerBudgetActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'temperatureShortWaveTendency', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'temperatureShortWaveTendency', r2Ptr)

! Define variable normalVelocitySurfaceLayer
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'normalVelocitySurfaceLayer'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'normal velocity averaged over ocean surface layer '&
//'(generally 0.1 of the ocean boundary layer)')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'normalVelocitySurfaceLayer', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'normalVelocitySurfaceLayer', r1Ptr)

! Define variable zMid
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'zMid'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'z-coordinate of the mid-depth of the layer')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'zMid', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'zMid', r2Ptr)

! Define variable zTop
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'zTop'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'z-coordinate of the top of the layer')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'zTop', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'zTop', r2Ptr)

! Define variable density
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'density'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'kg m^{-3}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'density')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'density', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'density', r2Ptr)

! Define variable displacedDensity
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'displacedDensity'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'kg m^{-3}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Density displaced adiabatically to the mid-depth one layer '&
//'deeper.  That is, layer k has been displaced to the depth of layer k+1.')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'displacedDensity', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'displacedDensity', r2Ptr)

! Define variable potentialDensity
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'potentialDensity'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'kg m^{-3}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'potential density: density displaced adiabatically to the '&
//'mid-depth of top layer')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'potentialDensity', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'potentialDensity', r2Ptr)

! Define variable inSituThermalExpansionCoeff
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'inSituThermalExpansionCoeff'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'C^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Thermal expansion coefficient (alpha), defined as $-1/\rho '&
//'d\rho/dT$ (note negative sign).  This is in situ, i.e. not displaced to another depth.')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (inSituEOSActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'inSituThermalExpansionCoeff', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'inSituThermalExpansionCoeff', r2Ptr)

! Define variable inSituSalineContractionCoeff
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'inSituSalineContractionCoeff'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'PSU^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Saline contraction coefficient (beta), defined as $1/\rho '&
//'d\rho/dS$.  This is also called the haline contraction coefficient.  This is in situ, i.e. not displaced to another depth.')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (inSituEOSActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'inSituSalineContractionCoeff', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'inSituSalineContractionCoeff', r2Ptr)

! Define variable BruntVaisalaFreqTop
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'BruntVaisalaFreqTop'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 's^{-2}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Brunt Vaisala frequency defined at the center '&
//'(horizontally) and top (vertically) of cell')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'BruntVaisalaFreqTop', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'BruntVaisalaFreqTop', r2Ptr)

! Define variable montgomeryPotential
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'montgomeryPotential'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm^2 s^{-2}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Montgomery potential, may be used as the pressure for '&
//'isopycnal coordinates.')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'montgomeryPotential', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'montgomeryPotential', r2Ptr)

! Define variable pressure
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'pressure'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'N m^{-2}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'pressure used in the momentum equation')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'pressure', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'pressure', r2Ptr)

! Define variable modifySSHMask
      allocate(i1Ptr(1))

! Setting up time level 1
      i1Ptr(1) % fieldName = 'modifySSHMask'
      i1Ptr(1) % isVarArray = .false.
      i1Ptr(1) % isDecomposed = .true.
      i1Ptr(1) % hasTimeDimension = .true.
      i1Ptr(1) % isPersistent = .true.
      i1Ptr(1) % isActive = .false.
! Setting up dimensions
      i1Ptr(1) % dimNames(1) = 'nCells'
      i1Ptr(1) % defaultValue = 0
      allocate(i1Ptr(1) % attLists(1))
      allocate(i1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'long_name', 'A mask indicating where the SSH can be modified from '&
//'refSSH through iteriative init/forward runs.  The mask is 1 under (and perhaps near) ice shelves and 0 elsenwere.')
      i1Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i1Ptr(1) % block => block

      if (initModeActive) then
         i1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'modifySSHMask', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'modifySSHMask', i1Ptr)

! Define variable normalTransportVelocity
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'normalTransportVelocity'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nEdges'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'horizontal velocity used to transport mass and tracers')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'normalTransportVelocity', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'normalTransportVelocity', r2Ptr)

! Define variable wettingVelocity
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'wettingVelocity'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nEdges'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Velocity to prevent drying of cell.')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'wettingVelocity', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'wettingVelocity', r2Ptr)

! Define variable vertAleTransportTop
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'vertAleTransportTop'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevelsP1'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'vertical transport through the layer interface at the top '&
//'of the cell')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'vertAleTransportTop', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'vertAleTransportTop', r2Ptr)

! Define variable vertVelocityTop
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'vertVelocityTop'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevelsP1'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'vertical velocity defined at center (horizontally) and top '&
//'(vertically) of cell')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'vertVelocityTop', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'vertVelocityTop', r2Ptr)

! Define variable vertTransportVelocityTop
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'vertTransportVelocityTop'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevelsP1'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'vertical tracer-transport velocity defined at center '&
//'(horizontally) and top (vertically) of cell.  This is not the vertical ALE transport, but is Eulerian (fixed-frame) in the '&
//'vertical, and computed from the continuity equation from the horizontal total tracer-transport velocity.')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'vertTransportVelocityTop', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'vertTransportVelocityTop', r2Ptr)

! Define variable vertGMBolusVelocityTop
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'vertGMBolusVelocityTop'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevelsP1'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'vertical tracer-transport velocity defined at center '&
//'(horizontally) and top (vertically) of cell.  This is not the vertical ALE transport, but is Eulerian (fixed-frame) in the '&
//'vertical, and computed from the continuity equation from the horizontal GM Bolus velocity.')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'vertGMBolusVelocityTop', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'vertGMBolusVelocityTop', r2Ptr)

! Define variable tangentialVelocity
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'tangentialVelocity'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nEdges'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'horizontal velocity, tangential to an edge')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'tangentialVelocity', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'tangentialVelocity', r2Ptr)

! Define variable layerThicknessEdge
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'layerThicknessEdge'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nEdges'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'layer thickness averaged from cell center to edges')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'layerThicknessEdge', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'layerThicknessEdge', r2Ptr)

! Define variable layerThicknessVertex
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'layerThicknessVertex'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nVertices'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'layer thickness averaged from cell center to vertices')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'layerThicknessVertex', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'layerThicknessVertex', r2Ptr)

! Define variable kineticEnergyCell
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'kineticEnergyCell'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm^2 s^{-2}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'kinetic energy of horizonal velocity on cells')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'kineticEnergyCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'kineticEnergyCell', r2Ptr)

! Define variable viscosity
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'viscosity'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nEdges'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm^2 s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'horizontal viscosity')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'viscosity', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'viscosity', r2Ptr)

! Define variable divergence
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'divergence'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 's^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'divergence of horizonal velocity')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'divergence', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'divergence', r2Ptr)

! Define variable circulation
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'circulation'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nVertices'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm^2 s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'area-integrated vorticity')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'circulation', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'circulation', r2Ptr)

! Define variable relativeVorticity
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'relativeVorticity'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nVertices'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 's^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'curl of horizontal velocity, defined at vertices')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'relativeVorticity', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'relativeVorticity', r2Ptr)

! Define variable relativeVorticityCell
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'relativeVorticityCell'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 's^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'curl of horizontal velocity, averaged from vertices to '&
//'cell centers')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'relativeVorticityCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'relativeVorticityCell', r2Ptr)

! Define variable normalizedRelativeVorticityEdge
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'normalizedRelativeVorticityEdge'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nEdges'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 's^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'curl of horizontal velocity divided by layer thickness, '&
//'averaged from vertices to edges')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'normalizedRelativeVorticityEdge', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'normalizedRelativeVorticityEdge', r2Ptr)

! Define variable normalizedPlanetaryVorticityEdge
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'normalizedPlanetaryVorticityEdge'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nEdges'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 's^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'earth''s rotational rate (Coriolis parameter, f) divided '&
//'by layer thickness, averaged from vertices to edges')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'normalizedPlanetaryVorticityEdge', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'normalizedPlanetaryVorticityEdge', r2Ptr)

! Define variable normalizedRelativeVorticityCell
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'normalizedRelativeVorticityCell'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 's^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'curl of horizontal velocity divided by layer thickness, '&
//'averaged from vertices to cell centers')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'normalizedRelativeVorticityCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'normalizedRelativeVorticityCell', r2Ptr)

! Define variable barotropicForcing
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'barotropicForcing'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-2}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Barotropic tendency computed from the baroclinic equations '&
//'in stage 1 of the split-explicit algorithm.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'barotropicForcing', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'barotropicForcing', r1Ptr)

! Define variable barotropicThicknessFlux
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'barotropicThicknessFlux'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm^2 s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Barotropic thickness flux at each edge, used to advance '&
//'sea surface height in each subcycle of stage 2 of the split-explicit algorithm.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'barotropicThicknessFlux', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'barotropicThicknessFlux', r1Ptr)

! Define variable velocityX
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'velocityX'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'component of horizontal velocity in the x-direction '&
//'(cartesian)')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'velocityX', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'velocityX', r2Ptr)

! Define variable velocityY
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'velocityY'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'component of horizontal velocity in the y-direction '&
//'(cartesian)')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'velocityY', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'velocityY', r2Ptr)

! Define variable velocityZ
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'velocityZ'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'component of horizontal velocity in the z-direction '&
//'(cartesian)')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'velocityZ', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'velocityZ', r2Ptr)

! Define variable velocityZonal
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'velocityZonal'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'component of horizontal velocity in the eastward '&
//'direction')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'velocityZonal', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'velocityZonal', r2Ptr)

! Define variable velocityMeridional
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'velocityMeridional'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'component of horizontal velocity in the northward '&
//'direction')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'velocityMeridional', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'velocityMeridional', r2Ptr)

! Define variable transportVelocityX
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'transportVelocityX'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'component of horizontal velocity used to transport mass '&
//'and tracers in the x-direction (cartesian)')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'transportVelocityX', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'transportVelocityX', r2Ptr)

! Define variable transportVelocityY
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'transportVelocityY'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'component of horizontal velocity used to transport mass '&
//'and tracers in the y-direction (cartesian)')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'transportVelocityY', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'transportVelocityY', r2Ptr)

! Define variable transportVelocityZ
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'transportVelocityZ'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'component of horizontal velocity used to transport mass '&
//'and tracers in the z-direction (cartesian)')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'transportVelocityZ', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'transportVelocityZ', r2Ptr)

! Define variable transportVelocityZonal
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'transportVelocityZonal'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'component of horizontal velocity used to transport mass '&
//'and tracers in the eastward direction')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'transportVelocityZonal', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'transportVelocityZonal', r2Ptr)

! Define variable transportVelocityMeridional
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'transportVelocityMeridional'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'component of horizontal velocity used to transport mass '&
//'and tracers in the northward direction')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'transportVelocityMeridional', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'transportVelocityMeridional', r2Ptr)

! Define variable gradSSH
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'gradSSH'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', '')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Gradient of sea surface height at edges.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'gradSSH', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'gradSSH', r1Ptr)

! Define variable gradSSHX
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'gradSSHX'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', '')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'X Component of the gradient of sea surface height at cell '&
//'centers.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'gradSSHX', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'gradSSHX', r1Ptr)

! Define variable gradSSHY
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'gradSSHY'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', '')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Y Component of the gradient of sea surface height at cell '&
//'centers.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'gradSSHY', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'gradSSHY', r1Ptr)

! Define variable gradSSHZ
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'gradSSHZ'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', '')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Z Component of the gradient of sea surface height at cell '&
//'centers.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'gradSSHZ', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'gradSSHZ', r1Ptr)

! Define variable gradSSHZonal
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'gradSSHZonal'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', '')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Zonal Component of the gradient of sea surface height at '&
//'cell centers.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'gradSSHZonal', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'gradSSHZonal', r1Ptr)

! Define variable gradSSHMeridional
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'gradSSHMeridional'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', '')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Meridional Component of the gradient of sea surface height '&
//'at cell centers.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'gradSSHMeridional', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'gradSSHMeridional', r1Ptr)

! Define variable normalGMBolusVelocity
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'normalGMBolusVelocity'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nEdges'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Bolus velocity in Gent-McWilliams eddy parameterization')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'normalGMBolusVelocity', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'normalGMBolusVelocity', r2Ptr)

! Define variable cGMphaseSpeed
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'cGMphaseSpeed'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'phase speed for the bolus velocity calculation')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'cGMphaseSpeed', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'cGMphaseSpeed', r1Ptr)

! Define variable kappaGM3D
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'kappaGM3D'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nEdges'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'spatially and depth varying GM kappa')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'kappaGM3D', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'kappaGM3D', r2Ptr)

! Define variable GMBolusVelocityX
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'GMBolusVelocityX'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Bolus velocity in Gent-McWilliams eddy parameterization, '&
//'x-direction')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'GMBolusVelocityX', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'GMBolusVelocityX', r2Ptr)

! Define variable GMBolusVelocityY
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'GMBolusVelocityY'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Bolus velocity in Gent-McWilliams eddy parameterization, '&
//'y-direction')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'GMBolusVelocityY', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'GMBolusVelocityY', r2Ptr)

! Define variable GMBolusVelocityZ
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'GMBolusVelocityZ'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Bolus velocity in Gent-McWilliams eddy parameterization, '&
//'z-direction')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'GMBolusVelocityZ', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'GMBolusVelocityZ', r2Ptr)

! Define variable GMBolusVelocityZonal
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'GMBolusVelocityZonal'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Bolus velocity in Gent-McWilliams eddy parameterization, '&
//'zonal-direction')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'GMBolusVelocityZonal', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'GMBolusVelocityZonal', r2Ptr)

! Define variable GMBolusVelocityMeridional
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'GMBolusVelocityMeridional'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Bolus velocity in Gent-McWilliams eddy parameterization, '&
//'meridional-direction')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'GMBolusVelocityMeridional', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'GMBolusVelocityMeridional', r2Ptr)

! Define variable RiTopOfCell
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'RiTopOfCell'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevelsP1'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'nondimensional')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'gradient Richardson number defined at the center '&
//'(horizontally) and top (vertically)')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'RiTopOfCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'RiTopOfCell', r2Ptr)

! Define variable RiTopOfEdge
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'RiTopOfEdge'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevelsP1'
      r2Ptr(1) % dimNames(2) = 'nEdges'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'nondimensional')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'gradient Richardson number defined at the edge '&
//'(horizontally) and top (vertically)')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'RiTopOfEdge', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'RiTopOfEdge', r2Ptr)

! Define variable vertViscTopOfEdge
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'vertViscTopOfEdge'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevelsP1'
      r2Ptr(1) % dimNames(2) = 'nEdges'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm^2 s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'vertical viscosity defined at the edge (horizontally) and '&
//'top (vertically)')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'vertViscTopOfEdge', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'vertViscTopOfEdge', r2Ptr)

! Define variable vertViscTopOfCell
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'vertViscTopOfCell'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevelsP1'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm^2 s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'vertical viscosity defined at the cell center '&
//'(horizontally) and top (vertically)')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'vertViscTopOfCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'vertViscTopOfCell', r2Ptr)

! Define variable vertDiffTopOfCell
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'vertDiffTopOfCell'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevelsP1'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm^2 s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'vertical diffusion defined at the cell center '&
//'(horizontally) and top (vertically)')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'vertDiffTopOfCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'vertDiffTopOfCell', r2Ptr)

! Define variable bulkRichardsonNumber
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'bulkRichardsonNumber'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'nondimensional')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'CVMix/KPP: bulk Richardson number')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'bulkRichardsonNumber', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'bulkRichardsonNumber', r2Ptr)

! Define variable bulkRichardsonNumberBuoy
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'bulkRichardsonNumberBuoy'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'nondimensional')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'CVMix/KPP: contribution of buoyancy to bulk Richardson '&
//'number')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'bulkRichardsonNumberBuoy', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'bulkRichardsonNumberBuoy', r2Ptr)

! Define variable bulkRichardsonNumberShear
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'bulkRichardsonNumberShear'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'nondimensional')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'CVMix/KPP: contribution of shear to bulk Richardson '&
//'number')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'bulkRichardsonNumberShear', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'bulkRichardsonNumberShear', r2Ptr)

! Define variable unresolvedShear
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'unresolvedShear'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'CVMix/KPP: contribution of unresolved velocity to vertical '&
//'shear')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'unresolvedShear', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'unresolvedShear', r2Ptr)

! Define variable boundaryLayerDepth
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'boundaryLayerDepth'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'CVMix/KPP: diagnosed depth of the ocean surface boundary '&
//'layer')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'boundaryLayerDepth', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'boundaryLayerDepth', r1Ptr)

! Define variable boundaryLayerDepthSmooth
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'boundaryLayerDepthSmooth'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'CVMix/KPP: smoothed boundary layer depth')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'boundaryLayerDepthSmooth', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'boundaryLayerDepthSmooth', r1Ptr)

! Define variable boundaryLayerDepthEdge
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'boundaryLayerDepthEdge'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'CVMix/KPP: diagnosed depth of the ocean surface boundary '&
//'layer averaged to cell edges')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'boundaryLayerDepthEdge', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'boundaryLayerDepthEdge', r1Ptr)

! Define variable indexBoundaryLayerDepth
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'indexBoundaryLayerDepth'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'none')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'CVMix/KPP: int(indexBoundaryLayerDepth) is vertical layer '&
//'within which boundaryLayerDepth resides. mod(indexBoundaryLayerDepth) indicates whether boundaryLayerDepth resides above layer '&
//'center (value = 0.25) or below layer center (value=0.75)')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'indexBoundaryLayerDepth', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'indexBoundaryLayerDepth', r1Ptr)

! Define variable indexSurfaceLayerDepth
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'indexSurfaceLayerDepth'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'none')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'CVMix/KPP: surface layer entirely encompasses '&
//'int(indexSurfaceLayerDepth) vertical layers and fraction(indexSurfaceLayerDepth) of the int(indexSurfaceLayerDepth)+1 layer.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'indexSurfaceLayerDepth', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'indexSurfaceLayerDepth', r1Ptr)

! Define variable surfaceFrictionVelocity
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'surfaceFrictionVelocity'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'CVMix/KPP: diagnosed surface friction velocity defined as '&
//'square root of (mag(wind stress) / reference density)')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'surfaceFrictionVelocity', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'surfaceFrictionVelocity', r1Ptr)

! Define variable penetrativeTemperatureFluxOBL
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'penetrativeTemperatureFluxOBL'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', '^\circ C m s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'CVMix/KPP: Penetrative temperature flux at the bottom of '&
//'boundary layer due to solar radiation. Positive is into the ocean.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'penetrativeTemperatureFluxOBL', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'penetrativeTemperatureFluxOBL', r1Ptr)

! Define variable surfaceBuoyancyForcing
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'surfaceBuoyancyForcing'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm^2 s^{-3}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'CVMix/KPP: diagnosed surface buoyancy flux due to heat, '&
//'salt and freshwater fluxes. Positive flux increases buoyancy.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'surfaceBuoyancyForcing', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'surfaceBuoyancyForcing', r1Ptr)

! Define variable relativeSlopeTopOfEdge
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'relativeSlopeTopOfEdge'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevelsP1'
      r2Ptr(1) % dimNames(2) = 'nEdges'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'non-dimensional')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Slope of isopycnal surface relative to constant coordinate '&
//'surface')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'relativeSlopeTopOfEdge', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'relativeSlopeTopOfEdge', r2Ptr)

! Define variable relativeSlopeTopOfCell
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'relativeSlopeTopOfCell'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevelsP1'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'non-dimensional')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Magnitude of slope of isopycnal surface relative to '&
//'constant coordinate surface averaged to cell centers')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'relativeSlopeTopOfCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'relativeSlopeTopOfCell', r2Ptr)

! Define variable relativeSlopeTapering
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'relativeSlopeTapering'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevelsP1'
      r2Ptr(1) % dimNames(2) = 'nEdges'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'non-dimensional')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'scalar tapering function applied to limit magnitude of '&
//'isopycnal mixing in regions where relativeSlopeTopOfCell is greater than config_gm_max_slope')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'relativeSlopeTapering', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'relativeSlopeTapering', r2Ptr)

! Define variable relativeSlopeTaperingCell
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'relativeSlopeTaperingCell'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevelsP1'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'non-dimensional')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'averaging of relativeSlopeTapering function to cell '&
//'centers')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'relativeSlopeTaperingCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'relativeSlopeTaperingCell', r2Ptr)

! Define variable relativeSlopeTopOfCellX
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'relativeSlopeTopOfCellX'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevelsP1'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Slope of isopycnal surface relative to constant coordinate '&
//'surface')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'relativeSlopeTopOfCellX', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'relativeSlopeTopOfCellX', r2Ptr)

! Define variable relativeSlopeTopOfCellY
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'relativeSlopeTopOfCellY'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevelsP1'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Slope of isopycnal surface relative to constant coordinate '&
//'surface')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'relativeSlopeTopOfCellY', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'relativeSlopeTopOfCellY', r2Ptr)

! Define variable relativeSlopeTopOfCellZ
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'relativeSlopeTopOfCellZ'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevelsP1'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Slope of isopycnal surface relative to constant coordinate '&
//'surface')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'relativeSlopeTopOfCellZ', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'relativeSlopeTopOfCellZ', r2Ptr)

! Define variable relativeSlopeTopOfCellZonal
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'relativeSlopeTopOfCellZonal'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevelsP1'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Slope of isopycnal surface relative to constant coordinate '&
//'surface')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'relativeSlopeTopOfCellZonal', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'relativeSlopeTopOfCellZonal', r2Ptr)

! Define variable relativeSlopeTopOfCellMeridional
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'relativeSlopeTopOfCellMeridional'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevelsP1'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Slope of isopycnal surface relative to constant coordinate '&
//'surface')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'relativeSlopeTopOfCellMeridional', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'relativeSlopeTopOfCellMeridional', r2Ptr)

! Define variable k33
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'k33'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevelsP1'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm^2 s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'The (3,3) entry of the Redi diffusion tensor. Added to the '&
//'model vertical diffusion.')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'k33', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'k33', r2Ptr)

! Define variable gmStreamFuncTopOfEdge
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'gmStreamFuncTopOfEdge'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevelsP1'
      r2Ptr(1) % dimNames(2) = 'nEdges'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm^2 s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'GM stream function')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'gmStreamFuncTopOfEdge', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'gmStreamFuncTopOfEdge', r2Ptr)

! Define variable gmStreamFuncTopOfCell
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'gmStreamFuncTopOfCell'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm^2 s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'GM stream function reconstructed to the cell centers')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'gmStreamFuncTopOfCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'gmStreamFuncTopOfCell', r2Ptr)

! Define variable GMStreamFuncX
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'GMStreamFuncX'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevelsP1'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm^2 s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'GM stream function')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'GMStreamFuncX', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'GMStreamFuncX', r2Ptr)

! Define variable GMStreamFuncY
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'GMStreamFuncY'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevelsP1'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm^2 s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'GM stream function')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'GMStreamFuncY', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'GMStreamFuncY', r2Ptr)

! Define variable GMStreamFuncZ
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'GMStreamFuncZ'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevelsP1'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm^2 s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'GM stream function')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'GMStreamFuncZ', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'GMStreamFuncZ', r2Ptr)

! Define variable GMStreamFuncZonal
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'GMStreamFuncZonal'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevelsP1'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm^2 s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'GM stream function')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'GMStreamFuncZonal', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'GMStreamFuncZonal', r2Ptr)

! Define variable GMStreamFuncMeridional
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'GMStreamFuncMeridional'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevelsP1'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm^2 s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'GM stream function')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'GMStreamFuncMeridional', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'GMStreamFuncMeridional', r2Ptr)

! Define variable gmBolusKappa
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'gmBolusKappa'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm^2 s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'GM Bolus Kappa value.  This is constant in time, and set '&
//'at init based on the constant or ramp fuction.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (gmActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'gmBolusKappa', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'gmBolusKappa', r1Ptr)

! Define variable surfaceFluxAttenuationCoefficient
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'surfaceFluxAttenuationCoefficient'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'The spatially-dependent length scale of exponential decay '&
//'of surface fluxes. Fluxes are multiplied by $e^{z/\gamma}$, where this coefficient is $\gamma$.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'surfaceFluxAttenuationCoefficient', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'surfaceFluxAttenuationCoefficient', r1Ptr)

! Define variable surfaceFluxAttenuationCoefficientRunoff
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'surfaceFluxAttenuationCoefficientRunoff'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'The spatially-dependent length scale of exponential decay '&
//'of river runoff. Fluxes are multiplied by $e^{z/\gamma}$, where this coefficient is $\gamma$.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'surfaceFluxAttenuationCoefficientRunoff', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'surfaceFluxAttenuationCoefficientRunoff', r1Ptr)

! Define variable landIceFrictionVelocity
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'landIceFrictionVelocity'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'The friction velocity $u_*$ under land ice')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (landIceFluxesPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'landIceFrictionVelocity', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'landIceFrictionVelocity', r1Ptr)

! Define variable topDrag
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'topDrag'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'N m^{-2}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Top drag at the surface of the ocean defined at edge '&
//'midpoints. Magnitude in direction of edge normal.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (landIceFluxesPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'topDrag', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'topDrag', r1Ptr)

! Define variable topDragMagnitude
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'topDragMagnitude'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'N m^{-2}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Magnitude of top drag at the surface of the ocean, at cell '&
//'centers.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (landIceFluxesPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'topDragMagnitude', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'topDragMagnitude', r1Ptr)

! Define variable rx1Cell
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'rx1Cell'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'The Haney number (rx1), a measure of hydrostatic '&
//'consistency, at cell centers.')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (initModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'rx1Cell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'rx1Cell', r2Ptr)

! Define variable rx1Edge
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'rx1Edge'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nEdges'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'The Haney number (rx1), a measure of hydrostatic '&
//'consistency, at edges.')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (initModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'rx1Edge', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'rx1Edge', r2Ptr)

! Define variable rx1MaxCell
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'rx1MaxCell'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'The Haney number (rx1) is ratio of vertical displacement '&
//'to cell thickness between two neighboring horizontal cells.  It is computed at each edge.  This cell-based value is the maximum '&
//'over all edges and vertical levels of each cell.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (initModeActive .or. debugDiagnosticsAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'rx1MaxCell', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'rx1MaxCell', r1Ptr)

! Define variable rx1MaxEdge
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'rx1MaxEdge'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'The maximum Haney number (rx1) in a vertical column, '&
//'measured at edges.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (initModeActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'rx1MaxEdge', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'rx1MaxEdge', r1Ptr)

! Define variable globalRx1Max
      allocate(r0Ptr(1))

! Setting up time level 1
      r0Ptr(1) % fieldName = 'globalRx1Max'
      r0Ptr(1) % isVarArray = .false.
      r0Ptr(1) % isDecomposed = .false.
      r0Ptr(1) % hasTimeDimension = .true.
      r0Ptr(1) % defaultValue = 0.0
      r0Ptr(1) % scalar = 0.0
      allocate(r0Ptr(1) % attLists(1))
      allocate(r0Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r0Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r0Ptr(1) % attLists(1) % attList, 'long_name', 'The global maximum Haney number (rx1).')
      r0Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r0Ptr(1) % block => block

      if (initModeActive .or. debugDiagnosticsAMPKGActive) then
         r0Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'globalRx1Max', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'globalRx1Max', r0Ptr)

! Define variable globalVerticalStretchMax
      allocate(r0Ptr(1))

! Setting up time level 1
      r0Ptr(1) % fieldName = 'globalVerticalStretchMax'
      r0Ptr(1) % isVarArray = .false.
      r0Ptr(1) % isDecomposed = .false.
      r0Ptr(1) % hasTimeDimension = .true.
      r0Ptr(1) % defaultValue = 0.0
      r0Ptr(1) % scalar = 0.0
      allocate(r0Ptr(1) % attLists(1))
      allocate(r0Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r0Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r0Ptr(1) % attLists(1) % attList, 'long_name', 'The global maximum stretching of the vertical grid '&
//'compared with z-level.')
      r0Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r0Ptr(1) % block => block

      if (initModeActive) then
         r0Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'globalVerticalStretchMax', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'globalVerticalStretchMax', r0Ptr)

! Define variable globalVerticalStretchMin
      allocate(r0Ptr(1))

! Setting up time level 1
      r0Ptr(1) % fieldName = 'globalVerticalStretchMin'
      r0Ptr(1) % isVarArray = .false.
      r0Ptr(1) % isDecomposed = .false.
      r0Ptr(1) % hasTimeDimension = .true.
      r0Ptr(1) % defaultValue = 0.0
      r0Ptr(1) % scalar = 0.0
      allocate(r0Ptr(1) % attLists(1))
      allocate(r0Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r0Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r0Ptr(1) % attLists(1) % attList, 'long_name', 'The global minimum stretching of the vertical grid '&
//'compared with z-level.')
      r0Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r0Ptr(1) % block => block

      if (initModeActive) then
         r0Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'globalVerticalStretchMin', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'globalVerticalStretchMin', r0Ptr)

! Define variable rx1InitSmoothingMask
      allocate(i1Ptr(1))

! Setting up time level 1
      i1Ptr(1) % fieldName = 'rx1InitSmoothingMask'
      i1Ptr(1) % isVarArray = .false.
      i1Ptr(1) % isDecomposed = .true.
      i1Ptr(1) % hasTimeDimension = .true.
      i1Ptr(1) % isPersistent = .true.
      i1Ptr(1) % isActive = .false.
! Setting up dimensions
      i1Ptr(1) % dimNames(1) = 'nCells'
      i1Ptr(1) % defaultValue = 0
      allocate(i1Ptr(1) % attLists(1))
      allocate(i1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'long_name', 'A mask indicating where layer interface and thickness '&
//'smoothing is to be performed during Haney number constrained initializaiton.')
      i1Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i1Ptr(1) % block => block

      if (initModeActive) then
         i1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'rx1InitSmoothingMask', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'rx1InitSmoothingMask', i1Ptr)

! Define variable verticalStretch
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'verticalStretch'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'the stretch factor of each layer compared with the default '&
//'z-level coordinate')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (initModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalStretch', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalStretch', r2Ptr)

! Define variable pressureAdjustedSSH
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'pressureAdjustedSSH'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'sea surface height adjusted by sea surface pressure')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'pressureAdjustedSSH', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'pressureAdjustedSSH', r1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_pool_diagnostics


   subroutine ocn_generate_pool_shortwave(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'shortwave', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'shortwave', newSubPool)

! Define variable chlorophyllData
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'chlorophyllData'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mg m^{-3}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'concentration of chlorophyll data')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (variableShortwaveActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'chlorophyllData', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'chlorophyllData', r1Ptr)

! Define variable zenithAngle
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'zenithAngle'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'none')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'the cos of the solar zenith angle')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (variableShortwaveActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'zenithAngle', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'zenithAngle', r1Ptr)

! Define variable clearSkyRadiation
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'clearSkyRadiation'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'percent')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'the fractional cloudiness (between 0 and 1)')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (variableShortwaveActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'clearSkyRadiation', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'clearSkyRadiation', r1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_pool_shortwave


   subroutine ocn_generate_forcing_subpool_tracersSurfaceFlux(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'tracersSurfaceFlux', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'tracersSurfaceFlux', newSubPool)

! Define var array activeTracersSurfaceFlux
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group activeTracerFluxGRP
! Define constituent var temperatureSurfaceFlux
! My Packages are activeTracersPKG
      if (activeTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureSurfaceFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracerFluxGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_temperatureSurfaceFlux', -1)
           end if
      end if
! Define constituent var salinitySurfaceFlux
! My packages are activeTracersPKG
      if (activeTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinitySurfaceFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracerFluxGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinitySurfaceFlux', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracerFluxGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'activeTracerFluxGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracerFluxGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_activeTracersSurfaceFlux', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'activeTracersSurfaceFlux'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'temperatureSurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinitySurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'salinitySurfaceFlux'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_activeTracersSurfaceFlux'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Flux of temperature through the ocean '&
//'surface. Positive into ocean.')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', '^\circ C m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'temperatureSurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinitySurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Flux of salinity through the ocean surface. '&
//'Positive into ocean.')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'PSU m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'salinitySurfaceFlux'
      end if
      r2Ptr(1) % block => block

      if (activeTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'activeTracersSurfaceFlux', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'activeTracersSurfaceFlux', r2Ptr)

! Define var array activeTracersSurfaceFluxRunoff
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group activeRunoffFluxGRP
! Define constituent var temperatureSurfaceFluxRunoff
! My Packages are activeTracersPKG
      if (activeTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureSurfaceFluxRunoff', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeRunoffFluxGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_temperatureSurfaceFluxRunoff', -1)
           end if
      end if
! Define constituent var salinitySurfaceFluxRunoff
! My packages are activeTracersPKG
      if (activeTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinitySurfaceFluxRunoff', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeRunoffFluxGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinitySurfaceFluxRunoff', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeRunoffFluxGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'activeRunoffFluxGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeRunoffFluxGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_activeTracersSurfaceFluxRunoff', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'activeTracersSurfaceFluxRunoff'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'temperatureSurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinitySurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'salinitySurfaceFluxRunoff'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_activeTracersSurfaceFluxRunoff'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Flux of temperature through the ocean surface '&
//'due to river runoff. Positive into ocean.')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', '^\circ C m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'temperatureSurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinitySurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Flux of salinity through the ocean surface '&
//'due to river runoff. Positive into ocean.')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'PSU m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'salinitySurfaceFluxRunoff'
      end if
      r2Ptr(1) % block => block

      if (activeTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'activeTracersSurfaceFluxRunoff', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'activeTracersSurfaceFluxRunoff', r2Ptr)

! Define var array activeTracersSurfaceFluxRemoved
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group activeRemovedFluxGRP
! Define constituent var temperatureSurfaceFluxRemoved
! My Packages are activeTracersPKG
      if (activeTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureSurfaceFluxRemoved', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeRemovedFluxGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_temperatureSurfaceFluxRemoved', -1)
           end if
      end if
! Define constituent var salinitySurfaceFluxRemoved
! My packages are activeTracersPKG
      if (activeTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinitySurfaceFluxRemoved', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeRemovedFluxGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinitySurfaceFluxRemoved', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeRemovedFluxGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'activeRemovedFluxGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeRemovedFluxGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_activeTracersSurfaceFluxRemoved', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'activeTracersSurfaceFluxRemoved'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'temperatureSurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinitySurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'salinitySurfaceFluxRemoved'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_activeTracersSurfaceFluxRemoved'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Flux of temperature that is ignored coming '&
//'into the ocean. Positive into ocean.')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', '^\circ C m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'temperatureSurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinitySurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Flux of salinity that is ignored coming into '&
//'the ocean. Positive into ocean.')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'PSU m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'salinitySurfaceFluxRemoved'
      end if
      r2Ptr(1) % block => block

      if (activeTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'activeTracersSurfaceFluxRemoved', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'activeTracersSurfaceFluxRemoved', r2Ptr)

! Define var array nonLocalSurfaceTracerFlux
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group activeNonLocalGRP
! Define constituent var nonLocalTemperatureSurfaceFlux
! My Packages are activeTracersPKG
      if (activeTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_nonLocalTemperatureSurfaceFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeNonLocalGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_nonLocalTemperatureSurfaceFlux', -1)
           end if
      end if
! Define constituent var nonLocalSalinitySurfaceFlux
! My packages are activeTracersPKG
      if (activeTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_nonLocalSalinitySurfaceFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeNonLocalGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_nonLocalSalinitySurfaceFlux', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeNonLocalGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'activeNonLocalGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeNonLocalGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_nonLocalSurfaceTracerFlux', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'nonLocalSurfaceTracerFlux'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_nonLocalTemperatureSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'nonLocalTemperatureSurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_nonLocalSalinitySurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'nonLocalSalinitySurfaceFlux'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_nonLocalSurfaceTracerFlux'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_nonLocalTemperatureSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'total flux of temperature (including '&
//'thickness contributions) through ocean surface')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', '^\circ C m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'nonLocalTemperatureSurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_nonLocalSalinitySurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'total flux of salinity (including thickness '&
//'contributions) through ocean surface')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'PSU m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'nonLocalSalinitySurfaceFlux'
      end if
      r2Ptr(1) % block => block

      if (activeTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'nonLocalSurfaceTracerFlux', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'nonLocalSurfaceTracerFlux', r2Ptr)

! Define var array debugTracersSurfaceFlux
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group debugTracerFluxGRP
! Define constituent var tracer1SurfaceFlux
! My Packages are debugTracersPKG
      if (debugTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_tracer1SurfaceFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'debugTracerFluxGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_tracer1SurfaceFlux', -1)
           end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'debugTracerFluxGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'debugTracerFluxGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'debugTracerFluxGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_debugTracersSurfaceFlux', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'debugTracersSurfaceFlux'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_tracer1SurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'tracer1SurfaceFlux'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_debugTracersSurfaceFlux'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_tracer1SurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Flux of tracer1 through the ocean surface. '&
//'Positive into ocean.')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'tracer1 m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'tracer1SurfaceFlux'
      end if
      r2Ptr(1) % block => block

      if (debugTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'debugTracersSurfaceFlux', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'debugTracersSurfaceFlux', r2Ptr)

! Define var array debugTracersSurfaceFluxRunoff
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group debugRunoffFluxGRP
! Define constituent var tracer1SurfaceFluxRunoff
! My Packages are debugTracersPKG
      if (debugTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_tracer1SurfaceFluxRunoff', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'debugRunoffFluxGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_tracer1SurfaceFluxRunoff', -1)
           end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'debugRunoffFluxGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'debugRunoffFluxGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'debugRunoffFluxGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_debugTracersSurfaceFluxRunoff', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'debugTracersSurfaceFluxRunoff'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_tracer1SurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'tracer1SurfaceFluxRunoff'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_debugTracersSurfaceFluxRunoff'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_tracer1SurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Flux of tracer1 through the ocean surface due '&
//'to river runoff. Positive into ocean.')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'tracer1 m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'tracer1SurfaceFluxRunoff'
      end if
      r2Ptr(1) % block => block

      if (debugTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'debugTracersSurfaceFluxRunoff', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'debugTracersSurfaceFluxRunoff', r2Ptr)

! Define var array debugTracersSurfaceFluxRemoved
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group debugRemovedFluxGRP
! Define constituent var tracer1SurfaceFluxRemoved
! My Packages are debugTracersPKG
      if (debugTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_tracer1SurfaceFluxRemoved', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'debugRemovedFluxGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_tracer1SurfaceFluxRemoved', -1)
           end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'debugRemovedFluxGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'debugRemovedFluxGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'debugRemovedFluxGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_debugTracersSurfaceFluxRemoved', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'debugTracersSurfaceFluxRemoved'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_tracer1SurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'tracer1SurfaceFluxRemoved'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_debugTracersSurfaceFluxRemoved'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_tracer1SurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Flux of tracer1 that is ignored coming into '&
//'the ocean. Positive into ocean.')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'tracer1 m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'tracer1SurfaceFluxRemoved'
      end if
      r2Ptr(1) % block => block

      if (debugTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'debugTracersSurfaceFluxRemoved', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'debugTracersSurfaceFluxRemoved', r2Ptr)

! Define var array ecosysTracersSurfaceFlux
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group ecosysSurfaceFluxGRP
! Define constituent var PO4SurfaceFlux
! My Packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_PO4SurfaceFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_PO4SurfaceFlux', -1)
           end if
      end if
! Define constituent var NO3SurfaceFlux
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_NO3SurfaceFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_NO3SurfaceFlux', -1)
         end if
      end if
! Define constituent var SiO3SurfaceFlux
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_SiO3SurfaceFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_SiO3SurfaceFlux', -1)
         end if
      end if
! Define constituent var NH4SurfaceFlux
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_NH4SurfaceFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_NH4SurfaceFlux', -1)
         end if
      end if
! Define constituent var FeSurfaceFlux
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_FeSurfaceFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_FeSurfaceFlux', -1)
         end if
      end if
! Define constituent var O2SurfaceFlux
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_O2SurfaceFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_O2SurfaceFlux', -1)
         end if
      end if
! Define constituent var DICSurfaceFlux
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DICSurfaceFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DICSurfaceFlux', -1)
         end if
      end if
! Define constituent var DIC_ALT_CO2SurfaceFlux
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DIC_ALT_CO2SurfaceFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DIC_ALT_CO2SurfaceFlux', -1)
         end if
      end if
! Define constituent var ALKSurfaceFlux
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_ALKSurfaceFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_ALKSurfaceFlux', -1)
         end if
      end if
! Define constituent var DOCSurfaceFlux
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOCSurfaceFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOCSurfaceFlux', -1)
         end if
      end if
! Define constituent var DONSurfaceFlux
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DONSurfaceFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DONSurfaceFlux', -1)
         end if
      end if
! Define constituent var DOFeSurfaceFlux
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOFeSurfaceFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOFeSurfaceFlux', -1)
         end if
      end if
! Define constituent var DOPSurfaceFlux
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOPSurfaceFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOPSurfaceFlux', -1)
         end if
      end if
! Define constituent var DOPrSurfaceFlux
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOPrSurfaceFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOPrSurfaceFlux', -1)
         end if
      end if
! Define constituent var DONrSurfaceFlux
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DONrSurfaceFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DONrSurfaceFlux', -1)
         end if
      end if
! Define constituent var zooCSurfaceFlux
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_zooCSurfaceFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_zooCSurfaceFlux', -1)
         end if
      end if
! Define constituent var spChlSurfaceFlux
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spChlSurfaceFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spChlSurfaceFlux', -1)
         end if
      end if
! Define constituent var spCSurfaceFlux
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spCSurfaceFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spCSurfaceFlux', -1)
         end if
      end if
! Define constituent var spFeSurfaceFlux
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spFeSurfaceFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spFeSurfaceFlux', -1)
         end if
      end if
! Define constituent var spCaCO3SurfaceFlux
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spCaCO3SurfaceFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spCaCO3SurfaceFlux', -1)
         end if
      end if
! Define constituent var diatChlSurfaceFlux
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatChlSurfaceFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatChlSurfaceFlux', -1)
         end if
      end if
! Define constituent var diatCSurfaceFlux
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatCSurfaceFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatCSurfaceFlux', -1)
         end if
      end if
! Define constituent var diatFeSurfaceFlux
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatFeSurfaceFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatFeSurfaceFlux', -1)
         end if
      end if
! Define constituent var diatSiSurfaceFlux
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatSiSurfaceFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatSiSurfaceFlux', -1)
         end if
      end if
! Define constituent var diazChlSurfaceFlux
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazChlSurfaceFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazChlSurfaceFlux', -1)
         end if
      end if
! Define constituent var diazCSurfaceFlux
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazCSurfaceFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazCSurfaceFlux', -1)
         end if
      end if
! Define constituent var diazFeSurfaceFlux
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazFeSurfaceFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazFeSurfaceFlux', -1)
         end if
      end if
! Define constituent var phaeoChlSurfaceFlux
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoChlSurfaceFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoChlSurfaceFlux', -1)
         end if
      end if
! Define constituent var phaeoCSurfaceFlux
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoCSurfaceFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoCSurfaceFlux', -1)
         end if
      end if
! Define constituent var phaeoFeSurfaceFlux
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoFeSurfaceFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoFeSurfaceFlux', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_ecosysTracersSurfaceFlux', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'ecosysTracersSurfaceFlux'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_PO4SurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'PO4SurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_NO3SurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'NO3SurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_SiO3SurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'SiO3SurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_NH4SurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'NH4SurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_FeSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'FeSurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_O2SurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'O2SurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DICSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DICSurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DIC_ALT_CO2SurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DIC_ALT_CO2SurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_ALKSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'ALKSurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOCSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DOCSurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DONSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DONSurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOFeSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DOFeSurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOPSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DOPSurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOPrSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DOPrSurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DONrSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DONrSurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_zooCSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'zooCSurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spChlSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'spChlSurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spCSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'spCSurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spFeSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'spFeSurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spCaCO3SurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'spCaCO3SurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatChlSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'diatChlSurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatCSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'diatCSurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatFeSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'diatFeSurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatSiSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'diatSiSurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazChlSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'diazChlSurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazCSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'diazCSurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazFeSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'diazFeSurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoChlSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'phaeoChlSurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoCSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'phaeoCSurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoFeSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'phaeoFeSurfaceFlux'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_ecosysTracersSurfaceFlux'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_PO4SurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Inorganic Phosphate Surface Flux')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol P m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'PO4SurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_NO3SurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Inorganic Nitrate Surface Flux')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol N m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'NO3SurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_SiO3SurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Inorganic Silicate Surface Flux')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol Si m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'SiO3SurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_NH4SurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Ammonia Surface Flux')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol N m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'NH4SurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_FeSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Inorganic Iron Surface Flux')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol Fe m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'FeSurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_O2SurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Oxygen Surface Flux')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol O2 m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'O2SurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DICSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Inorganic Carbon Surface Flux')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol C m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DICSurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DIC_ALT_CO2SurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Inorganic Carbon, Alternative CO2 '&
//'Surface Flux')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol C m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DIC_ALT_CO2SurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_ALKSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Alkalinity Surface Flux')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'meq m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'ALKSurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOCSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Organic Carbon Surface Flux')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol C m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DOCSurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DONSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Organic Nitrogen Surface Flux')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol N m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DONSurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOFeSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Organic Iron Surface Flux')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol Fe m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DOFeSurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOPSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Organic Phosphorus Surface Flux')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol P m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DOPSurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOPrSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Refractory DOP Surface Flux')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol P m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DOPrSurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DONrSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Refractory DON Surface Flux')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol N m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DONrSurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_zooCSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Zooplankton Carbon Surface Flux')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol C m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'zooCSurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spChlSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Small Phytoplankton Chlorophyll Surface Flux')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mg m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'spChlSurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spCSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Small Phytoplankton Carbon Surface Flux')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol C m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'spCSurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spFeSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Small Phytoplankton Iron Surface Flux')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol Fe m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'spFeSurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spCaCO3SurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Small Phytoplankton Calcium Carbonate Surface '&
//'Flux')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol C m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'spCaCO3SurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatChlSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Diatom Chlorophyll Surface Flux')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mg m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'diatChlSurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatCSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Diatom Carbon Surface Flux')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol C m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'diatCSurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatFeSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Diatom Iron Surface Flux')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol Fe m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'diatFeSurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatSiSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Diatom Silicate Surface Flux')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol Si m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'diatSiSurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazChlSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Diazotroph Chlorophyll Surface Flux')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mg m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'diazChlSurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazCSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Diazotroph Carbon Surface Flux')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol C m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'diazCSurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazFeSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Diazotroph Iron Surface Flux')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol Fe m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'diazFeSurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoChlSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Phaeocystis Chlorophyll Surface Flux')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mg m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'phaeoChlSurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoCSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Phaeocystis Carbon Surface Flux')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol C m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'phaeoCSurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoFeSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Phaeocystis Iron Surface Flux')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol Fe m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'phaeoFeSurfaceFlux'
      end if
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosysTracersSurfaceFlux', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosysTracersSurfaceFlux', r2Ptr)

! Define var array ecosysTracersSurfaceFluxRunoff
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group ecosysSurfaceFluxRunoffGRP
! Define constituent var PO4SurfaceFluxRunoff
! My Packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_PO4SurfaceFluxRunoff', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRunoffGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_PO4SurfaceFluxRunoff', -1)
           end if
      end if
! Define constituent var NO3SurfaceFluxRunoff
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_NO3SurfaceFluxRunoff', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRunoffGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_NO3SurfaceFluxRunoff', -1)
         end if
      end if
! Define constituent var SiO3SurfaceFluxRunoff
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_SiO3SurfaceFluxRunoff', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRunoffGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_SiO3SurfaceFluxRunoff', -1)
         end if
      end if
! Define constituent var NH4SurfaceFluxRunoff
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_NH4SurfaceFluxRunoff', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRunoffGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_NH4SurfaceFluxRunoff', -1)
         end if
      end if
! Define constituent var O2SurfaceFluxRunoff
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_O2SurfaceFluxRunoff', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRunoffGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_O2SurfaceFluxRunoff', -1)
         end if
      end if
! Define constituent var DICSurfaceFluxRunoff
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DICSurfaceFluxRunoff', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRunoffGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DICSurfaceFluxRunoff', -1)
         end if
      end if
! Define constituent var DIC_ALT_CO2SurfaceFluxRunoff
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DIC_ALT_CO2SurfaceFluxRunoff', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRunoffGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DIC_ALT_CO2SurfaceFluxRunoff', -1)
         end if
      end if
! Define constituent var ALKSurfaceFluxRunoff
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_ALKSurfaceFluxRunoff', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRunoffGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_ALKSurfaceFluxRunoff', -1)
         end if
      end if
! Define constituent var DOCSurfaceFluxRunoff
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOCSurfaceFluxRunoff', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRunoffGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOCSurfaceFluxRunoff', -1)
         end if
      end if
! Define constituent var DONSurfaceFluxRunoff
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DONSurfaceFluxRunoff', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRunoffGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DONSurfaceFluxRunoff', -1)
         end if
      end if
! Define constituent var DOFeSurfaceFluxRunoff
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOFeSurfaceFluxRunoff', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRunoffGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOFeSurfaceFluxRunoff', -1)
         end if
      end if
! Define constituent var DOPSurfaceFluxRunoff
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOPSurfaceFluxRunoff', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRunoffGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOPSurfaceFluxRunoff', -1)
         end if
      end if
! Define constituent var DOPrSurfaceFluxRunoff
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOPrSurfaceFluxRunoff', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRunoffGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOPrSurfaceFluxRunoff', -1)
         end if
      end if
! Define constituent var DONrSurfaceFluxRunoff
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DONrSurfaceFluxRunoff', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRunoffGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DONrSurfaceFluxRunoff', -1)
         end if
      end if
! Define constituent var zooCSurfaceFluxRunoff
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_zooCSurfaceFluxRunoff', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRunoffGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_zooCSurfaceFluxRunoff', -1)
         end if
      end if
! Define constituent var spChlSurfaceFluxRunoff
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spChlSurfaceFluxRunoff', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRunoffGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spChlSurfaceFluxRunoff', -1)
         end if
      end if
! Define constituent var spCSurfaceFluxRunoff
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spCSurfaceFluxRunoff', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRunoffGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spCSurfaceFluxRunoff', -1)
         end if
      end if
! Define constituent var spFeSurfaceFluxRunoff
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spFeSurfaceFluxRunoff', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRunoffGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spFeSurfaceFluxRunoff', -1)
         end if
      end if
! Define constituent var spCaCO3SurfaceFluxRunoff
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spCaCO3SurfaceFluxRunoff', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRunoffGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spCaCO3SurfaceFluxRunoff', -1)
         end if
      end if
! Define constituent var diatChlSurfaceFluxRunoff
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatChlSurfaceFluxRunoff', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRunoffGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatChlSurfaceFluxRunoff', -1)
         end if
      end if
! Define constituent var diatCSurfaceFluxRunoff
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatCSurfaceFluxRunoff', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRunoffGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatCSurfaceFluxRunoff', -1)
         end if
      end if
! Define constituent var diatFeSurfaceFluxRunoff
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatFeSurfaceFluxRunoff', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRunoffGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatFeSurfaceFluxRunoff', -1)
         end if
      end if
! Define constituent var diatSiSurfaceFluxRunoff
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatSiSurfaceFluxRunoff', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRunoffGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatSiSurfaceFluxRunoff', -1)
         end if
      end if
! Define constituent var diazChlSurfaceFluxRunoff
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazChlSurfaceFluxRunoff', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRunoffGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazChlSurfaceFluxRunoff', -1)
         end if
      end if
! Define constituent var diazCSurfaceFluxRunoff
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazCSurfaceFluxRunoff', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRunoffGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazCSurfaceFluxRunoff', -1)
         end if
      end if
! Define constituent var diazFeSurfaceFluxRunoff
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazFeSurfaceFluxRunoff', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRunoffGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazFeSurfaceFluxRunoff', -1)
         end if
      end if
! Define constituent var phaeoChlSurfaceFluxRunoff
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoChlSurfaceFluxRunoff', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRunoffGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoChlSurfaceFluxRunoff', -1)
         end if
      end if
! Define constituent var phaeoCSurfaceFluxRunoff
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoCSurfaceFluxRunoff', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRunoffGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoCSurfaceFluxRunoff', -1)
         end if
      end if
! Define constituent var phaeoFeSurfaceFluxRunoff
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoFeSurfaceFluxRunoff', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRunoffGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoFeSurfaceFluxRunoff', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRunoffGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRunoffGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRunoffGRP_end', index_counter)
            end if
         end if
! End of group       
! Starting group ecosysSurfaceFluxRunoffSurfaceFluxRunoffGRP
! Define constituent var FeSurfaceFluxRunoff
! My Packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_FeSurfaceFluxRunoff', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRunoffSurfaceFluxRunoffGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_FeSurfaceFluxRunoff', -1)
           end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRunoffSurfaceFluxRunoffGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRunoffSurfaceFluxRunoffGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRunoffSurfaceFluxRunoffGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_ecosysTracersSurfaceFluxRunoff', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'ecosysTracersSurfaceFluxRunoff'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_PO4SurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'PO4SurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_NO3SurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'NO3SurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_SiO3SurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'SiO3SurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_NH4SurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'NH4SurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_FeSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'FeSurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_O2SurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'O2SurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DICSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DICSurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DIC_ALT_CO2SurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DIC_ALT_CO2SurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_ALKSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'ALKSurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOCSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DOCSurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DONSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DONSurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOFeSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DOFeSurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOPSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DOPSurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOPrSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DOPrSurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DONrSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DONrSurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_zooCSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'zooCSurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spChlSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'spChlSurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spCSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'spCSurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spFeSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'spFeSurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spCaCO3SurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'spCaCO3SurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatChlSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'diatChlSurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatCSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'diatCSurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatFeSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'diatFeSurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatSiSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'diatSiSurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazChlSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'diazChlSurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazCSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'diazCSurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazFeSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'diazFeSurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoChlSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'phaeoChlSurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoCSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'phaeoCSurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoFeSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'phaeoFeSurfaceFluxRunoff'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_ecosysTracersSurfaceFluxRunoff'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_PO4SurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Inorganic Phosphate Surface Flux '&
//'Due to Runoff')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol P m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'PO4SurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_NO3SurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Inorganic Nitrate Surface Flux Due '&
//'to Runoff')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol N m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'NO3SurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_SiO3SurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Inorganic Silicate Surface Flux Due '&
//'to Runoff')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol Si m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'SiO3SurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_NH4SurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Ammonia Surface Flux Due to Runoff')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol N m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'NH4SurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_FeSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Inorganic Iron Surface Flux Due to '&
//'Runoff')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol Fe m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'FeSurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_O2SurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Oxygen Surface Flux Due to Runoff')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol O2 m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'O2SurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DICSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Inorganic Carbon Surface Flux Due '&
//'to Runoff')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol C m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DICSurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DIC_ALT_CO2SurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Inorganic Carbon, Alternative CO2 '&
//'Surface Flux Due to Runoff')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol C m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DIC_ALT_CO2SurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_ALKSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Alkalinity Surface Flux Due to Runoff')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'meq m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'ALKSurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOCSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Organic Carbon Surface Flux Due to '&
//'Runoff')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol C m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DOCSurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DONSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Organic Nitrogen Surface Flux Due '&
//'to Runoff')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol N m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DONSurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOFeSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Organic Iron Surface Flux Due to '&
//'Runoff')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol Fe m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DOFeSurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOPSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Organic Phosphorus Surface Flux Due '&
//'to Runoff')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol P m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DOPSurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOPrSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Refractory DOP Surface Flux Due to Runoff')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol P m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DOPrSurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DONrSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Refractory DON Surface Flux Due to Runoff')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol N m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DONrSurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_zooCSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Zooplankton Carbon Surface Flux Due to '&
//'Runoff')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol C m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'zooCSurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spChlSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Small Phytoplankton Chlorophyll Surface Flux '&
//'Due to Runoff')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mg m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'spChlSurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spCSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Small Phytoplankton Carbon Surface Flux Due '&
//'to Runoff')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol C m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'spCSurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spFeSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Small Phytoplankton Iron Surface Flux Due to '&
//'Runoff')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol Fe m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'spFeSurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spCaCO3SurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Small Phytoplankton Calcium Carbonate Surface '&
//'Flux Due to Runoff')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol C m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'spCaCO3SurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatChlSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Diatom Chlorophyll Surface Flux Due to '&
//'Runoff')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mg m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'diatChlSurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatCSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Diatom Carbon Surface Flux Due to Runoff')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol C m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'diatCSurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatFeSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Diatom Iron Surface Flux Due to Runoff')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol Fe m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'diatFeSurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatSiSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Diatom Silicate Surface Flux Due to Runoff')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol Si m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'diatSiSurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazChlSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Diazotroph Chlorophyll Surface Flux Due to '&
//'Runoff')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mg m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'diazChlSurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazCSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Diazotroph Carbon Surface Flux Due to Runoff')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol C m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'diazCSurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazFeSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Diazotroph Iron Surface Flux Due to Runoff')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol Fe m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'diazFeSurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoChlSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Phaeocystis Chlorophyll Surface Flux Due to '&
//'Runoff')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mg m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'phaeoChlSurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoCSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Phaeocystis Carbon Surface Flux Due to '&
//'Runoff')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol C m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'phaeoCSurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoFeSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Phaeocystis Iron Surface Flux Due to Runoff')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol Fe m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'phaeoFeSurfaceFluxRunoff'
      end if
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosysTracersSurfaceFluxRunoff', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosysTracersSurfaceFluxRunoff', r2Ptr)

! Define var array ecosysTracersSurfaceFluxRemoved
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group ecosysSurfaceFluxRemovedGRP
! Define constituent var PO4SurfaceFluxRemoved
! My Packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_PO4SurfaceFluxRemoved', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRemovedGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_PO4SurfaceFluxRemoved', -1)
           end if
      end if
! Define constituent var NO3SurfaceFluxRemoved
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_NO3SurfaceFluxRemoved', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRemovedGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_NO3SurfaceFluxRemoved', -1)
         end if
      end if
! Define constituent var SiO3SurfaceFluxRemoved
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_SiO3SurfaceFluxRemoved', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRemovedGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_SiO3SurfaceFluxRemoved', -1)
         end if
      end if
! Define constituent var NH4SurfaceFluxRemoved
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_NH4SurfaceFluxRemoved', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRemovedGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_NH4SurfaceFluxRemoved', -1)
         end if
      end if
! Define constituent var FeSurfaceFluxRemoved
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_FeSurfaceFluxRemoved', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRemovedGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_FeSurfaceFluxRemoved', -1)
         end if
      end if
! Define constituent var O2SurfaceFluxRemoved
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_O2SurfaceFluxRemoved', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRemovedGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_O2SurfaceFluxRemoved', -1)
         end if
      end if
! Define constituent var DICSurfaceFluxRemoved
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DICSurfaceFluxRemoved', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRemovedGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DICSurfaceFluxRemoved', -1)
         end if
      end if
! Define constituent var DIC_ALT_CO2SurfaceFluxRemoved
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DIC_ALT_CO2SurfaceFluxRemoved', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRemovedGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DIC_ALT_CO2SurfaceFluxRemoved', -1)
         end if
      end if
! Define constituent var ALKSurfaceFluxRemoved
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_ALKSurfaceFluxRemoved', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRemovedGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_ALKSurfaceFluxRemoved', -1)
         end if
      end if
! Define constituent var DOCSurfaceFluxRemoved
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOCSurfaceFluxRemoved', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRemovedGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOCSurfaceFluxRemoved', -1)
         end if
      end if
! Define constituent var DONSurfaceFluxRemoved
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DONSurfaceFluxRemoved', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRemovedGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DONSurfaceFluxRemoved', -1)
         end if
      end if
! Define constituent var DOFeSurfaceFluxRemoved
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOFeSurfaceFluxRemoved', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRemovedGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOFeSurfaceFluxRemoved', -1)
         end if
      end if
! Define constituent var DOPSurfaceFluxFluxRemoved
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOPSurfaceFluxFluxRemoved', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRemovedGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOPSurfaceFluxFluxRemoved', -1)
         end if
      end if
! Define constituent var DOPrSurfaceFluxRemoved
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOPrSurfaceFluxRemoved', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRemovedGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOPrSurfaceFluxRemoved', -1)
         end if
      end if
! Define constituent var DONrSurfaceFluxRemoved
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DONrSurfaceFluxRemoved', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRemovedGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DONrSurfaceFluxRemoved', -1)
         end if
      end if
! Define constituent var zooCSurfaceFluxRemoved
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_zooCSurfaceFluxRemoved', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRemovedGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_zooCSurfaceFluxRemoved', -1)
         end if
      end if
! Define constituent var spChlSurfaceFluxRemoved
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spChlSurfaceFluxRemoved', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRemovedGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spChlSurfaceFluxRemoved', -1)
         end if
      end if
! Define constituent var spCSurfaceFluxRemoved
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spCSurfaceFluxRemoved', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRemovedGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spCSurfaceFluxRemoved', -1)
         end if
      end if
! Define constituent var spFeSurfaceFluxRemoved
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spFeSurfaceFluxRemoved', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRemovedGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spFeSurfaceFluxRemoved', -1)
         end if
      end if
! Define constituent var spCaCO3SurfaceFluxRemoved
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spCaCO3SurfaceFluxRemoved', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRemovedGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spCaCO3SurfaceFluxRemoved', -1)
         end if
      end if
! Define constituent var diatChlSurfaceFluxRemoved
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatChlSurfaceFluxRemoved', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRemovedGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatChlSurfaceFluxRemoved', -1)
         end if
      end if
! Define constituent var diatCSurfaceFluxRemoved
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatCSurfaceFluxRemoved', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRemovedGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatCSurfaceFluxRemoved', -1)
         end if
      end if
! Define constituent var diatFeSurfaceFluxRemoved
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatFeSurfaceFluxRemoved', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRemovedGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatFeSurfaceFluxRemoved', -1)
         end if
      end if
! Define constituent var diatSiSurfaceFluxRemoved
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatSiSurfaceFluxRemoved', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRemovedGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatSiSurfaceFluxRemoved', -1)
         end if
      end if
! Define constituent var diazChlSurfaceFluxRemoved
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazChlSurfaceFluxRemoved', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRemovedGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazChlSurfaceFluxRemoved', -1)
         end if
      end if
! Define constituent var diazCSurfaceFluxRemoved
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazCSurfaceFluxRemoved', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRemovedGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazCSurfaceFluxRemoved', -1)
         end if
      end if
! Define constituent var diazFeSurfaceFluxRemoved
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazFeSurfaceFluxRemoved', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRemovedGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazFeSurfaceFluxRemoved', -1)
         end if
      end if
! Define constituent var phaeoChlSurfaceFluxRemoved
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoChlSurfaceFluxRemoved', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRemovedGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoChlSurfaceFluxRemoved', -1)
         end if
      end if
! Define constituent var phaeoCSurfaceFluxRemoved
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoCSurfaceFluxRemoved', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRemovedGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoCSurfaceFluxRemoved', -1)
         end if
      end if
! Define constituent var phaeoFeSurfaceFluxRemoved
! My packages are ecosysTracersPKG
      if (ecosysTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoFeSurfaceFluxRemoved', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRemovedGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoFeSurfaceFluxRemoved', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRemovedGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRemovedGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSurfaceFluxRemovedGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_ecosysTracersSurfaceFluxRemoved', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'ecosysTracersSurfaceFluxRemoved'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_PO4SurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'PO4SurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_NO3SurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'NO3SurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_SiO3SurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'SiO3SurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_NH4SurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'NH4SurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_FeSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'FeSurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_O2SurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'O2SurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DICSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DICSurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DIC_ALT_CO2SurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DIC_ALT_CO2SurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_ALKSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'ALKSurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOCSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DOCSurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DONSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DONSurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOFeSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DOFeSurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOPSurfaceFluxFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DOPSurfaceFluxFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOPrSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DOPrSurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DONrSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DONrSurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_zooCSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'zooCSurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spChlSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'spChlSurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spCSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'spCSurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spFeSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'spFeSurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spCaCO3SurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'spCaCO3SurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatChlSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'diatChlSurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatCSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'diatCSurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatFeSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'diatFeSurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatSiSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'diatSiSurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazChlSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'diazChlSurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazCSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'diazCSurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazFeSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'diazFeSurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoChlSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'phaeoChlSurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoCSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'phaeoCSurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoFeSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'phaeoFeSurfaceFluxRemoved'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_ecosysTracersSurfaceFluxRemoved'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_PO4SurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Inorganic Phosphate Surface Flux '&
//'that is ignored')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol P m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'PO4SurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_NO3SurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Inorganic Nitrate Surface Flux that '&
//'is ignored')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol N m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'NO3SurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_SiO3SurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Inorganic Silicate Surface Flux '&
//'that is ignored')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol Si m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'SiO3SurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_NH4SurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Ammonia Surface Flux that is '&
//'ignored')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol N m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'NH4SurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_FeSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Inorganic Iron Surface Flux that is '&
//'ignored')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol Fe m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'FeSurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_O2SurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Oxygen Surface Flux that is '&
//'ignored')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol O2 m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'O2SurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DICSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Inorganic Carbon Surface Flux that '&
//'is ignored')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol C m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DICSurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DIC_ALT_CO2SurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Inorganic Carbon, Alternative CO2 '&
//'Surface Flux that is ignored')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol C m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DIC_ALT_CO2SurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_ALKSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Alkalinity Surface Flux that is ignored')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'meq m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'ALKSurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOCSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Organic Carbon Surface Flux that is '&
//'ignored')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol C m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DOCSurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DONSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Organic Nitrogen Surface Flux that '&
//'is ignored')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol N m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DONSurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOFeSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Organic Iron Surface Flux that is '&
//'ignored')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol Fe m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DOFeSurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOPSurfaceFluxFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dissolved Organic Phosphorus Surface Flux '&
//'that is ignored')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol P m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DOPSurfaceFluxFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOPrSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Refractory DOP Surface Flux that is ignored')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol P m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DOPrSurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DONrSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Refractory DON Surface Flux that is ignored')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol N m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DONrSurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_zooCSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Zooplankton Carbon Surface Flux that is '&
//'ignored')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol C m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'zooCSurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spChlSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Small Phytoplankton Chlorophyll Surface Flux '&
//'that is ignored')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mg m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'spChlSurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spCSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Small Phytoplankton Carbon Surface Flux that '&
//'is ignored')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol C m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'spCSurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spFeSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Small Phytoplankton Iron Surface Flux that is '&
//'ignored')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol Fe m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'spFeSurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spCaCO3SurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Small Phytoplankton Calcium Carbonate Surface '&
//'Flux that is ignored')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol C m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'spCaCO3SurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatChlSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Diatom Chlorophyll Surface Flux that is '&
//'ignored')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mg m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'diatChlSurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatCSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Diatom Carbon Surface Flux that is ignored')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol C m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'diatCSurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatFeSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Diatom Iron Surface Flux that is ignored')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol Fe m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'diatFeSurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatSiSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Diatom Silicate Surface Flux that is ignored')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol Si m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'diatSiSurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazChlSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Diazotroph Chlorophyll Surface Flux that is '&
//'ignored')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mg m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'diazChlSurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazCSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Diazotroph Carbon Surface Flux that is '&
//'ignored')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol C m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'diazCSurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazFeSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Diazotroph Iron Surface Flux that is ignored')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol Fe m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'diazFeSurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoChlSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Phaeocystis Chlorophyll Surface Flux that is '&
//'ignored')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mg m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'phaeoChlSurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoCSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Phaeocystis Carbon Surface Flux that is '&
//'ignored')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol C m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'phaeoCSurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoFeSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Phaeocystis Iron Surface Flux that is '&
//'ignored')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol Fe m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'phaeoFeSurfaceFluxRemoved'
      end if
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosysTracersSurfaceFluxRemoved', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosysTracersSurfaceFluxRemoved', r2Ptr)

! Define var array DMSTracersSurfaceFlux
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group DMSSurfaceFluxGRP
! Define constituent var DMSSurfaceFlux
! My Packages are DMSTracersPKG
      if (DMSTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DMSSurfaceFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'DMSSurfaceFluxGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_DMSSurfaceFlux', -1)
           end if
      end if
! Define constituent var DMSPSurfaceFlux
! My packages are DMSTracersPKG
      if (DMSTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DMSPSurfaceFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'DMSSurfaceFluxGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DMSPSurfaceFlux', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'DMSSurfaceFluxGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'DMSSurfaceFluxGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'DMSSurfaceFluxGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_DMSTracersSurfaceFlux', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'DMSTracersSurfaceFlux'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DMSSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DMSSurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DMSPSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DMSPSurfaceFlux'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_DMSTracersSurfaceFlux'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DMSSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dimethyl Sulfide Surface Flux')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DMSSurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DMSPSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dimethyl Sulfoniopropionate Surface Flux')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DMSPSurfaceFlux'
      end if
      r2Ptr(1) % block => block

      if (DMSTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'DMSTracersSurfaceFlux', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'DMSTracersSurfaceFlux', r2Ptr)

! Define var array DMSTracersSurfaceFluxRunoff
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group DMSSurfaceFluxRunoffGRP
! Define constituent var DMSSurfaceFluxRunoff
! My Packages are DMSTracersPKG
      if (DMSTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DMSSurfaceFluxRunoff', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'DMSSurfaceFluxRunoffGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_DMSSurfaceFluxRunoff', -1)
           end if
      end if
! Define constituent var DMSPSurfaceFluxRunoff
! My packages are DMSTracersPKG
      if (DMSTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DMSPSurfaceFluxRunoff', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'DMSSurfaceFluxRunoffGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DMSPSurfaceFluxRunoff', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'DMSSurfaceFluxRunoffGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'DMSSurfaceFluxRunoffGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'DMSSurfaceFluxRunoffGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_DMSTracersSurfaceFluxRunoff', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'DMSTracersSurfaceFluxRunoff'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DMSSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DMSSurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DMSPSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DMSPSurfaceFluxRunoff'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_DMSTracersSurfaceFluxRunoff'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DMSSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dimethyl Sulfide Surface Flux Due to Runoff')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DMSSurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DMSPSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dimethyl Sulfoniopropionate Surface Flux Due '&
//'to Runoff')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DMSPSurfaceFluxRunoff'
      end if
      r2Ptr(1) % block => block

      if (DMSTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'DMSTracersSurfaceFluxRunoff', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'DMSTracersSurfaceFluxRunoff', r2Ptr)

! Define var array DMSTracersSurfaceFluxRemoved
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group DMSSurfaceFluxRemovedGRP
! Define constituent var DMSSurfaceFluxRemoved
! My Packages are DMSTracersPKG
      if (DMSTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DMSSurfaceFluxRemoved', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'DMSSurfaceFluxRemovedGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_DMSSurfaceFluxRemoved', -1)
           end if
      end if
! Define constituent var DMSPSurfaceFluxRemoved
! My packages are DMSTracersPKG
      if (DMSTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DMSPSurfaceFluxRemoved', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'DMSSurfaceFluxRemovedGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DMSPSurfaceFluxRemoved', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'DMSSurfaceFluxRemovedGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'DMSSurfaceFluxRemovedGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'DMSSurfaceFluxRemovedGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_DMSTracersSurfaceFluxRemoved', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'DMSTracersSurfaceFluxRemoved'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DMSSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DMSSurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DMSPSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DMSPSurfaceFluxRemoved'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_DMSTracersSurfaceFluxRemoved'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DMSSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dimethyl Sulfide Surface Flux that is '&
//'ignored')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DMSSurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DMSPSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Dimethyl Sulfoniopropionate Surface Flux that '&
//'is ignored')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DMSPSurfaceFluxRemoved'
      end if
      r2Ptr(1) % block => block

      if (DMSTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'DMSTracersSurfaceFluxRemoved', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'DMSTracersSurfaceFluxRemoved', r2Ptr)

! Define var array MacroMoleculesTracersSurfaceFlux
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group MacroMoleculesSurfaceFluxGRP
! Define constituent var PROTSurfaceFlux
! My Packages are MacroMoleculesTracersPKG
      if (MacroMoleculesTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_PROTSurfaceFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesSurfaceFluxGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_PROTSurfaceFlux', -1)
           end if
      end if
! Define constituent var POLYSurfaceFlux
! My packages are MacroMoleculesTracersPKG
      if (MacroMoleculesTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_POLYSurfaceFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesSurfaceFluxGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_POLYSurfaceFlux', -1)
         end if
      end if
! Define constituent var LIPSurfaceFlux
! My packages are MacroMoleculesTracersPKG
      if (MacroMoleculesTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_LIPSurfaceFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesSurfaceFluxGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_LIPSurfaceFlux', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesSurfaceFluxGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesSurfaceFluxGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesSurfaceFluxGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_MacroMoleculesTracersSurfaceFlux', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'MacroMoleculesTracersSurfaceFlux'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_PROTSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'PROTSurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_POLYSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'POLYSurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_LIPSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'LIPSurfaceFlux'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_MacroMoleculesTracersSurfaceFlux'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_PROTSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Proteins Surface Flux')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'PROTSurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_POLYSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Polysaccharides Surface Flux')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'POLYSurfaceFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_LIPSurfaceFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Lipids Surface Flux')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'LIPSurfaceFlux'
      end if
      r2Ptr(1) % block => block

      if (MacroMoleculesTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'MacroMoleculesTracersSurfaceFlux', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'MacroMoleculesTracersSurfaceFlux', r2Ptr)

! Define var array MacroMoleculesTracersSurfaceFluxRunoff
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group MacroMoleculesSurfaceFluxRunoffGRP
! Define constituent var PROTSurfaceFluxRunoff
! My Packages are MacroMoleculesTracersPKG
      if (MacroMoleculesTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_PROTSurfaceFluxRunoff', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesSurfaceFluxRunoffGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_PROTSurfaceFluxRunoff', -1)
           end if
      end if
! Define constituent var POLYSurfaceFluxRunoff
! My packages are MacroMoleculesTracersPKG
      if (MacroMoleculesTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_POLYSurfaceFluxRunoff', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesSurfaceFluxRunoffGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_POLYSurfaceFluxRunoff', -1)
         end if
      end if
! Define constituent var LIPSurfaceFluxRunoff
! My packages are MacroMoleculesTracersPKG
      if (MacroMoleculesTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_LIPSurfaceFluxRunoff', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesSurfaceFluxRunoffGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_LIPSurfaceFluxRunoff', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesSurfaceFluxRunoffGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesSurfaceFluxRunoffGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesSurfaceFluxRunoffGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_MacroMoleculesTracersSurfaceFluxRunoff', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'MacroMoleculesTracersSurfaceFluxRunoff'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_PROTSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'PROTSurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_POLYSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'POLYSurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_LIPSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'LIPSurfaceFluxRunoff'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_MacroMoleculesTracersSurfaceFluxRunoff'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_PROTSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Proteins Surface Flux Due to Runoff')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'PROTSurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_POLYSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Polysaccharides Surface Flux Due to Runoff')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'POLYSurfaceFluxRunoff'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_LIPSurfaceFluxRunoff', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Lipids Surface Flux Due to Runoff')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'LIPSurfaceFluxRunoff'
      end if
      r2Ptr(1) % block => block

      if (MacroMoleculesTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'MacroMoleculesTracersSurfaceFluxRunoff', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'MacroMoleculesTracersSurfaceFluxRunoff', r2Ptr)

! Define var array MacroMoleculesTracersSurfaceFluxRemoved
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group MacroMoleculesSurfaceFluxRemovedGRP
! Define constituent var PROTSurfaceFluxRemoved
! My Packages are MacroMoleculesTracersPKG
      if (MacroMoleculesTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_PROTSurfaceFluxRemoved', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesSurfaceFluxRemovedGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_PROTSurfaceFluxRemoved', -1)
           end if
      end if
! Define constituent var POLYSurfaceFluxRemoved
! My packages are MacroMoleculesTracersPKG
      if (MacroMoleculesTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_POLYSurfaceFluxRemoved', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesSurfaceFluxRemovedGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_POLYSurfaceFluxRemoved', -1)
         end if
      end if
! Define constituent var LIPSurfaceFluxRemoved
! My packages are MacroMoleculesTracersPKG
      if (MacroMoleculesTracersPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_LIPSurfaceFluxRemoved', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesSurfaceFluxRemovedGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_LIPSurfaceFluxRemoved', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesSurfaceFluxRemovedGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesSurfaceFluxRemovedGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesSurfaceFluxRemovedGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_MacroMoleculesTracersSurfaceFluxRemoved', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'MacroMoleculesTracersSurfaceFluxRemoved'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_PROTSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'PROTSurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_POLYSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'POLYSurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_LIPSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'LIPSurfaceFluxRemoved'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_MacroMoleculesTracersSurfaceFluxRemoved'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_PROTSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Proteins Surface Flux that is ignored')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'PROTSurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_POLYSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Polysaccharides Surface Flux that is ignored')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'POLYSurfaceFluxRemoved'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_LIPSurfaceFluxRemoved', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Lipids Surface Flux that is ignored')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol m^{-3} m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'LIPSurfaceFluxRemoved'
      end if
      r2Ptr(1) % block => block

      if (MacroMoleculesTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'MacroMoleculesTracersSurfaceFluxRemoved', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'MacroMoleculesTracersSurfaceFluxRemoved', r2Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_forcing_subpool_tracersSurfaceFlux


   subroutine ocn_generate_forcing_subpool_tracersSurfaceRestoringFields(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'tracersSurfaceRestoringFields', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'tracersSurfaceRestoringFields', newSubPool)

! Define var array activeTracersPistonVelocity
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group activeGRP
! Define constituent var temperaturePistonVelocity
! My Packages are activeTracersSurfaceRestoringPKG
      if (activeTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperaturePistonVelocity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_temperaturePistonVelocity', -1)
           end if
      end if
! Define constituent var salinityPistonVelocity
! My packages are activeTracersSurfaceRestoringPKG
      if (activeTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityPistonVelocity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityPistonVelocity', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'activeGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_activeTracersPistonVelocity', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'activeTracersPistonVelocity'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperaturePistonVelocity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'temperaturePistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityPistonVelocity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'salinityPistonVelocity'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_activeTracersPistonVelocity'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperaturePistonVelocity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which temperature is restored to temperatureSurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'temperaturePistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityPistonVelocity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which salinity is restored to salinitySurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'salinityPistonVelocity'
      end if
      r2Ptr(1) % block => block

      if (activeTracersSurfaceRestoringPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'activeTracersPistonVelocity', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'activeTracersPistonVelocity', r2Ptr)

! Define var array activeTracersSurfaceRestoringValue
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group activeGRP
! Define constituent var temperatureSurfaceRestoringValue
! My Packages are activeTracersSurfaceRestoringPKG
      if (activeTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureSurfaceRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_temperatureSurfaceRestoringValue', -1)
           end if
      end if
! Define constituent var salinitySurfaceRestoringValue
! My packages are activeTracersSurfaceRestoringPKG
      if (activeTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinitySurfaceRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinitySurfaceRestoringValue', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'activeGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_activeTracersSurfaceRestoringValue', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'activeTracersSurfaceRestoringValue'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'temperatureSurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinitySurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'salinitySurfaceRestoringValue'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_activeTracersSurfaceRestoringValue'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Temperature is restored toward this field at '&
//'a rate controlled by temperaturePistonVelocity.')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', '^\circ C')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'temperatureSurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinitySurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Salinity is restored toward this field at a '&
//'rate controlled by salinityPistonVelocity.')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'PSU')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'salinitySurfaceRestoringValue'
      end if
      r2Ptr(1) % block => block

      if (activeTracersSurfaceRestoringPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'activeTracersSurfaceRestoringValue', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'activeTracersSurfaceRestoringValue', r2Ptr)

! Define var array debugTracersPistonVelocity
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group debugGRP
! Define constituent var tracer1PistonVelocity
! My Packages are debugTracersSurfaceRestoringPKG
      if (debugTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_tracer1PistonVelocity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'debugGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_tracer1PistonVelocity', -1)
           end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'debugGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'debugGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'debugGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_debugTracersPistonVelocity', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'debugTracersPistonVelocity'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_tracer1PistonVelocity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'tracer1PistonVelocity'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_debugTracersPistonVelocity'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_tracer1PistonVelocity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which tracer1 is restored to tracer1SurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'tracer1PistonVelocity'
      end if
      r2Ptr(1) % block => block

      if (debugTracersSurfaceRestoringPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'debugTracersPistonVelocity', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'debugTracersPistonVelocity', r2Ptr)

! Define var array debugTracersSurfaceRestoringValue
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group debugGRP
! Define constituent var tracer1SurfaceRestoringValue
! My Packages are debugTracersSurfaceRestoringPKG
      if (debugTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_tracer1SurfaceRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'debugGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_tracer1SurfaceRestoringValue', -1)
           end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'debugGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'debugGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'debugGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_debugTracersSurfaceRestoringValue', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'debugTracersSurfaceRestoringValue'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_tracer1SurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'tracer1SurfaceRestoringValue'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_debugTracersSurfaceRestoringValue'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_tracer1SurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'tracer1 is restored toward this field at a '&
//'rate controlled by tracer1PistonVelocity.')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', '^\circ C')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'tracer1SurfaceRestoringValue'
      end if
      r2Ptr(1) % block => block

      if (debugTracersSurfaceRestoringPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'debugTracersSurfaceRestoringValue', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'debugTracersSurfaceRestoringValue', r2Ptr)

! Define var array ecosysTracersPistonVelocity
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group ecosysPVGRP
! Define constituent var PO4PistonVelocity
! My Packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_PO4PistonVelocity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysPVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_PO4PistonVelocity', -1)
           end if
      end if
! Define constituent var NO3PistonVelocity
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_NO3PistonVelocity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysPVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_NO3PistonVelocity', -1)
         end if
      end if
! Define constituent var SiO3PistonVelocity
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_SiO3PistonVelocity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysPVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_SiO3PistonVelocity', -1)
         end if
      end if
! Define constituent var NH4PistonVelocity
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_NH4PistonVelocity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysPVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_NH4PistonVelocity', -1)
         end if
      end if
! Define constituent var FePistonVelocity
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_FePistonVelocity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysPVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_FePistonVelocity', -1)
         end if
      end if
! Define constituent var O2PistonVelocity
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_O2PistonVelocity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysPVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_O2PistonVelocity', -1)
         end if
      end if
! Define constituent var DICPistonVelocity
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DICPistonVelocity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysPVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DICPistonVelocity', -1)
         end if
      end if
! Define constituent var DIC_ALT_CO2PistonVelocity
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DIC_ALT_CO2PistonVelocity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysPVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DIC_ALT_CO2PistonVelocity', -1)
         end if
      end if
! Define constituent var ALKPistonVelocity
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_ALKPistonVelocity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysPVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_ALKPistonVelocity', -1)
         end if
      end if
! Define constituent var DOCPistonVelocity
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOCPistonVelocity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysPVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOCPistonVelocity', -1)
         end if
      end if
! Define constituent var DONPistonVelocity
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DONPistonVelocity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysPVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DONPistonVelocity', -1)
         end if
      end if
! Define constituent var DOFePistonVelocity
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOFePistonVelocity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysPVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOFePistonVelocity', -1)
         end if
      end if
! Define constituent var DOPPistonVelocity
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOPPistonVelocity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysPVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOPPistonVelocity', -1)
         end if
      end if
! Define constituent var DOPrPistonVelocity
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOPrPistonVelocity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysPVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOPrPistonVelocity', -1)
         end if
      end if
! Define constituent var DONrPistonVelocity
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DONrPistonVelocity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysPVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DONrPistonVelocity', -1)
         end if
      end if
! Define constituent var zooCPistonVelocity
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_zooCPistonVelocity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysPVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_zooCPistonVelocity', -1)
         end if
      end if
! Define constituent var spChlPistonVelocity
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spChlPistonVelocity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysPVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spChlPistonVelocity', -1)
         end if
      end if
! Define constituent var spCPistonVelocity
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spCPistonVelocity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysPVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spCPistonVelocity', -1)
         end if
      end if
! Define constituent var spFePistonVelocity
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spFePistonVelocity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysPVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spFePistonVelocity', -1)
         end if
      end if
! Define constituent var spCaCO3PistonVelocity
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spCaCO3PistonVelocity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysPVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spCaCO3PistonVelocity', -1)
         end if
      end if
! Define constituent var diatChlPistonVelocity
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatChlPistonVelocity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysPVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatChlPistonVelocity', -1)
         end if
      end if
! Define constituent var diatCPistonVelocity
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatCPistonVelocity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysPVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatCPistonVelocity', -1)
         end if
      end if
! Define constituent var diatFePistonVelocity
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatFePistonVelocity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysPVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatFePistonVelocity', -1)
         end if
      end if
! Define constituent var diatSiPistonVelocity
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatSiPistonVelocity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysPVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatSiPistonVelocity', -1)
         end if
      end if
! Define constituent var diazChlPistonVelocity
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazChlPistonVelocity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysPVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazChlPistonVelocity', -1)
         end if
      end if
! Define constituent var diazCPistonVelocity
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazCPistonVelocity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysPVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazCPistonVelocity', -1)
         end if
      end if
! Define constituent var diazFePistonVelocity
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazFePistonVelocity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysPVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazFePistonVelocity', -1)
         end if
      end if
! Define constituent var phaeoChlPistonVelocity
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoChlPistonVelocity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysPVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoChlPistonVelocity', -1)
         end if
      end if
! Define constituent var phaeoCPistonVelocity
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoCPistonVelocity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysPVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoCPistonVelocity', -1)
         end if
      end if
! Define constituent var phaeoFePistonVelocity
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoFePistonVelocity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysPVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoFePistonVelocity', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysPVGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'ecosysPVGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysPVGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_ecosysTracersPistonVelocity', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'ecosysTracersPistonVelocity'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_PO4PistonVelocity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'PO4PistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_NO3PistonVelocity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'NO3PistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_SiO3PistonVelocity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'SiO3PistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_NH4PistonVelocity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'NH4PistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_FePistonVelocity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'FePistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_O2PistonVelocity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'O2PistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DICPistonVelocity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DICPistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DIC_ALT_CO2PistonVelocity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DIC_ALT_CO2PistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_ALKPistonVelocity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'ALKPistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOCPistonVelocity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DOCPistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DONPistonVelocity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DONPistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOFePistonVelocity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DOFePistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOPPistonVelocity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DOPPistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOPrPistonVelocity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DOPrPistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DONrPistonVelocity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DONrPistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_zooCPistonVelocity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'zooCPistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spChlPistonVelocity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'spChlPistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spCPistonVelocity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'spCPistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spFePistonVelocity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'spFePistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spCaCO3PistonVelocity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'spCaCO3PistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatChlPistonVelocity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'diatChlPistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatCPistonVelocity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'diatCPistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatFePistonVelocity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'diatFePistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatSiPistonVelocity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'diatSiPistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazChlPistonVelocity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'diazChlPistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazCPistonVelocity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'diazCPistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazFePistonVelocity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'diazFePistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoChlPistonVelocity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'phaeoChlPistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoCPistonVelocity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'phaeoCPistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoFePistonVelocity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'phaeoFePistonVelocity'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_ecosysTracersPistonVelocity'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_PO4PistonVelocity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which PO4 is restored to PO4SurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'PO4PistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_NO3PistonVelocity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which NO3 is restored to NO3SurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'NO3PistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_SiO3PistonVelocity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which SiO3 is restored to SiO3SurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'SiO3PistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_NH4PistonVelocity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which NH4 is restored to NH4SurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'NH4PistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_FePistonVelocity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which Fe is restored to FeSurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'FePistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_O2PistonVelocity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which O2 is restored to O2SurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'O2PistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DICPistonVelocity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which DIC is restored to DICSurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DICPistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DIC_ALT_CO2PistonVelocity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which DIC_ALT_CO2 is restored to DIC_ALT_CO2SurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DIC_ALT_CO2PistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_ALKPistonVelocity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which ALK is restored to ALKSurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'ALKPistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOCPistonVelocity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which DOC is restored to DOCSurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DOCPistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DONPistonVelocity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which DON is restored to DONSurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DONPistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOFePistonVelocity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which DOFe is restored to DOFeSurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DOFePistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOPPistonVelocity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which DOP is restored to DOPSurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DOPPistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOPrPistonVelocity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which DOPr is restored to DOPrSurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DOPrPistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DONrPistonVelocity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which DONr is restored to DONrSurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DONrPistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_zooCPistonVelocity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which zooC is restored to zooCSurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'zooCPistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spChlPistonVelocity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which spChl is restored to spChlSurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'spChlPistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spCPistonVelocity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which spC is restored to spCSurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'spCPistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spFePistonVelocity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which spFe is restored to spFeSurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'spFePistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spCaCO3PistonVelocity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which spCaCO3 is restored to spCaCO3SurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'spCaCO3PistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatChlPistonVelocity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which diatChl is restored to diatChlSurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'diatChlPistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatCPistonVelocity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which diatC is restored to diatCSurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'diatCPistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatFePistonVelocity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which diatFe is restored to diatFeSurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'diatFePistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatSiPistonVelocity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which diatSi is restored to diatSiSurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'diatSiPistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazChlPistonVelocity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which diazChl is restored to diazChlSurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'diazChlPistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazCPistonVelocity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which diazC is restored to diazCSurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'diazCPistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazFePistonVelocity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which diazFe is restored to diazFeSurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'diazFePistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoChlPistonVelocity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which phaeoChl is restored to phaeoChlSurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'phaeoChlPistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoCPistonVelocity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which phaeoC is restored to phaeoCSurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'phaeoCPistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoFePistonVelocity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which phaeoFe is restored to phaeoFeSurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'phaeoFePistonVelocity'
      end if
      r2Ptr(1) % block => block

      if (ecosysTracersSurfaceRestoringPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosysTracersPistonVelocity', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosysTracersPistonVelocity', r2Ptr)

! Define var array ecosysTracersSurfaceRestoringValue
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group ecosysSRVGRP
! Define constituent var PO4SurfaceRestoringValue
! My Packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_PO4SurfaceRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_PO4SurfaceRestoringValue', -1)
           end if
      end if
! Define constituent var NO3SurfaceRestoringValue
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_NO3SurfaceRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_NO3SurfaceRestoringValue', -1)
         end if
      end if
! Define constituent var SiO3SurfaceRestoringValue
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_SiO3SurfaceRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_SiO3SurfaceRestoringValue', -1)
         end if
      end if
! Define constituent var NH4SurfaceRestoringValue
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_NH4SurfaceRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_NH4SurfaceRestoringValue', -1)
         end if
      end if
! Define constituent var FeSurfaceRestoringValue
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_FeSurfaceRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_FeSurfaceRestoringValue', -1)
         end if
      end if
! Define constituent var O2SurfaceRestoringValue
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_O2SurfaceRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_O2SurfaceRestoringValue', -1)
         end if
      end if
! Define constituent var DICSurfaceRestoringValue
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DICSurfaceRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DICSurfaceRestoringValue', -1)
         end if
      end if
! Define constituent var DIC_ALT_CO2SurfaceRestoringValue
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DIC_ALT_CO2SurfaceRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DIC_ALT_CO2SurfaceRestoringValue', -1)
         end if
      end if
! Define constituent var ALKSurfaceRestoringValue
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_ALKSurfaceRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_ALKSurfaceRestoringValue', -1)
         end if
      end if
! Define constituent var DOCSurfaceRestoringValue
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOCSurfaceRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOCSurfaceRestoringValue', -1)
         end if
      end if
! Define constituent var DONSurfaceRestoringValue
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DONSurfaceRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DONSurfaceRestoringValue', -1)
         end if
      end if
! Define constituent var DOFeSurfaceRestoringValue
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOFeSurfaceRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOFeSurfaceRestoringValue', -1)
         end if
      end if
! Define constituent var DOPSurfaceRestoringValue
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOPSurfaceRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOPSurfaceRestoringValue', -1)
         end if
      end if
! Define constituent var DOPrSurfaceRestoringValue
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOPrSurfaceRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOPrSurfaceRestoringValue', -1)
         end if
      end if
! Define constituent var DONrSurfaceRestoringValue
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DONrSurfaceRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DONrSurfaceRestoringValue', -1)
         end if
      end if
! Define constituent var spChlSurfaceRestoringValue
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spChlSurfaceRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spChlSurfaceRestoringValue', -1)
         end if
      end if
! Define constituent var spCSurfaceRestoringValue
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spCSurfaceRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spCSurfaceRestoringValue', -1)
         end if
      end if
! Define constituent var spFeSurfaceRestoringValue
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spFeSurfaceRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spFeSurfaceRestoringValue', -1)
         end if
      end if
! Define constituent var spCaCO3SurfaceRestoringValue
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spCaCO3SurfaceRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spCaCO3SurfaceRestoringValue', -1)
         end if
      end if
! Define constituent var diatChlSurfaceRestoringValue
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatChlSurfaceRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatChlSurfaceRestoringValue', -1)
         end if
      end if
! Define constituent var diatCSurfaceRestoringValue
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatCSurfaceRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatCSurfaceRestoringValue', -1)
         end if
      end if
! Define constituent var diatFeSurfaceRestoringValue
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatFeSurfaceRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatFeSurfaceRestoringValue', -1)
         end if
      end if
! Define constituent var diatSiSurfaceRestoringValue
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatSiSurfaceRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatSiSurfaceRestoringValue', -1)
         end if
      end if
! Define constituent var diazChlSurfaceRestoringValue
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazChlSurfaceRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazChlSurfaceRestoringValue', -1)
         end if
      end if
! Define constituent var diazCSurfaceRestoringValue
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazCSurfaceRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazCSurfaceRestoringValue', -1)
         end if
      end if
! Define constituent var diazFeSurfaceRestoringValue
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazFeSurfaceRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazFeSurfaceRestoringValue', -1)
         end if
      end if
! Define constituent var phaeoChlSurfaceRestoringValue
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoChlSurfaceRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoChlSurfaceRestoringValue', -1)
         end if
      end if
! Define constituent var phaeoCSurfaceRestoringValue
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoCSurfaceRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoCSurfaceRestoringValue', -1)
         end if
      end if
! Define constituent var phaeoFeSurfaceRestoringValue
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoFeSurfaceRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoFeSurfaceRestoringValue', -1)
         end if
      end if
! Define constituent var zooCSurfaceRestoringValue
! My packages are ecosysTracersSurfaceRestoringPKG
      if (ecosysTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_zooCSurfaceRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_zooCSurfaceRestoringValue', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSRVGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'ecosysSRVGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysSRVGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_ecosysTracersSurfaceRestoringValue', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'ecosysTracersSurfaceRestoringValue'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_PO4SurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'PO4SurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_NO3SurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'NO3SurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_SiO3SurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'SiO3SurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_NH4SurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'NH4SurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_FeSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'FeSurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_O2SurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'O2SurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DICSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DICSurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DIC_ALT_CO2SurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DIC_ALT_CO2SurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_ALKSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'ALKSurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOCSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DOCSurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DONSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DONSurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOFeSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DOFeSurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOPSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DOPSurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOPrSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DOPrSurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DONrSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DONrSurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spChlSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'spChlSurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spCSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'spCSurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spFeSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'spFeSurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spCaCO3SurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'spCaCO3SurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatChlSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'diatChlSurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatCSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'diatCSurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatFeSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'diatFeSurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatSiSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'diatSiSurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazChlSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'diazChlSurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazCSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'diazCSurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazFeSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'diazFeSurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoChlSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'phaeoChlSurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoCSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'phaeoCSurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoFeSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'phaeoFeSurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_zooCSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'zooCSurfaceRestoringValue'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_ecosysTracersSurfaceRestoringValue'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_PO4SurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which PO4 is restored to PO4SurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'PO4SurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_NO3SurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which NO3 is restored to NO3SurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'NO3SurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_SiO3SurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which SiO3 is restored to SiO3SurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'SiO3SurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_NH4SurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which NH4 is restored to NH4SurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'NH4SurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_FeSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which Fe is restored to FeSurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'FeSurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_O2SurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which O2 is restored to O2SurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'O2SurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DICSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which DIC is restored to DICSurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DICSurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DIC_ALT_CO2SurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which DIC_ALT_CO2 is restored to DIC_ALT_CO2SurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DIC_ALT_CO2SurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_ALKSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which ALK is restored to ALKSurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'ALKSurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOCSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which DOC is restored to DOCSurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DOCSurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DONSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which DON is restored to DONSurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DONSurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOFeSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which DOFe is restored to DOFeSurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DOFeSurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOPSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which DOP is restored to DOPSurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DOPSurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOPrSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which DOPr is restored to DOPrSurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DOPrSurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DONrSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which DONr is restored to DOPrSurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DONrSurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spChlSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which zooC is restored to DOPrSurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'spChlSurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spCSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which zooC is restored to DOPrSurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'spCSurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spFeSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which zooC is restored to DOPrSurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'spFeSurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spCaCO3SurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which zooC is restored to DOPrSurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'spCaCO3SurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatChlSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which zooC is restored to DOPrSurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'diatChlSurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatCSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which zooC is restored to DOPrSurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'diatCSurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatFeSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which zooC is restored to DOPrSurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'diatFeSurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatSiSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which zooC is restored to DOPrSurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'diatSiSurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazChlSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which zooC is restored to DOPrSurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'diazChlSurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazCSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which zooC is restored to DOPrSurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'diazCSurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazFeSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which zooC is restored to DOPrSurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'diazFeSurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoChlSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which zooC is restored to DOPrSurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'phaeoChlSurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoCSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which zooC is restored to DOPrSurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'phaeoCSurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoFeSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which zooC is restored to DOPrSurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'phaeoFeSurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_zooCSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which zooC is restored to DOPrSurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'zooCSurfaceRestoringValue'
      end if
      r2Ptr(1) % block => block

      if (ecosysTracersSurfaceRestoringPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosysTracersSurfaceRestoringValue', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosysTracersSurfaceRestoringValue', r2Ptr)

! Define var array DMSTracersPistonVelocity
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group DMSPVGRP
! Define constituent var DMSPistonVelocity
! My Packages are DMSTracersSurfaceRestoringPKG
      if (DMSTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DMSPistonVelocity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'DMSPVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_DMSPistonVelocity', -1)
           end if
      end if
! Define constituent var DMSPPistonVelocity
! My packages are DMSTracersSurfaceRestoringPKG
      if (DMSTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DMSPPistonVelocity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'DMSPVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DMSPPistonVelocity', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'DMSPVGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'DMSPVGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'DMSPVGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_DMSTracersPistonVelocity', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'DMSTracersPistonVelocity'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DMSPistonVelocity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DMSPistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DMSPPistonVelocity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DMSPPistonVelocity'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_DMSTracersPistonVelocity'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DMSPistonVelocity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which DMS is restored to DMSSurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DMSPistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DMSPPistonVelocity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which DMSP is restored to DMSPSurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DMSPPistonVelocity'
      end if
      r2Ptr(1) % block => block

      if (DMSTracersSurfaceRestoringPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'DMSTracersPistonVelocity', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'DMSTracersPistonVelocity', r2Ptr)

! Define var array DMSTracersSurfaceRestoringValue
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group DMSSRVGRP
! Define constituent var DMSSurfaceRestoringValue
! My Packages are DMSTracersSurfaceRestoringPKG
      if (DMSTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DMSSurfaceRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'DMSSRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_DMSSurfaceRestoringValue', -1)
           end if
      end if
! Define constituent var DMSPSurfaceRestoringValue
! My packages are DMSTracersSurfaceRestoringPKG
      if (DMSTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DMSPSurfaceRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'DMSSRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DMSPSurfaceRestoringValue', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'DMSSRVGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'DMSSRVGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'DMSSRVGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_DMSTracersSurfaceRestoringValue', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'DMSTracersSurfaceRestoringValue'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DMSSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DMSSurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DMSPSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DMSPSurfaceRestoringValue'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_DMSTracersSurfaceRestoringValue'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DMSSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Tracer is restored toward this field at a '&
//'rate controlled by DMSPistonVelocity.')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol m^{3}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DMSSurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DMSPSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Tracer is restored toward this field at a '&
//'rate controlled by DMSPPistonVelocity.')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol m^{3}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DMSPSurfaceRestoringValue'
      end if
      r2Ptr(1) % block => block

      if (DMSTracersSurfaceRestoringPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'DMSTracersSurfaceRestoringValue', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'DMSTracersSurfaceRestoringValue', r2Ptr)

! Define var array MacroMoleculesTracersPistonVelocity
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group MacroMoleculesPVGRP
! Define constituent var PROTPistonVelocity
! My Packages are MacroMoleculesTracersSurfaceRestoringPKG
      if (MacroMoleculesTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_PROTPistonVelocity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesPVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_PROTPistonVelocity', -1)
           end if
      end if
! Define constituent var POLYPistonVelocity
! My packages are MacroMoleculesTracersSurfaceRestoringPKG
      if (MacroMoleculesTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_POLYPistonVelocity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesPVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_POLYPistonVelocity', -1)
         end if
      end if
! Define constituent var LIPPistonVelocity
! My packages are MacroMoleculesTracersSurfaceRestoringPKG
      if (MacroMoleculesTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_LIPPistonVelocity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesPVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_LIPPistonVelocity', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesPVGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesPVGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesPVGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_MacroMoleculesTracersPistonVelocity', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'MacroMoleculesTracersPistonVelocity'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_PROTPistonVelocity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'PROTPistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_POLYPistonVelocity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'POLYPistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_LIPPistonVelocity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'LIPPistonVelocity'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_MacroMoleculesTracersPistonVelocity'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_PROTPistonVelocity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which PROT is restored to PROTSurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'PROTPistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_POLYPistonVelocity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which POLY is restored to POLYSurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'POLYPistonVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_LIPPistonVelocity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which LIP is restored to LIPSurfaceRestoringValue')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'LIPPistonVelocity'
      end if
      r2Ptr(1) % block => block

      if (MacroMoleculesTracersSurfaceRestoringPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'MacroMoleculesTracersPistonVelocity', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'MacroMoleculesTracersPistonVelocity', r2Ptr)

! Define var array MacroMoleculesTracersSurfaceRestoringValue
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group MacroMoleculesSRVGRP
! Define constituent var PROTSurfaceRestoringValue
! My Packages are MacroMoleculesTracersSurfaceRestoringPKG
      if (MacroMoleculesTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_PROTSurfaceRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesSRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_PROTSurfaceRestoringValue', -1)
           end if
      end if
! Define constituent var POLYSurfaceRestoringValue
! My packages are MacroMoleculesTracersSurfaceRestoringPKG
      if (MacroMoleculesTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_POLYSurfaceRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesSRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_POLYSurfaceRestoringValue', -1)
         end if
      end if
! Define constituent var LIPSurfaceRestoringValue
! My packages are MacroMoleculesTracersSurfaceRestoringPKG
      if (MacroMoleculesTracersSurfaceRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_LIPSurfaceRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesSRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_LIPSurfaceRestoringValue', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesSRVGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesSRVGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesSRVGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_MacroMoleculesTracersSurfaceRestoringValue', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'MacroMoleculesTracersSurfaceRestoringValue'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_PROTSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'PROTSurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_POLYSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'POLYSurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_LIPSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'LIPSurfaceRestoringValue'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_MacroMoleculesTracersSurfaceRestoringValue'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_PROTSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Tracer is restored toward this field at a '&
//'rate controlled by PROTPistonVelocity.')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol m^{3}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'PROTSurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_POLYSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Tracer is restored toward this field at a '&
//'rate controlled by POLYPistonVelocity.')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol m^{3}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'POLYSurfaceRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_LIPSurfaceRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Tracer is restored toward this field at a '&
//'rate controlled by LIPPistonVelocity.')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'mmol m^{3}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'LIPSurfaceRestoringValue'
      end if
      r2Ptr(1) % block => block

      if (MacroMoleculesTracersSurfaceRestoringPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'MacroMoleculesTracersSurfaceRestoringValue', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'MacroMoleculesTracersSurfaceRestoringValue', r2Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_forcing_subpool_tracersSurfaceRestoringFields


   subroutine ocn_generate_forcing_subpool_tracersInteriorRestoringFields(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'tracersInteriorRestoringFields', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'tracersInteriorRestoringFields', newSubPool)

! Define var array activeTracersInteriorRestoringRate
      allocate(r3Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group activeGRP
! Define constituent var temperatureInteriorRestoringRate
! My Packages are activeTracersInteriorRestoringPKG
      if (activeTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureInteriorRestoringRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_temperatureInteriorRestoringRate', -1)
           end if
      end if
! Define constituent var salinityInteriorRestoringRate
! My packages are activeTracersInteriorRestoringPKG
      if (activeTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityInteriorRestoringRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityInteriorRestoringRate', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'activeGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_activeTracersInteriorRestoringRate', numConstituents)
      end if
! Defining time level 1
      allocate( r3Ptr(1) % constituentNames(numConstituents) )
      r3Ptr(1) % fieldName = 'activeTracersInteriorRestoringRate'
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isVarArray = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'temperatureInteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'salinityInteriorRestoringRate'
      end if

! Setup dimensions for       
      r3Ptr(1) % dimNames(1) = 'num_activeTracersInteriorRestoringRate'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nCells'

      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(size(r3Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r3Ptr(1) % constituentNames, dim=1)
         allocate(r3Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which temperature is restored to temperatureInteriorRestoringValue')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', '{s}^-1')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'temperatureInteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which salinity is restored to salinityInteriorRestoringValue')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', '{s}^-1')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'salinityInteriorRestoringRate'
      end if
      r3Ptr(1) % block => block

      if (activeTracersInteriorRestoringPKGActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'activeTracersInteriorRestoringRate', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'activeTracersInteriorRestoringRate', r3Ptr)

! Define var array activeTracersInteriorRestoringValue
      allocate(r3Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group activeGRP
! Define constituent var temperatureInteriorRestoringValue
! My Packages are activeTracersInteriorRestoringPKG
      if (activeTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureInteriorRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_temperatureInteriorRestoringValue', -1)
           end if
      end if
! Define constituent var salinityInteriorRestoringValue
! My packages are activeTracersInteriorRestoringPKG
      if (activeTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityInteriorRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityInteriorRestoringValue', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'activeGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_activeTracersInteriorRestoringValue', numConstituents)
      end if
! Defining time level 1
      allocate( r3Ptr(1) % constituentNames(numConstituents) )
      r3Ptr(1) % fieldName = 'activeTracersInteriorRestoringValue'
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isVarArray = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'temperatureInteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'salinityInteriorRestoringValue'
      end if

! Setup dimensions for       
      r3Ptr(1) % dimNames(1) = 'num_activeTracersInteriorRestoringValue'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nCells'

      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(size(r3Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r3Ptr(1) % constituentNames, dim=1)
         allocate(r3Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Temperature is restored toward this field at '&
//'a rate controlled by temperatureInteriorRestoringRate.')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', '^\circ C')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'temperatureInteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Salinity is restored toward this field at a '&
//'rate controlled by salinityInteriorRestoringRate.')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'PSU')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'salinityInteriorRestoringValue'
      end if
      r3Ptr(1) % block => block

      if (activeTracersInteriorRestoringPKGActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'activeTracersInteriorRestoringValue', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'activeTracersInteriorRestoringValue', r3Ptr)

! Define var array debugTracersInteriorRestoringRate
      allocate(r3Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group debugGRP
! Define constituent var tracer1InteriorRestoringRate
! My Packages are debugTracersInteriorRestoringPKG
      if (debugTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_tracer1InteriorRestoringRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'debugGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_tracer1InteriorRestoringRate', -1)
           end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'debugGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'debugGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'debugGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_debugTracersInteriorRestoringRate', numConstituents)
      end if
! Defining time level 1
      allocate( r3Ptr(1) % constituentNames(numConstituents) )
      r3Ptr(1) % fieldName = 'debugTracersInteriorRestoringRate'
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isVarArray = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_tracer1InteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'tracer1InteriorRestoringRate'
      end if

! Setup dimensions for       
      r3Ptr(1) % dimNames(1) = 'num_debugTracersInteriorRestoringRate'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nCells'

      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(size(r3Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r3Ptr(1) % constituentNames, dim=1)
         allocate(r3Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_tracer1InteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which tracer1 is restored to tracer1InteriorRestoringValue')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', '{s}^-1')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'tracer1InteriorRestoringRate'
      end if
      r3Ptr(1) % block => block

      if (debugTracersInteriorRestoringPKGActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'debugTracersInteriorRestoringRate', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'debugTracersInteriorRestoringRate', r3Ptr)

! Define var array debugTracersInteriorRestoringValue
      allocate(r3Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group debugGRP
! Define constituent var tracer1InteriorRestoringValue
! My Packages are debugTracersInteriorRestoringPKG
      if (debugTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_tracer1InteriorRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'debugGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_tracer1InteriorRestoringValue', -1)
           end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'debugGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'debugGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'debugGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_debugTracersInteriorRestoringValue', numConstituents)
      end if
! Defining time level 1
      allocate( r3Ptr(1) % constituentNames(numConstituents) )
      r3Ptr(1) % fieldName = 'debugTracersInteriorRestoringValue'
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isVarArray = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_tracer1InteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'tracer1InteriorRestoringValue'
      end if

! Setup dimensions for       
      r3Ptr(1) % dimNames(1) = 'num_debugTracersInteriorRestoringValue'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nCells'

      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(size(r3Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r3Ptr(1) % constituentNames, dim=1)
         allocate(r3Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_tracer1InteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'tracer1 is restored toward this field at a '&
//'rate controlled by tracer1InteriorRestoringRate.')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', '^\circ C')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'tracer1InteriorRestoringValue'
      end if
      r3Ptr(1) % block => block

      if (debugTracersInteriorRestoringPKGActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'debugTracersInteriorRestoringValue', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'debugTracersInteriorRestoringValue', r3Ptr)

! Define var array ecosysTracersInteriorRestoringRate
      allocate(r3Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group ecosysIRRGRP
! Define constituent var PO4InteriorRestoringRate
! My Packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_PO4InteriorRestoringRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRRGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_PO4InteriorRestoringRate', -1)
           end if
      end if
! Define constituent var NO3InteriorRestoringRate
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_NO3InteriorRestoringRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRRGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_NO3InteriorRestoringRate', -1)
         end if
      end if
! Define constituent var SiO3InteriorRestoringRate
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_SiO3InteriorRestoringRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRRGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_SiO3InteriorRestoringRate', -1)
         end if
      end if
! Define constituent var NH4InteriorRestoringRate
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_NH4InteriorRestoringRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRRGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_NH4InteriorRestoringRate', -1)
         end if
      end if
! Define constituent var FeInteriorRestoringRate
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_FeInteriorRestoringRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRRGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_FeInteriorRestoringRate', -1)
         end if
      end if
! Define constituent var O2InteriorRestoringRate
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_O2InteriorRestoringRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRRGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_O2InteriorRestoringRate', -1)
         end if
      end if
! Define constituent var DICInteriorRestoringRate
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DICInteriorRestoringRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRRGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DICInteriorRestoringRate', -1)
         end if
      end if
! Define constituent var DIC_ALT_CO2InteriorRestoringRate
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DIC_ALT_CO2InteriorRestoringRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRRGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DIC_ALT_CO2InteriorRestoringRate', -1)
         end if
      end if
! Define constituent var ALKInteriorRestoringRate
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_ALKInteriorRestoringRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRRGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_ALKInteriorRestoringRate', -1)
         end if
      end if
! Define constituent var DOCInteriorRestoringRate
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOCInteriorRestoringRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRRGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOCInteriorRestoringRate', -1)
         end if
      end if
! Define constituent var DONInteriorRestoringRate
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DONInteriorRestoringRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRRGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DONInteriorRestoringRate', -1)
         end if
      end if
! Define constituent var DOFeInteriorRestoringRate
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOFeInteriorRestoringRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRRGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOFeInteriorRestoringRate', -1)
         end if
      end if
! Define constituent var DOPInteriorRestoringRate
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOPInteriorRestoringRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRRGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOPInteriorRestoringRate', -1)
         end if
      end if
! Define constituent var DOPrInteriorRestoringRate
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOPrInteriorRestoringRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRRGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOPrInteriorRestoringRate', -1)
         end if
      end if
! Define constituent var DONrInteriorRestoringRate
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DONrInteriorRestoringRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRRGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DONrInteriorRestoringRate', -1)
         end if
      end if
! Define constituent var zooCInteriorRestoringRate
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_zooCInteriorRestoringRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRRGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_zooCInteriorRestoringRate', -1)
         end if
      end if
! Define constituent var spChlInteriorRestoringRate
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spChlInteriorRestoringRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRRGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spChlInteriorRestoringRate', -1)
         end if
      end if
! Define constituent var spCInteriorRestoringRate
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spCInteriorRestoringRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRRGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spCInteriorRestoringRate', -1)
         end if
      end if
! Define constituent var spFeInteriorRestoringRate
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spFeInteriorRestoringRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRRGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spFeInteriorRestoringRate', -1)
         end if
      end if
! Define constituent var spCaCO3InteriorRestoringRate
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spCaCO3InteriorRestoringRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRRGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spCaCO3InteriorRestoringRate', -1)
         end if
      end if
! Define constituent var diatChlInteriorRestoringRate
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatChlInteriorRestoringRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRRGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatChlInteriorRestoringRate', -1)
         end if
      end if
! Define constituent var diatCInteriorRestoringRate
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatCInteriorRestoringRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRRGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatCInteriorRestoringRate', -1)
         end if
      end if
! Define constituent var diatFeInteriorRestoringRate
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatFeInteriorRestoringRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRRGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatFeInteriorRestoringRate', -1)
         end if
      end if
! Define constituent var diatSiInteriorRestoringRate
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatSiInteriorRestoringRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRRGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatSiInteriorRestoringRate', -1)
         end if
      end if
! Define constituent var diazChlInteriorRestoringRate
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazChlInteriorRestoringRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRRGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazChlInteriorRestoringRate', -1)
         end if
      end if
! Define constituent var diazCInteriorRestoringRate
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazCInteriorRestoringRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRRGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazCInteriorRestoringRate', -1)
         end if
      end if
! Define constituent var diazFeInteriorRestoringRate
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazFeInteriorRestoringRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRRGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazFeInteriorRestoringRate', -1)
         end if
      end if
! Define constituent var phaeoChlInteriorRestoringRate
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoChlInteriorRestoringRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRRGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoChlInteriorRestoringRate', -1)
         end if
      end if
! Define constituent var phaeoCInteriorRestoringRate
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoCInteriorRestoringRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRRGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoCInteriorRestoringRate', -1)
         end if
      end if
! Define constituent var phaeoFeInteriorRestoringRate
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoFeInteriorRestoringRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRRGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoFeInteriorRestoringRate', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRRGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRRGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRRGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_ecosysTracersInteriorRestoringRate', numConstituents)
      end if
! Defining time level 1
      allocate( r3Ptr(1) % constituentNames(numConstituents) )
      r3Ptr(1) % fieldName = 'ecosysTracersInteriorRestoringRate'
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isVarArray = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_PO4InteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'PO4InteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_NO3InteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'NO3InteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_SiO3InteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'SiO3InteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_NH4InteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'NH4InteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_FeInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'FeInteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_O2InteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'O2InteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DICInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'DICInteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DIC_ALT_CO2InteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'DIC_ALT_CO2InteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_ALKInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'ALKInteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOCInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'DOCInteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DONInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'DONInteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOFeInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'DOFeInteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOPInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'DOPInteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOPrInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'DOPrInteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DONrInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'DONrInteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_zooCInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'zooCInteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spChlInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'spChlInteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spCInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'spCInteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spFeInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'spFeInteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spCaCO3InteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'spCaCO3InteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatChlInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'diatChlInteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatCInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'diatCInteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatFeInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'diatFeInteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatSiInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'diatSiInteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazChlInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'diazChlInteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazCInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'diazCInteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazFeInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'diazFeInteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoChlInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'phaeoChlInteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoCInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'phaeoCInteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoFeInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'phaeoFeInteriorRestoringRate'
      end if

! Setup dimensions for       
      r3Ptr(1) % dimNames(1) = 'num_ecosysTracersInteriorRestoringRate'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nCells'

      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(size(r3Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r3Ptr(1) % constituentNames, dim=1)
         allocate(r3Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_PO4InteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which PO4 is restored to PO4InteriorRestoringValue')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', '{s}^-1')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'PO4InteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_NO3InteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which NO3 is restored to NO3InteriorRestoringValue')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', '{s}^-1')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'NO3InteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_SiO3InteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which SiO3 is restored to SiO3InteriorRestoringValue')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', '{s}^-1')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'SiO3InteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_NH4InteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which NH4 is restored to NH4InteriorRestoringValue')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', '{s}^-1')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'NH4InteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_FeInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which Fe is restored to FeInteriorRestoringValue')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', '{s}^-1')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'FeInteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_O2InteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which O2 is restored to O2InteriorRestoringValue')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', '{s}^-1')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'O2InteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DICInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which DIC is restored to DICInteriorRestoringValue')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', '{s}^-1')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'DICInteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DIC_ALT_CO2InteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which DIC_ALT_CO2 is restored to DIC_ALT_CO2InteriorRestoringValue')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', '{s}^-1')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'DIC_ALT_CO2InteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_ALKInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which ALK is restored to ALKInteriorRestoringValue')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', '{s}^-1')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'ALKInteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOCInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which DOC is restored to DOCInteriorRestoringValue')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', '{s}^-1')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'DOCInteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DONInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which DON is restored to DONInteriorRestoringValue')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', '{s}^-1')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'DONInteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOFeInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which DOFe is restored to DOFeInteriorRestoringValue')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', '{s}^-1')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'DOFeInteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOPInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which DOP is restored to DOPInteriorRestoringValue')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', '{s}^-1')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'DOPInteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOPrInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which DOPr is restored to DOPrInteriorRestoringValue')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', '{s}^-1')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'DOPrInteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DONrInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which DONr is restored to DONrInteriorRestoringValue')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', '{s}^-1')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'DONrInteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_zooCInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which zooC is restored to zooCInteriorRestoringValue')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', '{s}^-1')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'zooCInteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spChlInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which spChl is restored to spChlInteriorRestoringValue')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', '{s}^-1')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'spChlInteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spCInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which spC is restored to spCInteriorRestoringValue')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', '{s}^-1')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'spCInteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spFeInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which spFe is restored to spFeInteriorRestoringValue')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', '{s}^-1')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'spFeInteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spCaCO3InteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which spCaCO3 is restored to spCaCO3InteriorRestoringValue')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', '{s}^-1')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'spCaCO3InteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatChlInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which diatChl is restored to diatChlInteriorRestoringValue')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', '{s}^-1')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'diatChlInteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatCInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which diatC is restored to diatCInteriorRestoringValue')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', '{s}^-1')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'diatCInteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatFeInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which diatFe is restored to diatFeInteriorRestoringValue')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', '{s}^-1')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'diatFeInteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatSiInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which diatSi is restored to diatSiInteriorRestoringValue')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', '{s}^-1')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'diatSiInteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazChlInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which diazChl is restored to diazChlInteriorRestoringValue')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', '{s}^-1')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'diazChlInteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazCInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which diazC is restored to diazCInteriorRestoringValue')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', '{s}^-1')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'diazCInteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazFeInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which diazFe is restored to diazFeInteriorRestoringValue')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', '{s}^-1')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'diazFeInteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoChlInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which phaeoChl is restored to phaeoChlInteriorRestoringValue')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', '{s}^-1')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'phaeoChlInteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoCInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which phaeoC is restored to phaeoCInteriorRestoringValue')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', '{s}^-1')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'phaeoCInteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoFeInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which phaeoFe is restored to phaeoFeInteriorRestoringValue')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', '{s}^-1')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'phaeoFeInteriorRestoringRate'
      end if
      r3Ptr(1) % block => block

      if (ecosysTracersInteriorRestoringPKGActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosysTracersInteriorRestoringRate', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosysTracersInteriorRestoringRate', r3Ptr)

! Define var array ecosysTracersInteriorRestoringValue
      allocate(r3Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group ecosysIRVGRP
! Define constituent var PO4InteriorRestoringValue
! My Packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_PO4InteriorRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_PO4InteriorRestoringValue', -1)
           end if
      end if
! Define constituent var NO3InteriorRestoringValue
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_NO3InteriorRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_NO3InteriorRestoringValue', -1)
         end if
      end if
! Define constituent var SiO3InteriorRestoringValue
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_SiO3InteriorRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_SiO3InteriorRestoringValue', -1)
         end if
      end if
! Define constituent var NH4InteriorRestoringValue
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_NH4InteriorRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_NH4InteriorRestoringValue', -1)
         end if
      end if
! Define constituent var FeInteriorRestoringValue
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_FeInteriorRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_FeInteriorRestoringValue', -1)
         end if
      end if
! Define constituent var O2InteriorRestoringValue
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_O2InteriorRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_O2InteriorRestoringValue', -1)
         end if
      end if
! Define constituent var DICInteriorRestoringValue
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DICInteriorRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DICInteriorRestoringValue', -1)
         end if
      end if
! Define constituent var DIC_ALT_CO2InteriorRestoringValue
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DIC_ALT_CO2InteriorRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DIC_ALT_CO2InteriorRestoringValue', -1)
         end if
      end if
! Define constituent var ALKInteriorRestoringValue
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_ALKInteriorRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_ALKInteriorRestoringValue', -1)
         end if
      end if
! Define constituent var DOCInteriorRestoringValue
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOCInteriorRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOCInteriorRestoringValue', -1)
         end if
      end if
! Define constituent var DONInteriorRestoringValue
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DONInteriorRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DONInteriorRestoringValue', -1)
         end if
      end if
! Define constituent var DOFeInteriorRestoringValue
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOFeInteriorRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOFeInteriorRestoringValue', -1)
         end if
      end if
! Define constituent var DOPInteriorRestoringValue
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOPInteriorRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOPInteriorRestoringValue', -1)
         end if
      end if
! Define constituent var DOPrInteriorRestoringValue
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOPrInteriorRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOPrInteriorRestoringValue', -1)
         end if
      end if
! Define constituent var DONrInteriorRestoringValue
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DONrInteriorRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DONrInteriorRestoringValue', -1)
         end if
      end if
! Define constituent var zooCInteriorRestoringValue
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_zooCInteriorRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_zooCInteriorRestoringValue', -1)
         end if
      end if
! Define constituent var spChlInteriorRestoringValue
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spChlInteriorRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spChlInteriorRestoringValue', -1)
         end if
      end if
! Define constituent var spCInteriorRestoringValue
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spCInteriorRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spCInteriorRestoringValue', -1)
         end if
      end if
! Define constituent var spFeInteriorRestoringValue
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spFeInteriorRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spFeInteriorRestoringValue', -1)
         end if
      end if
! Define constituent var spCaCO3InteriorRestoringValue
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spCaCO3InteriorRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spCaCO3InteriorRestoringValue', -1)
         end if
      end if
! Define constituent var diatChlInteriorRestoringValue
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatChlInteriorRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatChlInteriorRestoringValue', -1)
         end if
      end if
! Define constituent var diatCInteriorRestoringValue
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatCInteriorRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatCInteriorRestoringValue', -1)
         end if
      end if
! Define constituent var diatFeInteriorRestoringValue
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatFeInteriorRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatFeInteriorRestoringValue', -1)
         end if
      end if
! Define constituent var diatSiInteriorRestoringValue
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatSiInteriorRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatSiInteriorRestoringValue', -1)
         end if
      end if
! Define constituent var diazChlInteriorRestoringValue
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazChlInteriorRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazChlInteriorRestoringValue', -1)
         end if
      end if
! Define constituent var diazCInteriorRestoringValue
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazCInteriorRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazCInteriorRestoringValue', -1)
         end if
      end if
! Define constituent var diazFeInteriorRestoringValue
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazFeInteriorRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazFeInteriorRestoringValue', -1)
         end if
      end if
! Define constituent var phaeoChlInteriorRestoringValue
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoChlInteriorRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoChlInteriorRestoringValue', -1)
         end if
      end if
! Define constituent var phaeoCInteriorRestoringValue
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoCInteriorRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoCInteriorRestoringValue', -1)
         end if
      end if
! Define constituent var phaeoFeInteriorRestoringValue
! My packages are ecosysTracersInteriorRestoringPKG
      if (ecosysTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoFeInteriorRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoFeInteriorRestoringValue', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRVGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRVGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysIRVGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_ecosysTracersInteriorRestoringValue', numConstituents)
      end if
! Defining time level 1
      allocate( r3Ptr(1) % constituentNames(numConstituents) )
      r3Ptr(1) % fieldName = 'ecosysTracersInteriorRestoringValue'
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isVarArray = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_PO4InteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'PO4InteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_NO3InteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'NO3InteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_SiO3InteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'SiO3InteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_NH4InteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'NH4InteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_FeInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'FeInteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_O2InteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'O2InteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DICInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'DICInteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DIC_ALT_CO2InteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'DIC_ALT_CO2InteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_ALKInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'ALKInteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOCInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'DOCInteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DONInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'DONInteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOFeInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'DOFeInteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOPInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'DOPInteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOPrInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'DOPrInteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DONrInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'DONrInteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_zooCInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'zooCInteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spChlInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'spChlInteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spCInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'spCInteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spFeInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'spFeInteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spCaCO3InteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'spCaCO3InteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatChlInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'diatChlInteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatCInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'diatCInteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatFeInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'diatFeInteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatSiInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'diatSiInteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazChlInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'diazChlInteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazCInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'diazCInteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazFeInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'diazFeInteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoChlInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'phaeoChlInteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoCInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'phaeoCInteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoFeInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'phaeoFeInteriorRestoringValue'
      end if

! Setup dimensions for       
      r3Ptr(1) % dimNames(1) = 'num_ecosysTracersInteriorRestoringValue'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nCells'

      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(size(r3Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r3Ptr(1) % constituentNames, dim=1)
         allocate(r3Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_PO4InteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Tracer is restored toward this field at a '&
//'rate controlled by PO4InteriorRestoringRate.')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol P m^{3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'PO4InteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_NO3InteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Tracer is restored toward this field at a '&
//'rate controlled by NO3InteriorRestoringRate.')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol N m^{3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'NO3InteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_SiO3InteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Tracer is restored toward this field at a '&
//'rate controlled by SiO3InteriorRestoringRate.')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol Si m^{3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'SiO3InteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_NH4InteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Tracer is restored toward this field at a '&
//'rate controlled by NH4InteriorRestoringRate.')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol N m^{3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'NH4InteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_FeInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Tracer is restored toward this field at a '&
//'rate controlled by FeInteriorRestoringRate.')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol Fe m^{3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'FeInteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_O2InteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Tracer is restored toward this field at a '&
//'rate controlled by O2InteriorRestoringRate.')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol O2 m^{3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'O2InteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DICInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Tracer is restored toward this field at a '&
//'rate controlled by DICInteriorRestoringRate.')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol C m^{3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'DICInteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DIC_ALT_CO2InteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Tracer is restored toward this field at a '&
//'rate controlled by DIC_ALT_CO2InteriorRestoringRate.')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol C m^{3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'DIC_ALT_CO2InteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_ALKInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Tracer is restored toward this field at a '&
//'rate controlled by ALKInteriorRestoringRate.')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'meq m^{3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'ALKInteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOCInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Tracer is restored toward this field at a '&
//'rate controlled by DOCInteriorRestoringRate.')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol C m^{3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'DOCInteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DONInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Tracer is restored toward this field at a '&
//'rate controlled by DONInteriorRestoringRate.')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol N m^{3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'DONInteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOFeInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Tracer is restored toward this field at a '&
//'rate controlled by DOFeInteriorRestoringRate.')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol Fe m^{3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'DOFeInteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOPInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Tracer is restored toward this field at a '&
//'rate controlled by DOPInteriorRestoringRate.')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol P m^{3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'DOPInteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOPrInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Tracer is restored toward this field at a '&
//'rate controlled by DOPrInteriorRestoringRate.')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol P m^{3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'DOPrInteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DONrInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Tracer is restored toward this field at a '&
//'rate controlled by DONrInteriorRestoringRate.')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol N m^{3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'DONrInteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_zooCInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Tracer is restored toward this field at a '&
//'rate controlled by zooCInteriorRestoringRate.')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol C m^{3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'zooCInteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spChlInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Tracer is restored toward this field at a '&
//'rate controlled by spChlInteriorRestoringRate.')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mg Chl m^{3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'spChlInteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spCInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Tracer is restored toward this field at a '&
//'rate controlled by spCInteriorRestoringRate.')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol C m^{3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'spCInteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spFeInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Tracer is restored toward this field at a '&
//'rate controlled by spFeInteriorRestoringRate.')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol Fe m^{3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'spFeInteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spCaCO3InteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Tracer is restored toward this field at a '&
//'rate controlled by spCaCO3InteriorRestoringRate.')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol C m^{3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'spCaCO3InteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatChlInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Tracer is restored toward this field at a '&
//'rate controlled by diatChlInteriorRestoringRate.')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mg Chl m^{3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'diatChlInteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatCInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Tracer is restored toward this field at a '&
//'rate controlled by diatCInteriorRestoringRate.')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol C m^{3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'diatCInteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatFeInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Tracer is restored toward this field at a '&
//'rate controlled by diatFeInteriorRestoringRate.')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol Fe m^{3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'diatFeInteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatSiInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Tracer is restored toward this field at a '&
//'rate controlled by diatSiInteriorRestoringRate.')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol Si m^{3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'diatSiInteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazChlInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Tracer is restored toward this field at a '&
//'rate controlled by diazChlInteriorRestoringRate.')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mg Chl m^{3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'diazChlInteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazCInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Tracer is restored toward this field at a '&
//'rate controlled by diazCInteriorRestoringRate.')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol C m^{3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'diazCInteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazFeInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Tracer is restored toward this field at a '&
//'rate controlled by diazFeInteriorRestoringRate.')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol Fe m^{3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'diazFeInteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoChlInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Tracer is restored toward this field at a '&
//'rate controlled by phaeoChlInteriorRestoringRate.')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mg Chl m^{3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'phaeoChlInteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoCInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Tracer is restored toward this field at a '&
//'rate controlled by phaeoCInteriorRestoringRate.')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol C m^{3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'phaeoCInteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoFeInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Tracer is restored toward this field at a '&
//'rate controlled by phaeoFeInteriorRestoringRate.')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol Fe m^{3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'phaeoFeInteriorRestoringValue'
      end if
      r3Ptr(1) % block => block

      if (ecosysTracersInteriorRestoringPKGActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosysTracersInteriorRestoringValue', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosysTracersInteriorRestoringValue', r3Ptr)

! Define var array DMSTracersInteriorRestoringRate
      allocate(r3Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group DMSIRRGRP
! Define constituent var DMSInteriorRestoringRate
! My Packages are DMSTracersInteriorRestoringPKG
      if (DMSTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DMSInteriorRestoringRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'DMSIRRGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_DMSInteriorRestoringRate', -1)
           end if
      end if
! Define constituent var DMSPInteriorRestoringRate
! My packages are DMSTracersInteriorRestoringPKG
      if (DMSTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DMSPInteriorRestoringRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'DMSIRRGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DMSPInteriorRestoringRate', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'DMSIRRGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'DMSIRRGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'DMSIRRGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_DMSTracersInteriorRestoringRate', numConstituents)
      end if
! Defining time level 1
      allocate( r3Ptr(1) % constituentNames(numConstituents) )
      r3Ptr(1) % fieldName = 'DMSTracersInteriorRestoringRate'
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isVarArray = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DMSInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'DMSInteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DMSPInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'DMSPInteriorRestoringRate'
      end if

! Setup dimensions for       
      r3Ptr(1) % dimNames(1) = 'num_DMSTracersInteriorRestoringRate'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nCells'

      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(size(r3Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r3Ptr(1) % constituentNames, dim=1)
         allocate(r3Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DMSInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which DMS is restored to DMSInteriorRestoringValue')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', '{s}^-1')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'DMSInteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DMSPInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which DMSP is restored to DMSPInteriorRestoringValue')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', '{s}^-1')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'DMSPInteriorRestoringRate'
      end if
      r3Ptr(1) % block => block

      if (DMSTracersInteriorRestoringPKGActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'DMSTracersInteriorRestoringRate', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'DMSTracersInteriorRestoringRate', r3Ptr)

! Define var array DMSTracersInteriorRestoringValue
      allocate(r3Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group DMSIRVGRP
! Define constituent var DMSInteriorRestoringValue
! My Packages are DMSTracersInteriorRestoringPKG
      if (DMSTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DMSInteriorRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'DMSIRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_DMSInteriorRestoringValue', -1)
           end if
      end if
! Define constituent var DMSPInteriorRestoringValue
! My packages are DMSTracersInteriorRestoringPKG
      if (DMSTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DMSPInteriorRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'DMSIRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DMSPInteriorRestoringValue', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'DMSIRVGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'DMSIRVGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'DMSIRVGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_DMSTracersInteriorRestoringValue', numConstituents)
      end if
! Defining time level 1
      allocate( r3Ptr(1) % constituentNames(numConstituents) )
      r3Ptr(1) % fieldName = 'DMSTracersInteriorRestoringValue'
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isVarArray = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DMSInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'DMSInteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DMSPInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'DMSPInteriorRestoringValue'
      end if

! Setup dimensions for       
      r3Ptr(1) % dimNames(1) = 'num_DMSTracersInteriorRestoringValue'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nCells'

      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(size(r3Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r3Ptr(1) % constituentNames, dim=1)
         allocate(r3Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DMSInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Tracer is restored toward this field at a '&
//'rate controlled by DMSInteriorRestoringRate.')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol m^{3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'DMSInteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DMSPInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Tracer is restored toward this field at a '&
//'rate controlled by DMSPInteriorRestoringRate.')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol m^{3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'DMSPInteriorRestoringValue'
      end if
      r3Ptr(1) % block => block

      if (DMSTracersInteriorRestoringPKGActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'DMSTracersInteriorRestoringValue', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'DMSTracersInteriorRestoringValue', r3Ptr)

! Define var array MacroMoleculesTracersInteriorRestoringRate
      allocate(r3Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group MacroMoleculesIRRGRP
! Define constituent var PROTInteriorRestoringRate
! My Packages are MacroMoleculesTracersInteriorRestoringPKG
      if (MacroMoleculesTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_PROTInteriorRestoringRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesIRRGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_PROTInteriorRestoringRate', -1)
           end if
      end if
! Define constituent var POLYInteriorRestoringRate
! My packages are MacroMoleculesTracersInteriorRestoringPKG
      if (MacroMoleculesTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_POLYInteriorRestoringRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesIRRGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_POLYInteriorRestoringRate', -1)
         end if
      end if
! Define constituent var LIPInteriorRestoringRate
! My packages are MacroMoleculesTracersInteriorRestoringPKG
      if (MacroMoleculesTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_LIPInteriorRestoringRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesIRRGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_LIPInteriorRestoringRate', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesIRRGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesIRRGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesIRRGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_MacroMoleculesTracersInteriorRestoringRate', numConstituents)
      end if
! Defining time level 1
      allocate( r3Ptr(1) % constituentNames(numConstituents) )
      r3Ptr(1) % fieldName = 'MacroMoleculesTracersInteriorRestoringRate'
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isVarArray = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_PROTInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'PROTInteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_POLYInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'POLYInteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_LIPInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'LIPInteriorRestoringRate'
      end if

! Setup dimensions for       
      r3Ptr(1) % dimNames(1) = 'num_MacroMoleculesTracersInteriorRestoringRate'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nCells'

      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(size(r3Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r3Ptr(1) % constituentNames, dim=1)
         allocate(r3Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_PROTInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which PROT is restored to PROTInteriorRestoringValue')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', '{s}^-1')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'PROTInteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_POLYInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which POLY is restored to POLYInteriorRestoringValue')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', '{s}^-1')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'POLYInteriorRestoringRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_LIPInteriorRestoringRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the rate at '&
//'which LIP is restored to LIPInteriorRestoringValue')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', '{s}^-1')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'LIPInteriorRestoringRate'
      end if
      r3Ptr(1) % block => block

      if (MacroMoleculesTracersInteriorRestoringPKGActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'MacroMoleculesTracersInteriorRestoringRate', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'MacroMoleculesTracersInteriorRestoringRate', r3Ptr)

! Define var array MacroMoleculesTracersInteriorRestoringValue
      allocate(r3Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group MacroMoleculesIRVGRP
! Define constituent var PROTInteriorRestoringValue
! My Packages are MacroMoleculesTracersInteriorRestoringPKG
      if (MacroMoleculesTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_PROTInteriorRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesIRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_PROTInteriorRestoringValue', -1)
           end if
      end if
! Define constituent var POLYInteriorRestoringValue
! My packages are MacroMoleculesTracersInteriorRestoringPKG
      if (MacroMoleculesTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_POLYInteriorRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesIRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_POLYInteriorRestoringValue', -1)
         end if
      end if
! Define constituent var LIPInteriorRestoringValue
! My packages are MacroMoleculesTracersInteriorRestoringPKG
      if (MacroMoleculesTracersInteriorRestoringPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_LIPInteriorRestoringValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesIRVGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_LIPInteriorRestoringValue', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesIRVGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesIRVGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesIRVGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_MacroMoleculesTracersInteriorRestoringValue', numConstituents)
      end if
! Defining time level 1
      allocate( r3Ptr(1) % constituentNames(numConstituents) )
      r3Ptr(1) % fieldName = 'MacroMoleculesTracersInteriorRestoringValue'
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isVarArray = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_PROTInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'PROTInteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_POLYInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'POLYInteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_LIPInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'LIPInteriorRestoringValue'
      end if

! Setup dimensions for       
      r3Ptr(1) % dimNames(1) = 'num_MacroMoleculesTracersInteriorRestoringValue'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nCells'

      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(size(r3Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r3Ptr(1) % constituentNames, dim=1)
         allocate(r3Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_PROTInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Tracer is restored toward this field at a '&
//'rate controlled by PROTInteriorRestoringRate.')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol m^{3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'PROTInteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_POLYInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Tracer is restored toward this field at a '&
//'rate controlled by POLYInteriorRestoringRate.')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol m^{3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'POLYInteriorRestoringValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_LIPInteriorRestoringValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Tracer is restored toward this field at a '&
//'rate controlled by LIPInteriorRestoringRate.')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'mmol m^{3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'LIPInteriorRestoringValue'
      end if
      r3Ptr(1) % block => block

      if (MacroMoleculesTracersInteriorRestoringPKGActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'MacroMoleculesTracersInteriorRestoringValue', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'MacroMoleculesTracersInteriorRestoringValue', r3Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_forcing_subpool_tracersInteriorRestoringFields


   subroutine ocn_generate_forcing_subpool_tracersExponentialDecayFields(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'tracersExponentialDecayFields', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'tracersExponentialDecayFields', newSubPool)

! Define var array activeTracersExponentialDecayRate
      allocate(r1Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group activeGRP
! Define constituent var temperatureExponentialDecayRate
! My Packages are activeTracersExponentialDecayPKG
      if (activeTracersExponentialDecayPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureExponentialDecayRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_temperatureExponentialDecayRate', -1)
           end if
      end if
! Define constituent var salinityExponentialDecayRate
! My packages are activeTracersExponentialDecayPKG
      if (activeTracersExponentialDecayPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityExponentialDecayRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityExponentialDecayRate', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'activeGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_activeTracersExponentialDecayRate', numConstituents)
      end if
! Defining time level 1
      allocate( r1Ptr(1) % constituentNames(numConstituents) )
      r1Ptr(1) % fieldName = 'activeTracersExponentialDecayRate'
      r1Ptr(1) % isDecomposed = .false.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isVarArray = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'temperatureExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'salinityExponentialDecayRate'
      end if

! Setup dimensions for       
      r1Ptr(1) % dimNames(1) = 'num_activeTracersExponentialDecayRate'

      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(size(r1Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r1Ptr(1) % constituentNames, dim=1)
         allocate(r1Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the '&
//'exponential decay of temperature')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'temperatureExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the '&
//'exponential decay of salinity')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'salinityExponentialDecayRate'
      end if
      r1Ptr(1) % block => block

      if (activeTracersExponentialDecayPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'activeTracersExponentialDecayRate', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'activeTracersExponentialDecayRate', r1Ptr)

! Define var array debugTracersExponentialDecayRate
      allocate(r1Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group debugGRP
! Define constituent var tracer1ExponentialDecayRate
! My Packages are debugTracersExponentialDecayPKG
      if (debugTracersExponentialDecayPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_tracer1ExponentialDecayRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'debugGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_tracer1ExponentialDecayRate', -1)
           end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'debugGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'debugGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'debugGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_debugTracersExponentialDecayRate', numConstituents)
      end if
! Defining time level 1
      allocate( r1Ptr(1) % constituentNames(numConstituents) )
      r1Ptr(1) % fieldName = 'debugTracersExponentialDecayRate'
      r1Ptr(1) % isDecomposed = .false.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isVarArray = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_tracer1ExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'tracer1ExponentialDecayRate'
      end if

! Setup dimensions for       
      r1Ptr(1) % dimNames(1) = 'num_debugTracersExponentialDecayRate'

      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(size(r1Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r1Ptr(1) % constituentNames, dim=1)
         allocate(r1Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_tracer1ExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the '&
//'exponential decay of tracer1')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'tracer1ExponentialDecayRate'
      end if
      r1Ptr(1) % block => block

      if (debugTracersExponentialDecayPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'debugTracersExponentialDecayRate', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'debugTracersExponentialDecayRate', r1Ptr)

! Define var array ecosysTracersExponentialDecayRate
      allocate(r1Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group ecosysGRP
! Define constituent var PO4ExponentialDecayRate
! My Packages are ecosysTracersExponentialDecayPKG
      if (ecosysTracersExponentialDecayPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_PO4ExponentialDecayRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_PO4ExponentialDecayRate', -1)
           end if
      end if
! Define constituent var NO3ExponentialDecayRate
! My packages are ecosysTracersExponentialDecayPKG
      if (ecosysTracersExponentialDecayPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_NO3ExponentialDecayRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_NO3ExponentialDecayRate', -1)
         end if
      end if
! Define constituent var SiO3ExponentialDecayRate
! My packages are ecosysTracersExponentialDecayPKG
      if (ecosysTracersExponentialDecayPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_SiO3ExponentialDecayRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_SiO3ExponentialDecayRate', -1)
         end if
      end if
! Define constituent var NH4ExponentialDecayRate
! My packages are ecosysTracersExponentialDecayPKG
      if (ecosysTracersExponentialDecayPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_NH4ExponentialDecayRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_NH4ExponentialDecayRate', -1)
         end if
      end if
! Define constituent var FeExponentialDecayRate
! My packages are ecosysTracersExponentialDecayPKG
      if (ecosysTracersExponentialDecayPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_FeExponentialDecayRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_FeExponentialDecayRate', -1)
         end if
      end if
! Define constituent var O2ExponentialDecayRate
! My packages are ecosysTracersExponentialDecayPKG
      if (ecosysTracersExponentialDecayPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_O2ExponentialDecayRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_O2ExponentialDecayRate', -1)
         end if
      end if
! Define constituent var DICExponentialDecayRate
! My packages are ecosysTracersExponentialDecayPKG
      if (ecosysTracersExponentialDecayPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DICExponentialDecayRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DICExponentialDecayRate', -1)
         end if
      end if
! Define constituent var DIC_ALT_CO2ExponentialDecayRate
! My packages are ecosysTracersExponentialDecayPKG
      if (ecosysTracersExponentialDecayPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DIC_ALT_CO2ExponentialDecayRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DIC_ALT_CO2ExponentialDecayRate', -1)
         end if
      end if
! Define constituent var ALKExponentialDecayRate
! My packages are ecosysTracersExponentialDecayPKG
      if (ecosysTracersExponentialDecayPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_ALKExponentialDecayRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_ALKExponentialDecayRate', -1)
         end if
      end if
! Define constituent var DOCExponentialDecayRate
! My packages are ecosysTracersExponentialDecayPKG
      if (ecosysTracersExponentialDecayPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOCExponentialDecayRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOCExponentialDecayRate', -1)
         end if
      end if
! Define constituent var DONExponentialDecayRate
! My packages are ecosysTracersExponentialDecayPKG
      if (ecosysTracersExponentialDecayPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DONExponentialDecayRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DONExponentialDecayRate', -1)
         end if
      end if
! Define constituent var DOFeExponentialDecayRate
! My packages are ecosysTracersExponentialDecayPKG
      if (ecosysTracersExponentialDecayPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOFeExponentialDecayRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOFeExponentialDecayRate', -1)
         end if
      end if
! Define constituent var DOPExponentialDecayRate
! My packages are ecosysTracersExponentialDecayPKG
      if (ecosysTracersExponentialDecayPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOPExponentialDecayRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOPExponentialDecayRate', -1)
         end if
      end if
! Define constituent var DOPrExponentialDecayRate
! My packages are ecosysTracersExponentialDecayPKG
      if (ecosysTracersExponentialDecayPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOPrExponentialDecayRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOPrExponentialDecayRate', -1)
         end if
      end if
! Define constituent var DONrExponentialDecayRate
! My packages are ecosysTracersExponentialDecayPKG
      if (ecosysTracersExponentialDecayPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DONrExponentialDecayRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DONrExponentialDecayRate', -1)
         end if
      end if
! Define constituent var zooCExponentialDecayRate
! My packages are ecosysTracersExponentialDecayPKG
      if (ecosysTracersExponentialDecayPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_zooCExponentialDecayRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_zooCExponentialDecayRate', -1)
         end if
      end if
! Define constituent var spChlExponentialDecayRate
! My packages are ecosysTracersExponentialDecayPKG
      if (ecosysTracersExponentialDecayPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spChlExponentialDecayRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spChlExponentialDecayRate', -1)
         end if
      end if
! Define constituent var spCExponentialDecayRate
! My packages are ecosysTracersExponentialDecayPKG
      if (ecosysTracersExponentialDecayPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spCExponentialDecayRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spCExponentialDecayRate', -1)
         end if
      end if
! Define constituent var spFeExponentialDecayRate
! My packages are ecosysTracersExponentialDecayPKG
      if (ecosysTracersExponentialDecayPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spFeExponentialDecayRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spFeExponentialDecayRate', -1)
         end if
      end if
! Define constituent var spCaCO3ExponentialDecayRate
! My packages are ecosysTracersExponentialDecayPKG
      if (ecosysTracersExponentialDecayPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spCaCO3ExponentialDecayRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spCaCO3ExponentialDecayRate', -1)
         end if
      end if
! Define constituent var diatChlExponentialDecayRate
! My packages are ecosysTracersExponentialDecayPKG
      if (ecosysTracersExponentialDecayPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatChlExponentialDecayRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatChlExponentialDecayRate', -1)
         end if
      end if
! Define constituent var diatCExponentialDecayRate
! My packages are ecosysTracersExponentialDecayPKG
      if (ecosysTracersExponentialDecayPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatCExponentialDecayRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatCExponentialDecayRate', -1)
         end if
      end if
! Define constituent var diatFeExponentialDecayRate
! My packages are ecosysTracersExponentialDecayPKG
      if (ecosysTracersExponentialDecayPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatFeExponentialDecayRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatFeExponentialDecayRate', -1)
         end if
      end if
! Define constituent var diatSiExponentialDecayRate
! My packages are ecosysTracersExponentialDecayPKG
      if (ecosysTracersExponentialDecayPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatSiExponentialDecayRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatSiExponentialDecayRate', -1)
         end if
      end if
! Define constituent var diazChlExponentialDecayRate
! My packages are ecosysTracersExponentialDecayPKG
      if (ecosysTracersExponentialDecayPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazChlExponentialDecayRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazChlExponentialDecayRate', -1)
         end if
      end if
! Define constituent var diazCExponentialDecayRate
! My packages are ecosysTracersExponentialDecayPKG
      if (ecosysTracersExponentialDecayPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazCExponentialDecayRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazCExponentialDecayRate', -1)
         end if
      end if
! Define constituent var diazFeExponentialDecayRate
! My packages are ecosysTracersExponentialDecayPKG
      if (ecosysTracersExponentialDecayPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazFeExponentialDecayRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazFeExponentialDecayRate', -1)
         end if
      end if
! Define constituent var phaeoChlExponentialDecayRate
! My packages are ecosysTracersExponentialDecayPKG
      if (ecosysTracersExponentialDecayPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoChlExponentialDecayRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoChlExponentialDecayRate', -1)
         end if
      end if
! Define constituent var phaeoCExponentialDecayRate
! My packages are ecosysTracersExponentialDecayPKG
      if (ecosysTracersExponentialDecayPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoCExponentialDecayRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoCExponentialDecayRate', -1)
         end if
      end if
! Define constituent var phaeoFeExponentialDecayRate
! My packages are ecosysTracersExponentialDecayPKG
      if (ecosysTracersExponentialDecayPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoFeExponentialDecayRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoFeExponentialDecayRate', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_ecosysTracersExponentialDecayRate', numConstituents)
      end if
! Defining time level 1
      allocate( r1Ptr(1) % constituentNames(numConstituents) )
      r1Ptr(1) % fieldName = 'ecosysTracersExponentialDecayRate'
      r1Ptr(1) % isDecomposed = .false.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isVarArray = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_PO4ExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'PO4ExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_NO3ExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'NO3ExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_SiO3ExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'SiO3ExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_NH4ExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'NH4ExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_FeExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'FeExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_O2ExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'O2ExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DICExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'DICExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DIC_ALT_CO2ExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'DIC_ALT_CO2ExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_ALKExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'ALKExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOCExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'DOCExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DONExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'DONExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOFeExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'DOFeExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOPExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'DOPExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOPrExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'DOPrExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DONrExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'DONrExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_zooCExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'zooCExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spChlExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'spChlExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spCExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'spCExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spFeExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'spFeExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spCaCO3ExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'spCaCO3ExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatChlExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'diatChlExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatCExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'diatCExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatFeExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'diatFeExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatSiExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'diatSiExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazChlExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'diazChlExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazCExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'diazCExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazFeExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'diazFeExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoChlExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'phaeoChlExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoCExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'phaeoCExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoFeExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'phaeoFeExponentialDecayRate'
      end if

! Setup dimensions for       
      r1Ptr(1) % dimNames(1) = 'num_ecosysTracersExponentialDecayRate'

      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(size(r1Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r1Ptr(1) % constituentNames, dim=1)
         allocate(r1Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_PO4ExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the '&
//'exponential decay of PO4')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'PO4ExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_NO3ExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the '&
//'exponential decay of NO3')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'NO3ExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_SiO3ExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the '&
//'exponential decay of SiO3')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'SiO3ExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_NH4ExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the '&
//'exponential decay of NH4')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'NH4ExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_FeExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the '&
//'exponential decay of Fe')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'FeExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_O2ExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the '&
//'exponential decay of O2')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'O2ExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DICExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the '&
//'exponential decay of DIC')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'DICExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DIC_ALT_CO2ExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the '&
//'exponential decay of DIC_ALT_CO2')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'DIC_ALT_CO2ExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_ALKExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the '&
//'exponential decay of ALK')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'ALKExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOCExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the '&
//'exponential decay of DOC')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'DOCExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DONExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the '&
//'exponential decay of DON')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'DONExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOFeExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the '&
//'exponential decay of DOFe')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'DOFeExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOPExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the '&
//'exponential decay of DOP')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'DOPExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOPrExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the '&
//'exponential decay of DOPr')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'DOPrExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DONrExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the '&
//'exponential decay of DONr')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'DONrExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_zooCExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the '&
//'exponential decay of zooC')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'zooCExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spChlExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the '&
//'exponential decay of spChl')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'spChlExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spCExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the '&
//'exponential decay of spC')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'spCExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spFeExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the '&
//'exponential decay of spFe')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'spFeExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spCaCO3ExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the '&
//'exponential decay of spCaCO3')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'spCaCO3ExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatChlExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the '&
//'exponential decay of diatChl')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'diatChlExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatCExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the '&
//'exponential decay of diatC')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'diatCExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatFeExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the '&
//'exponential decay of diatFe')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'diatFeExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatSiExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the '&
//'exponential decay of diatSi')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'diatSiExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazChlExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the '&
//'exponential decay of diazChl')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'diazChlExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazCExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the '&
//'exponential decay of diazC')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'diazCExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazFeExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the '&
//'exponential decay of diazFe')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'diazFeExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoChlExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the '&
//'exponential decay of phaeoChl')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'phaeoChlExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoCExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the '&
//'exponential decay of phaeoC')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'phaeoCExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoFeExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the '&
//'exponential decay of phaeoFe')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'phaeoFeExponentialDecayRate'
      end if
      r1Ptr(1) % block => block

      if (ecosysTracersExponentialDecayPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosysTracersExponentialDecayRate', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosysTracersExponentialDecayRate', r1Ptr)

! Define var array DMSTracersExponentialDecayRate
      allocate(r1Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group DMSGRP
! Define constituent var DMSExponentialDecayRate
! My Packages are DMSTracersExponentialDecayPKG
      if (DMSTracersExponentialDecayPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DMSExponentialDecayRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'DMSGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_DMSExponentialDecayRate', -1)
           end if
      end if
! Define constituent var DMSPExponentialDecayRate
! My packages are DMSTracersExponentialDecayPKG
      if (DMSTracersExponentialDecayPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DMSPExponentialDecayRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'DMSGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DMSPExponentialDecayRate', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'DMSGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'DMSGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'DMSGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_DMSTracersExponentialDecayRate', numConstituents)
      end if
! Defining time level 1
      allocate( r1Ptr(1) % constituentNames(numConstituents) )
      r1Ptr(1) % fieldName = 'DMSTracersExponentialDecayRate'
      r1Ptr(1) % isDecomposed = .false.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isVarArray = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DMSExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'DMSExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DMSPExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'DMSPExponentialDecayRate'
      end if

! Setup dimensions for       
      r1Ptr(1) % dimNames(1) = 'num_DMSTracersExponentialDecayRate'

      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(size(r1Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r1Ptr(1) % constituentNames, dim=1)
         allocate(r1Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DMSExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the '&
//'exponential decay of DMS')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'DMSExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DMSPExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the '&
//'exponential decay of DMSP')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'DMSPExponentialDecayRate'
      end if
      r1Ptr(1) % block => block

      if (DMSTracersExponentialDecayPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'DMSTracersExponentialDecayRate', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'DMSTracersExponentialDecayRate', r1Ptr)

! Define var array MacroMoleculesTracersExponentialDecayRate
      allocate(r1Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group MacroMoleculesGRP
! Define constituent var PROTExponentialDecayRate
! My Packages are MacroMoleculesTracersExponentialDecayPKG
      if (MacroMoleculesTracersExponentialDecayPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_PROTExponentialDecayRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_PROTExponentialDecayRate', -1)
           end if
      end if
! Define constituent var POLYExponentialDecayRate
! My packages are MacroMoleculesTracersExponentialDecayPKG
      if (MacroMoleculesTracersExponentialDecayPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_POLYExponentialDecayRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_POLYExponentialDecayRate', -1)
         end if
      end if
! Define constituent var LIPExponentialDecayRate
! My packages are MacroMoleculesTracersExponentialDecayPKG
      if (MacroMoleculesTracersExponentialDecayPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_LIPExponentialDecayRate', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_LIPExponentialDecayRate', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_MacroMoleculesTracersExponentialDecayRate', numConstituents)
      end if
! Defining time level 1
      allocate( r1Ptr(1) % constituentNames(numConstituents) )
      r1Ptr(1) % fieldName = 'MacroMoleculesTracersExponentialDecayRate'
      r1Ptr(1) % isDecomposed = .false.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isVarArray = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_PROTExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'PROTExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_POLYExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'POLYExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_LIPExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'LIPExponentialDecayRate'
      end if

! Setup dimensions for       
      r1Ptr(1) % dimNames(1) = 'num_MacroMoleculesTracersExponentialDecayRate'

      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(size(r1Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r1Ptr(1) % constituentNames, dim=1)
         allocate(r1Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_PROTExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the '&
//'exponential decay of PROT')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'PROTExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_POLYExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the '&
//'exponential decay of POLY')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'POLYExponentialDecayRate'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_LIPExponentialDecayRate', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'A non-negative field controlling the '&
//'exponential decay of LIP')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'LIPExponentialDecayRate'
      end if
      r1Ptr(1) % block => block

      if (MacroMoleculesTracersExponentialDecayPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'MacroMoleculesTracersExponentialDecayRate', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'MacroMoleculesTracersExponentialDecayRate', r1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_forcing_subpool_tracersExponentialDecayFields


   subroutine ocn_generate_forcing_subpool_tracersIdealAgeFields(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'tracersIdealAgeFields', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'tracersIdealAgeFields', newSubPool)

! Define var array activeTracersIdealAgeMask
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group activeGRP
! Define constituent var temperatureIdealAgeMask
! My Packages are activeTracersIdealAgePKG
      if (activeTracersIdealAgePKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureIdealAgeMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_temperatureIdealAgeMask', -1)
           end if
      end if
! Define constituent var salinityIdealAgeMask
! My packages are activeTracersIdealAgePKG
      if (activeTracersIdealAgePKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityIdealAgeMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityIdealAgeMask', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'activeGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_activeTracersIdealAgeMask', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'activeTracersIdealAgeMask'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'temperatureIdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'salinityIdealAgeMask'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_activeTracersIdealAgeMask'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, temperature is reset to '&
//'temperature * temperatureIdealAgeMask, valid values of temperatureIdealAgeMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'temperatureIdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, salinity is reset to salinity * '&
//'salinityIdealAgeMask, valid values of salinityIdealAgeMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'salinityIdealAgeMask'
      end if
      r2Ptr(1) % block => block

      if (activeTracersIdealAgePKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'activeTracersIdealAgeMask', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'activeTracersIdealAgeMask', r2Ptr)

! Define var array debugTracersIdealAgeMask
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group debugGRP
! Define constituent var tracer1IdealAgeMask
! My Packages are debugTracersIdealAgePKG
      if (debugTracersIdealAgePKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_tracer1IdealAgeMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'debugGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_tracer1IdealAgeMask', -1)
           end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'debugGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'debugGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'debugGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_debugTracersIdealAgeMask', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'debugTracersIdealAgeMask'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_tracer1IdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'tracer1IdealAgeMask'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_debugTracersIdealAgeMask'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_tracer1IdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, tracer1 is reset to tracer1 * '&
//'tracer1IdealAgeMask, valid values of tracer1IdealAgeMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'tracer1IdealAgeMask'
      end if
      r2Ptr(1) % block => block

      if (debugTracersIdealAgePKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'debugTracersIdealAgeMask', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'debugTracersIdealAgeMask', r2Ptr)

! Define var array ecosysTracersIdealAgeMask
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group ecosysGRP
! Define constituent var PO4IdealAgeMask
! My Packages are ecosysTracersIdealAgePKG
      if (ecosysTracersIdealAgePKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_PO4IdealAgeMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_PO4IdealAgeMask', -1)
           end if
      end if
! Define constituent var NO3IdealAgeMask
! My packages are ecosysTracersIdealAgePKG
      if (ecosysTracersIdealAgePKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_NO3IdealAgeMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_NO3IdealAgeMask', -1)
         end if
      end if
! Define constituent var SiO3IdealAgeMask
! My packages are ecosysTracersIdealAgePKG
      if (ecosysTracersIdealAgePKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_SiO3IdealAgeMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_SiO3IdealAgeMask', -1)
         end if
      end if
! Define constituent var NH4IdealAgeMask
! My packages are ecosysTracersIdealAgePKG
      if (ecosysTracersIdealAgePKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_NH4IdealAgeMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_NH4IdealAgeMask', -1)
         end if
      end if
! Define constituent var FeIdealAgeMask
! My packages are ecosysTracersIdealAgePKG
      if (ecosysTracersIdealAgePKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_FeIdealAgeMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_FeIdealAgeMask', -1)
         end if
      end if
! Define constituent var O2IdealAgeMask
! My packages are ecosysTracersIdealAgePKG
      if (ecosysTracersIdealAgePKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_O2IdealAgeMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_O2IdealAgeMask', -1)
         end if
      end if
! Define constituent var DICIdealAgeMask
! My packages are ecosysTracersIdealAgePKG
      if (ecosysTracersIdealAgePKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DICIdealAgeMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DICIdealAgeMask', -1)
         end if
      end if
! Define constituent var DIC_ALT_CO2IdealAgeMask
! My packages are ecosysTracersIdealAgePKG
      if (ecosysTracersIdealAgePKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DIC_ALT_CO2IdealAgeMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DIC_ALT_CO2IdealAgeMask', -1)
         end if
      end if
! Define constituent var ALKIdealAgeMask
! My packages are ecosysTracersIdealAgePKG
      if (ecosysTracersIdealAgePKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_ALKIdealAgeMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_ALKIdealAgeMask', -1)
         end if
      end if
! Define constituent var DOCIdealAgeMask
! My packages are ecosysTracersIdealAgePKG
      if (ecosysTracersIdealAgePKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOCIdealAgeMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOCIdealAgeMask', -1)
         end if
      end if
! Define constituent var DONIdealAgeMask
! My packages are ecosysTracersIdealAgePKG
      if (ecosysTracersIdealAgePKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DONIdealAgeMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DONIdealAgeMask', -1)
         end if
      end if
! Define constituent var DOFeIdealAgeMask
! My packages are ecosysTracersIdealAgePKG
      if (ecosysTracersIdealAgePKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOFeIdealAgeMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOFeIdealAgeMask', -1)
         end if
      end if
! Define constituent var DOPIdealAgeMask
! My packages are ecosysTracersIdealAgePKG
      if (ecosysTracersIdealAgePKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOPIdealAgeMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOPIdealAgeMask', -1)
         end if
      end if
! Define constituent var DOPrIdealAgeMask
! My packages are ecosysTracersIdealAgePKG
      if (ecosysTracersIdealAgePKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOPrIdealAgeMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOPrIdealAgeMask', -1)
         end if
      end if
! Define constituent var DONrIdealAgeMask
! My packages are ecosysTracersIdealAgePKG
      if (ecosysTracersIdealAgePKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DONrIdealAgeMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DONrIdealAgeMask', -1)
         end if
      end if
! Define constituent var zooCIdealAgeMask
! My packages are ecosysTracersIdealAgePKG
      if (ecosysTracersIdealAgePKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_zooCIdealAgeMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_zooCIdealAgeMask', -1)
         end if
      end if
! Define constituent var spChlIdealAgeMask
! My packages are ecosysTracersIdealAgePKG
      if (ecosysTracersIdealAgePKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spChlIdealAgeMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spChlIdealAgeMask', -1)
         end if
      end if
! Define constituent var spCIdealAgeMask
! My packages are ecosysTracersIdealAgePKG
      if (ecosysTracersIdealAgePKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spCIdealAgeMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spCIdealAgeMask', -1)
         end if
      end if
! Define constituent var spFeIdealAgeMask
! My packages are ecosysTracersIdealAgePKG
      if (ecosysTracersIdealAgePKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spFeIdealAgeMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spFeIdealAgeMask', -1)
         end if
      end if
! Define constituent var spCaCO3IdealAgeMask
! My packages are ecosysTracersIdealAgePKG
      if (ecosysTracersIdealAgePKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spCaCO3IdealAgeMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spCaCO3IdealAgeMask', -1)
         end if
      end if
! Define constituent var diatChlIdealAgeMask
! My packages are ecosysTracersIdealAgePKG
      if (ecosysTracersIdealAgePKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatChlIdealAgeMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatChlIdealAgeMask', -1)
         end if
      end if
! Define constituent var diatCIdealAgeMask
! My packages are ecosysTracersIdealAgePKG
      if (ecosysTracersIdealAgePKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatCIdealAgeMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatCIdealAgeMask', -1)
         end if
      end if
! Define constituent var diatFeIdealAgeMask
! My packages are ecosysTracersIdealAgePKG
      if (ecosysTracersIdealAgePKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatFeIdealAgeMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatFeIdealAgeMask', -1)
         end if
      end if
! Define constituent var diatSiIdealAgeMask
! My packages are ecosysTracersIdealAgePKG
      if (ecosysTracersIdealAgePKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatSiIdealAgeMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatSiIdealAgeMask', -1)
         end if
      end if
! Define constituent var diazChlIdealAgeMask
! My packages are ecosysTracersIdealAgePKG
      if (ecosysTracersIdealAgePKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazChlIdealAgeMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazChlIdealAgeMask', -1)
         end if
      end if
! Define constituent var diazCIdealAgeMask
! My packages are ecosysTracersIdealAgePKG
      if (ecosysTracersIdealAgePKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazCIdealAgeMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazCIdealAgeMask', -1)
         end if
      end if
! Define constituent var diazFeIdealAgeMask
! My packages are ecosysTracersIdealAgePKG
      if (ecosysTracersIdealAgePKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazFeIdealAgeMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazFeIdealAgeMask', -1)
         end if
      end if
! Define constituent var phaeoChlIdealAgeMask
! My packages are ecosysTracersIdealAgePKG
      if (ecosysTracersIdealAgePKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoChlIdealAgeMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoChlIdealAgeMask', -1)
         end if
      end if
! Define constituent var phaeoCIdealAgeMask
! My packages are ecosysTracersIdealAgePKG
      if (ecosysTracersIdealAgePKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoCIdealAgeMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoCIdealAgeMask', -1)
         end if
      end if
! Define constituent var phaeoFeIdealAgeMask
! My packages are ecosysTracersIdealAgePKG
      if (ecosysTracersIdealAgePKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoFeIdealAgeMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoFeIdealAgeMask', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_ecosysTracersIdealAgeMask', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'ecosysTracersIdealAgeMask'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_PO4IdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'PO4IdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_NO3IdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'NO3IdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_SiO3IdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'SiO3IdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_NH4IdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'NH4IdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_FeIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'FeIdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_O2IdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'O2IdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DICIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DICIdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DIC_ALT_CO2IdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DIC_ALT_CO2IdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_ALKIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'ALKIdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOCIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DOCIdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DONIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DONIdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOFeIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DOFeIdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOPIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DOPIdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOPrIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DOPrIdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DONrIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DONrIdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_zooCIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'zooCIdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spChlIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'spChlIdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spCIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'spCIdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spFeIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'spFeIdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spCaCO3IdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'spCaCO3IdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatChlIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'diatChlIdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatCIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'diatCIdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatFeIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'diatFeIdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatSiIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'diatSiIdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazChlIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'diazChlIdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazCIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'diazCIdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazFeIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'diazFeIdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoChlIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'phaeoChlIdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoCIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'phaeoCIdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoFeIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'phaeoFeIdealAgeMask'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_ecosysTracersIdealAgeMask'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_PO4IdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, PO4 is reset to PO4 * '&
//'PO4IdealAgeMask, valid values of PO4IdealAgeMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'PO4IdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_NO3IdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, NO3 is reset to NO3 * '&
//'NO3IdealAgeMask, valid values of NO3IdealAgeMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'NO3IdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_SiO3IdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, SiO3 is reset to SiO3 * '&
//'SiO3IdealAgeMask, valid values of SiO3IdealAgeMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'SiO3IdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_NH4IdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, NH4 is reset to NH4 * '&
//'NH4IdealAgeMask, valid values of NH4IdealAgeMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'NH4IdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_FeIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, Fe is reset to Fe * '&
//'FeIdealAgeMask, valid values of FeIdealAgeMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'FeIdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_O2IdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, O2 is reset to O2 * '&
//'O2IdealAgeMask, valid values of O2IdealAgeMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'O2IdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DICIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, DIC is reset to DIC * '&
//'DICIdealAgeMask, valid values of DICIdealAgeMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DICIdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DIC_ALT_CO2IdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, DIC_ALT_CO2 is reset to '&
//'DIC_ALT_CO2 * DIC_ALT_CO2IdealAgeMask, valid values of DIC_ALT_CO2IdealAgeMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DIC_ALT_CO2IdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_ALKIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, ALK is reset to ALK * '&
//'ALKIdealAgeMask, valid values of ALKIdealAgeMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'ALKIdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOCIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, DOC is reset to DOC * '&
//'DOCIdealAgeMask, valid values of DOCIdealAgeMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DOCIdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DONIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, DON is reset to DON * '&
//'DONIdealAgeMask, valid values of DONIdealAgeMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DONIdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOFeIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, DOFe is reset to DOFe * '&
//'DOFeIdealAgeMask, valid values of DOFeIdealAgeMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DOFeIdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOPIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, DOP is reset to DOP * '&
//'DOPIdealAgeMask, valid values of DOPIdealAgeMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DOPIdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOPrIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, DOPr is reset to DOPr * '&
//'DOPrIdealAgeMask, valid values of DOPrIdealAgeMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DOPrIdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DONrIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, DONr is reset to DONr * '&
//'DONrIdealAgeMask, valid values of DONrIdealAgeMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DONrIdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_zooCIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, zooC is reset to zooC * '&
//'zooCIdealAgeMask, valid values of zooCIdealAgeMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'zooCIdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spChlIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, spChl is reset to spChl * '&
//'spChlIdealAgeMask, valid values of spChlIdealAgeMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'spChlIdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spCIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, spC is reset to spC * '&
//'spCIdealAgeMask, valid values of spCIdealAgeMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'spCIdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spFeIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, spFe is reset to spFe * '&
//'spFeIdealAgeMask, valid values of spFeIdealAgeMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'spFeIdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spCaCO3IdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, spCaCO3 is reset to spCaCO3 * '&
//'spCaCO3IdealAgeMask, valid values of spCaCO3IdealAgeMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'spCaCO3IdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatChlIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, diatChl is reset to diatChl * '&
//'diatChlIdealAgeMask, valid values of diatChlIdealAgeMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'diatChlIdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatCIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, diatC is reset to diatC * '&
//'diatCIdealAgeMask, valid values of diatCIdealAgeMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'diatCIdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatFeIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, diatFe is reset to diatFe * '&
//'diatFeIdealAgeMask, valid values of diatFeIdealAgeMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'diatFeIdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatSiIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, diatSi is reset to diatSi * '&
//'diatSiIdealAgeMask, valid values of diatSiIdealAgeMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'diatSiIdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazChlIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, diazChl is reset to diazChl * '&
//'diazChlIdealAgeMask, valid values of diazChlIdealAgeMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'diazChlIdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazCIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, diazC is reset to diazC * '&
//'diazCIdealAgeMask, valid values of diazCIdealAgeMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'diazCIdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazFeIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, diazFe is reset to diazFe * '&
//'diazFeIdealAgeMask, valid values of diazFeIdealAgeMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'diazFeIdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoChlIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, phaeoChl is reset to phaeoChl * '&
//'phaeoChlIdealAgeMask, valid values of phaeoChlIdealAgeMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'phaeoChlIdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoCIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, phaeoC is reset to phaeoC * '&
//'phaeoCIdealAgeMask, valid values of phaeoCIdealAgeMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'phaeoCIdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoFeIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, phaeoFe is reset to phaeoFe * '&
//'phaeoFeIdealAgeMask, valid values of phaeoFeIdealAgeMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'phaeoFeIdealAgeMask'
      end if
      r2Ptr(1) % block => block

      if (ecosysTracersIdealAgePKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosysTracersIdealAgeMask', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosysTracersIdealAgeMask', r2Ptr)

! Define var array DMSTracersIdealAgeMask
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group DMSGRP
! Define constituent var DMSIdealAgeMask
! My Packages are DMSTracersIdealAgePKG
      if (DMSTracersIdealAgePKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DMSIdealAgeMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'DMSGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_DMSIdealAgeMask', -1)
           end if
      end if
! Define constituent var DMSPIdealAgeMask
! My packages are DMSTracersIdealAgePKG
      if (DMSTracersIdealAgePKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DMSPIdealAgeMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'DMSGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DMSPIdealAgeMask', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'DMSGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'DMSGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'DMSGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_DMSTracersIdealAgeMask', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'DMSTracersIdealAgeMask'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DMSIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DMSIdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DMSPIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DMSPIdealAgeMask'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_DMSTracersIdealAgeMask'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DMSIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, DMS is reset to DMS * '&
//'DMSIdealAgeMask, valid values of DMSIdealAgeMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DMSIdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DMSPIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, DMSP is reset to DMSP * '&
//'DMSPIdealAgeMask, valid values of DMSPIdealAgeMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DMSPIdealAgeMask'
      end if
      r2Ptr(1) % block => block

      if (DMSTracersIdealAgePKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'DMSTracersIdealAgeMask', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'DMSTracersIdealAgeMask', r2Ptr)

! Define var array MacroMoleculesTracersIdealAgeMask
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group MacroMoleculesGRP
! Define constituent var PROTIdealAgeMask
! My Packages are MacroMoleculesTracersIdealAgePKG
      if (MacroMoleculesTracersIdealAgePKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_PROTIdealAgeMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_PROTIdealAgeMask', -1)
           end if
      end if
! Define constituent var POLYIdealAgeMask
! My packages are MacroMoleculesTracersIdealAgePKG
      if (MacroMoleculesTracersIdealAgePKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_POLYIdealAgeMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_POLYIdealAgeMask', -1)
         end if
      end if
! Define constituent var LIPIdealAgeMask
! My packages are MacroMoleculesTracersIdealAgePKG
      if (MacroMoleculesTracersIdealAgePKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_LIPIdealAgeMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_LIPIdealAgeMask', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_MacroMoleculesTracersIdealAgeMask', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'MacroMoleculesTracersIdealAgeMask'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_PROTIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'PROTIdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_POLYIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'POLYIdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_LIPIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'LIPIdealAgeMask'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_MacroMoleculesTracersIdealAgeMask'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_PROTIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, PROT is reset to PROT * '&
//'PROTIdealAgeMask, valid values of PROTIdealAgeMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'PROTIdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_POLYIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, POLY is reset to POLY * '&
//'POLYIdealAgeMask, valid values of POLYIdealAgeMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'POLYIdealAgeMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_LIPIdealAgeMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, LIP is reset to LIP * '&
//'LIPIdealAgeMask, valid values of LIPIdealAgeMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'LIPIdealAgeMask'
      end if
      r2Ptr(1) % block => block

      if (MacroMoleculesTracersIdealAgePKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'MacroMoleculesTracersIdealAgeMask', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'MacroMoleculesTracersIdealAgeMask', r2Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_forcing_subpool_tracersIdealAgeFields


   subroutine ocn_generate_forcing_subpool_tracersTTDFields(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'tracersTTDFields', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'tracersTTDFields', newSubPool)

! Define var array activeTracersTTDMask
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group activeGRP
! Define constituent var temperatureTTDMask
! My Packages are activeTracersTTDPKG
      if (activeTracersTTDPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureTTDMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_temperatureTTDMask', -1)
           end if
      end if
! Define constituent var salinityTTDMask
! My packages are activeTracersTTDPKG
      if (activeTracersTTDPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityTTDMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityTTDMask', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'activeGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_activeTracersTTDMask', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'activeTracersTTDMask'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureTTDMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'temperatureTTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityTTDMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'salinityTTDMask'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_activeTracersTTDMask'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureTTDMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, temperature is reset to '&
//'TTDMask, valid values of temperatureTTDMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'temperatureTTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityTTDMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, salinity is reset to '&
//'salinityTTDMask, valid values of salinityTTDMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'salinityTTDMask'
      end if
      r2Ptr(1) % block => block

      if (activeTracersTTDPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'activeTracersTTDMask', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'activeTracersTTDMask', r2Ptr)

! Define var array debugTracersTTDMask
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group debugGRP
! Define constituent var tracer1TTDMask
! My Packages are debugTracersTTDPKG
      if (debugTracersTTDPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_tracer1TTDMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'debugGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_tracer1TTDMask', -1)
           end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'debugGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'debugGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'debugGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_debugTracersTTDMask', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'debugTracersTTDMask'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_tracer1TTDMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'tracer1TTDMask'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_debugTracersTTDMask'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_tracer1TTDMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, tracer1 is reset to TTDMask, '&
//'valid values of tracer1TTDMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'tracer1TTDMask'
      end if
      r2Ptr(1) % block => block

      if (debugTracersTTDPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'debugTracersTTDMask', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'debugTracersTTDMask', r2Ptr)

! Define var array ecosysTracersTTDMask
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group ecosysGRP
! Define constituent var PO4TTDMask
! My Packages are ecosysTracersTTDPKG
      if (ecosysTracersTTDPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_PO4TTDMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_PO4TTDMask', -1)
           end if
      end if
! Define constituent var NO3TTDMask
! My packages are ecosysTracersTTDPKG
      if (ecosysTracersTTDPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_NO3TTDMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_NO3TTDMask', -1)
         end if
      end if
! Define constituent var SiO3TTDMask
! My packages are ecosysTracersTTDPKG
      if (ecosysTracersTTDPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_SiO3TTDMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_SiO3TTDMask', -1)
         end if
      end if
! Define constituent var NH4TTDMask
! My packages are ecosysTracersTTDPKG
      if (ecosysTracersTTDPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_NH4TTDMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_NH4TTDMask', -1)
         end if
      end if
! Define constituent var FeTTDMask
! My packages are ecosysTracersTTDPKG
      if (ecosysTracersTTDPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_FeTTDMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_FeTTDMask', -1)
         end if
      end if
! Define constituent var O2TTDMask
! My packages are ecosysTracersTTDPKG
      if (ecosysTracersTTDPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_O2TTDMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_O2TTDMask', -1)
         end if
      end if
! Define constituent var DICTTDMask
! My packages are ecosysTracersTTDPKG
      if (ecosysTracersTTDPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DICTTDMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DICTTDMask', -1)
         end if
      end if
! Define constituent var DIC_ALT_CO2TTDMask
! My packages are ecosysTracersTTDPKG
      if (ecosysTracersTTDPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DIC_ALT_CO2TTDMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DIC_ALT_CO2TTDMask', -1)
         end if
      end if
! Define constituent var ALKTTDMask
! My packages are ecosysTracersTTDPKG
      if (ecosysTracersTTDPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_ALKTTDMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_ALKTTDMask', -1)
         end if
      end if
! Define constituent var DOCTTDMask
! My packages are ecosysTracersTTDPKG
      if (ecosysTracersTTDPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOCTTDMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOCTTDMask', -1)
         end if
      end if
! Define constituent var DONTTDMask
! My packages are ecosysTracersTTDPKG
      if (ecosysTracersTTDPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DONTTDMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DONTTDMask', -1)
         end if
      end if
! Define constituent var DOFeTTDMask
! My packages are ecosysTracersTTDPKG
      if (ecosysTracersTTDPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOFeTTDMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOFeTTDMask', -1)
         end if
      end if
! Define constituent var DOPTTDMask
! My packages are ecosysTracersTTDPKG
      if (ecosysTracersTTDPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOPTTDMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOPTTDMask', -1)
         end if
      end if
! Define constituent var DOPrTTDMask
! My packages are ecosysTracersTTDPKG
      if (ecosysTracersTTDPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOPrTTDMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DOPrTTDMask', -1)
         end if
      end if
! Define constituent var DONrTTDMask
! My packages are ecosysTracersTTDPKG
      if (ecosysTracersTTDPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DONrTTDMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DONrTTDMask', -1)
         end if
      end if
! Define constituent var zooCTTDMask
! My packages are ecosysTracersTTDPKG
      if (ecosysTracersTTDPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_zooCTTDMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_zooCTTDMask', -1)
         end if
      end if
! Define constituent var spChlTTDMask
! My packages are ecosysTracersTTDPKG
      if (ecosysTracersTTDPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spChlTTDMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spChlTTDMask', -1)
         end if
      end if
! Define constituent var spCTTDMask
! My packages are ecosysTracersTTDPKG
      if (ecosysTracersTTDPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spCTTDMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spCTTDMask', -1)
         end if
      end if
! Define constituent var spFeTTDMask
! My packages are ecosysTracersTTDPKG
      if (ecosysTracersTTDPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spFeTTDMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spFeTTDMask', -1)
         end if
      end if
! Define constituent var spCaCO3TTDMask
! My packages are ecosysTracersTTDPKG
      if (ecosysTracersTTDPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spCaCO3TTDMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_spCaCO3TTDMask', -1)
         end if
      end if
! Define constituent var diatChlTTDMask
! My packages are ecosysTracersTTDPKG
      if (ecosysTracersTTDPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatChlTTDMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatChlTTDMask', -1)
         end if
      end if
! Define constituent var diatCTTDMask
! My packages are ecosysTracersTTDPKG
      if (ecosysTracersTTDPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatCTTDMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatCTTDMask', -1)
         end if
      end if
! Define constituent var diatFeTTDMask
! My packages are ecosysTracersTTDPKG
      if (ecosysTracersTTDPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatFeTTDMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatFeTTDMask', -1)
         end if
      end if
! Define constituent var diatSiTTDMask
! My packages are ecosysTracersTTDPKG
      if (ecosysTracersTTDPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatSiTTDMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diatSiTTDMask', -1)
         end if
      end if
! Define constituent var diazChlTTDMask
! My packages are ecosysTracersTTDPKG
      if (ecosysTracersTTDPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazChlTTDMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazChlTTDMask', -1)
         end if
      end if
! Define constituent var diazCTTDMask
! My packages are ecosysTracersTTDPKG
      if (ecosysTracersTTDPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazCTTDMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazCTTDMask', -1)
         end if
      end if
! Define constituent var diazFeTTDMask
! My packages are ecosysTracersTTDPKG
      if (ecosysTracersTTDPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazFeTTDMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_diazFeTTDMask', -1)
         end if
      end if
! Define constituent var phaeoChlTTDMask
! My packages are ecosysTracersTTDPKG
      if (ecosysTracersTTDPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoChlTTDMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoChlTTDMask', -1)
         end if
      end if
! Define constituent var phaeoCTTDMask
! My packages are ecosysTracersTTDPKG
      if (ecosysTracersTTDPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoCTTDMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoCTTDMask', -1)
         end if
      end if
! Define constituent var phaeoFeTTDMask
! My packages are ecosysTracersTTDPKG
      if (ecosysTracersTTDPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoFeTTDMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_phaeoFeTTDMask', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ecosysGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_ecosysTracersTTDMask', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'ecosysTracersTTDMask'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_PO4TTDMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'PO4TTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_NO3TTDMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'NO3TTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_SiO3TTDMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'SiO3TTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_NH4TTDMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'NH4TTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_FeTTDMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'FeTTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_O2TTDMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'O2TTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DICTTDMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DICTTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DIC_ALT_CO2TTDMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DIC_ALT_CO2TTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_ALKTTDMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'ALKTTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOCTTDMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DOCTTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DONTTDMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DONTTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOFeTTDMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DOFeTTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOPTTDMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DOPTTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOPrTTDMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DOPrTTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DONrTTDMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DONrTTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_zooCTTDMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'zooCTTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spChlTTDMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'spChlTTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spCTTDMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'spCTTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spFeTTDMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'spFeTTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spCaCO3TTDMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'spCaCO3TTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatChlTTDMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'diatChlTTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatCTTDMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'diatCTTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatFeTTDMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'diatFeTTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatSiTTDMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'diatSiTTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazChlTTDMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'diazChlTTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazCTTDMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'diazCTTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazFeTTDMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'diazFeTTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoChlTTDMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'phaeoChlTTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoCTTDMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'phaeoCTTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoFeTTDMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'phaeoFeTTDMask'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_ecosysTracersTTDMask'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_PO4TTDMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, PO4 is reset to TTDMask, valid '&
//'values of PO4TTDMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'PO4TTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_NO3TTDMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, NO3 is reset to TTDMask, valid '&
//'values of NO3TTDMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'NO3TTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_SiO3TTDMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, SiO3 is reset to TTDMask, valid '&
//'values of SiO3TTDMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'SiO3TTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_NH4TTDMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, NH4 is reset to TTDMask, valid '&
//'values of NH4TTDMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'NH4TTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_FeTTDMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, Fe is reset to TTDMask, valid '&
//'values of FeTTDMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'FeTTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_O2TTDMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, O2 is reset to TTDMask, valid '&
//'values of O2TTDMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'O2TTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DICTTDMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, DIC is reset to TTDMask, valid '&
//'values of DICTTDMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DICTTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DIC_ALT_CO2TTDMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, DIC_ALT_CO2 is reset to '&
//'TTDMask, valid values of DIC_ALT_CO2TTDMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DIC_ALT_CO2TTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_ALKTTDMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, ALK is reset to TTDMask, valid '&
//'values of ALKTTDMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'ALKTTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOCTTDMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, DOC is reset to TTDMask, valid '&
//'values of DOCTTDMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DOCTTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DONTTDMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, DON is reset to TTDMask, valid '&
//'values of DONTTDMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DONTTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOFeTTDMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, DOFe is reset to TTDMask, valid '&
//'values of DOFeTTDMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DOFeTTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOPTTDMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, DOP is reset to TTDMask, valid '&
//'values of DOPTTDMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DOPTTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DOPrTTDMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, DOPr is reset to TTDMask, valid '&
//'values of DOPrTTDMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DOPrTTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DONrTTDMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, DONr is reset to TTDMask, valid '&
//'values of DONrTTDMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DONrTTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_zooCTTDMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, zooC is reset to TTDMask, valid '&
//'values of zooCTTDMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'zooCTTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spChlTTDMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, spChl is reset to TTDMask, '&
//'valid values of spChlTTDMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'spChlTTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spCTTDMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, spC is reset to TTDMask, valid '&
//'values of spCTTDMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'spCTTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spFeTTDMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, spFe is reset to TTDMask, valid '&
//'values of spFeTTDMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'spFeTTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_spCaCO3TTDMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, spCaCO3 is reset to TTDMask, '&
//'valid values of spCaCO3TTDMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'spCaCO3TTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatChlTTDMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, diatChl is reset to TTDMask, '&
//'valid values of diatChlTTDMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'diatChlTTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatCTTDMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, diatC is reset to TTDMask, '&
//'valid values of diatCTTDMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'diatCTTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatFeTTDMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, diatFe is reset to TTDMask, '&
//'valid values of diatFeTTDMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'diatFeTTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diatSiTTDMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, diatSi is reset to TTDMask, '&
//'valid values of diatSiTTDMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'diatSiTTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazChlTTDMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, diazChl is reset to TTDMask, '&
//'valid values of diazChlTTDMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'diazChlTTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazCTTDMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, diazC is reset to TTDMask, '&
//'valid values of diazCTTDMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'diazCTTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_diazFeTTDMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, diazFe is reset to TTDMask, '&
//'valid values of diazFeTTDMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'diazFeTTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoChlTTDMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, phaeoChl is reset to TTDMask, '&
//'valid values of phaeoChlTTDMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'phaeoChlTTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoCTTDMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, phaeoC is reset to TTDMask, '&
//'valid values of phaeoCTTDMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'phaeoCTTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_phaeoFeTTDMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, phaeoFe is reset to TTDMask, '&
//'valid values of phaeoFeTTDMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'phaeoFeTTDMask'
      end if
      r2Ptr(1) % block => block

      if (ecosysTracersTTDPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosysTracersTTDMask', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosysTracersTTDMask', r2Ptr)

! Define var array DMSTracersTTDMask
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group DMSGRP
! Define constituent var DMSTTDMask
! My Packages are DMSTracersTTDPKG
      if (DMSTracersTTDPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DMSTTDMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'DMSGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_DMSTTDMask', -1)
           end if
      end if
! Define constituent var DMSPTTDMask
! My packages are DMSTracersTTDPKG
      if (DMSTracersTTDPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DMSPTTDMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'DMSGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_DMSPTTDMask', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'DMSGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'DMSGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'DMSGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_DMSTracersTTDMask', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'DMSTracersTTDMask'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DMSTTDMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DMSTTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DMSPTTDMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'DMSPTTDMask'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_DMSTracersTTDMask'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DMSTTDMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, DMS is reset to TTDMask, valid '&
//'values of DMSTTDMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DMSTTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_DMSPTTDMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, DMSP is reset to DMSPTTDMask, '&
//'valid values of DMSPTTDMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'DMSPTTDMask'
      end if
      r2Ptr(1) % block => block

      if (DMSTracersTTDPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'DMSTracersTTDMask', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'DMSTracersTTDMask', r2Ptr)

! Define var array MacroMoleculesTracersTTDMask
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group MacroMoleculesGRP
! Define constituent var PROTTTDMask
! My Packages are MacroMoleculesTracersTTDPKG
      if (MacroMoleculesTracersTTDPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_PROTTTDMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_PROTTTDMask', -1)
           end if
      end if
! Define constituent var POLYTTDMask
! My packages are MacroMoleculesTracersTTDPKG
      if (MacroMoleculesTracersTTDPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_POLYTTDMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_POLYTTDMask', -1)
         end if
      end if
! Define constituent var LIPTTDMask
! My packages are MacroMoleculesTracersTTDPKG
      if (MacroMoleculesTracersTTDPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_LIPTTDMask', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesGRP_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_LIPTTDMask', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesGRP_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesGRP_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'MacroMoleculesGRP_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_MacroMoleculesTracersTTDMask', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'MacroMoleculesTracersTTDMask'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_PROTTTDMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'PROTTTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_POLYTTDMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'POLYTTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_LIPTTDMask', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'LIPTTDMask'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_MacroMoleculesTracersTTDMask'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_PROTTTDMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, PROT is reset to TTDMask, valid '&
//'values of PROTTTDMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'PROTTTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_POLYTTDMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, POLY is reset to TTDMask, valid '&
//'values of POLYTTDMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'POLYTTDMask'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_LIPTTDMask', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'In top layer, LIP is reset to LIPTTDMask, '&
//'valid values of LIPTTDMask or 0 and 1')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'unitless')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'LIPTTDMask'
      end if
      r2Ptr(1) % block => block

      if (MacroMoleculesTracersTTDPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'MacroMoleculesTracersTTDMask', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'MacroMoleculesTracersTTDMask', r2Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_forcing_subpool_tracersTTDFields


   subroutine ocn_generate_forcing_subpool_ecosysAuxiliary(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'ecosysAuxiliary', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'ecosysAuxiliary', newSubPool)

! Define variable PH_PREV_3D
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'PH_PREV_3D'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'pH')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'pH (3D) from previous timestep')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'PH_PREV_3D', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'PH_PREV_3D', r2Ptr)

! Define variable PH_PREV_ALT_CO2_3D
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'PH_PREV_ALT_CO2_3D'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'pH')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'pH (3D) of alternate CO2 from previous timestep')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'PH_PREV_ALT_CO2_3D', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'PH_PREV_ALT_CO2_3D', r2Ptr)

! Define variable FESEDFLUX
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'FESEDFLUX'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol Fe m^{-3} m s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Sedimentary Fe Flux')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'FESEDFLUX', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'FESEDFLUX', r2Ptr)

! Define variable dust_FLUX_IN
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'dust_FLUX_IN'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'kg m^{-2} s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Surface Dust Flux')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'dust_FLUX_IN', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'dust_FLUX_IN', r1Ptr)

! Define variable IRON_FLUX_IN
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'IRON_FLUX_IN'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol Fe m^{-3} m s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Surface Fe Flux')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'IRON_FLUX_IN', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'IRON_FLUX_IN', r1Ptr)

! Define variable PAR_surface
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'PAR_surface'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'TEMP or Watts m s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Photosynthetically Available Radiation at Ocean Surface')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'PAR_surface', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'PAR_surface', r1Ptr)

! Define variable windSpeedSquared10m
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'windSpeedSquared10m'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm^2 s^{-2}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Wind Speed at 10m Squared')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'windSpeedSquared10m', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'windSpeedSquared10m', r1Ptr)

! Define variable atmosphericCO2
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'atmosphericCO2'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'ppm')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Atmospheric CO2 Concentration')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'atmosphericCO2', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'atmosphericCO2', r1Ptr)

! Define variable atmosphericCO2_ALT_CO2
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'atmosphericCO2_ALT_CO2'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'ppm')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Atmospheric CO2 Concentration for Alternate CO2')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'atmosphericCO2_ALT_CO2', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'atmosphericCO2_ALT_CO2', r1Ptr)

! Define variable PH_PREV
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'PH_PREV'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'pH')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'pH (2D) from previous timestep')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'PH_PREV', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'PH_PREV', r1Ptr)

! Define variable PH_PREV_ALT_CO2
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'PH_PREV_ALT_CO2'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'pH')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'pH (2D) of alternate CO2 from previous timestep')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'PH_PREV_ALT_CO2', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'PH_PREV_ALT_CO2', r1Ptr)

! Define variable depositionFluxNO3
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'depositionFluxNO3'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol N m^{-3} m s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Atmospheric Deposition of NO3')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'depositionFluxNO3', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'depositionFluxNO3', r1Ptr)

! Define variable depositionFluxNH4
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'depositionFluxNH4'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol N m^{-3} m s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Atmospheric Deposition of NH4')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'depositionFluxNH4', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'depositionFluxNH4', r1Ptr)

! Define variable pocToSed
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'pocToSed'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'nmol cm^{-2} m s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Flux of POC into bottom sediments')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'pocToSed', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'pocToSed', r1Ptr)

! Define variable riverFluxNO3
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'riverFluxNO3'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol N m^{-3} m s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'River Runoff Flux of NO3')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'riverFluxNO3', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'riverFluxNO3', r1Ptr)

! Define variable riverFluxPO4
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'riverFluxPO4'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol P m^{-3} m s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'River Runoff Flux of PO4')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'riverFluxPO4', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'riverFluxPO4', r1Ptr)

! Define variable riverFluxSiO3
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'riverFluxSiO3'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol Si m^{-3} m s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'River Runoff Flux of SiO3')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'riverFluxSiO3', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'riverFluxSiO3', r1Ptr)

! Define variable riverFluxFe
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'riverFluxFe'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol Fe m^{-3} m s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'River Runoff Flux of Fe')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'riverFluxFe', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'riverFluxFe', r1Ptr)

! Define variable riverFluxDOC
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'riverFluxDOC'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-3} m s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'River Runoff Flux of DOC')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'riverFluxDOC', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'riverFluxDOC', r1Ptr)

! Define variable riverFluxDON
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'riverFluxDON'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol N m^{-3} m s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'River Runoff Flux of DON')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'riverFluxDON', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'riverFluxDON', r1Ptr)

! Define variable riverFluxDOP
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'riverFluxDOP'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol P m^{-3} m s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'River Runoff Flux of DOP')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'riverFluxDOP', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'riverFluxDOP', r1Ptr)

! Define variable riverFluxDIC
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'riverFluxDIC'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-3} m s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'River Runoff Flux of DIC')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'riverFluxDIC', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'riverFluxDIC', r1Ptr)

! Define variable riverFluxALK
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'riverFluxALK'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'meq m^{-3} m s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'River Runoff Flux of ALK')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'riverFluxALK', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'riverFluxALK', r1Ptr)

! Define variable CO2_gas_flux
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'CO2_gas_flux'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-3} m s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'CO2 Gas Flux')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'CO2_gas_flux', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'CO2_gas_flux', r1Ptr)

! Define variable CO2_alt_gas_flux
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'CO2_alt_gas_flux'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-3} m s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'CO2 Gas Flux for Alternate CO2')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'CO2_alt_gas_flux', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'CO2_alt_gas_flux', r1Ptr)

! Define variable avgCO2_gas_flux
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'avgCO2_gas_flux'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-3} m s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'CO2 Gas Flux averaged over a coupling interval')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'avgCO2_gas_flux', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'avgCO2_gas_flux', r1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_forcing_subpool_ecosysAuxiliary


   subroutine ocn_generate_forcing_subpool_ecosysSeaIceCoupling(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'ecosysSeaIceCoupling', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'ecosysSeaIceCoupling', newSubPool)

! Define variable avgOceanSurfacePhytoC
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'avgOceanSurfacePhytoC'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'R3'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-3}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Ocean Surface phytoplankton carbon concentration: (1,2,3) '&
//'corresponds to (diat,sp,phaeo)')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'avgOceanSurfacePhytoC', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'avgOceanSurfacePhytoC', r2Ptr)

! Define variable avgOceanSurfaceDIC
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'avgOceanSurfaceDIC'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-3}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Ocean Surface DIC concentration')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'avgOceanSurfaceDIC', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'avgOceanSurfaceDIC', r1Ptr)

! Define variable avgOceanSurfaceNO3
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'avgOceanSurfaceNO3'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol N m^{-3}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Ocean Surface NO3 concentration')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'avgOceanSurfaceNO3', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'avgOceanSurfaceNO3', r1Ptr)

! Define variable avgOceanSurfaceSiO3
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'avgOceanSurfaceSiO3'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol Si m^{-3}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Ocean Surface SiO3 concentration')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'avgOceanSurfaceSiO3', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'avgOceanSurfaceSiO3', r1Ptr)

! Define variable avgOceanSurfaceNH4
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'avgOceanSurfaceNH4'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol N m^{-3}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Ocean Surface NH4 concentration')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'avgOceanSurfaceNH4', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'avgOceanSurfaceNH4', r1Ptr)

! Define variable avgOceanSurfaceDOCr
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'avgOceanSurfaceDOCr'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-3}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Ocean Surface DOCr (Humics) concentration')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'avgOceanSurfaceDOCr', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'avgOceanSurfaceDOCr', r1Ptr)

! Define variable avgOceanSurfaceFeParticulate
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'avgOceanSurfaceFeParticulate'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol Fe m^{-3}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Ocean Surface particulate Fe concentration (set to zero)')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'avgOceanSurfaceFeParticulate', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'avgOceanSurfaceFeParticulate', r1Ptr)

! Define variable avgOceanSurfaceFeDissolved
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'avgOceanSurfaceFeDissolved'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol Fe m^{-3}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Ocean Surface dissolved bioavailable Fe concentration')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'avgOceanSurfaceFeDissolved', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'avgOceanSurfaceFeDissolved', r1Ptr)

! Define variable iceFluxPhytoC
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'iceFluxPhytoC'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'R3'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-2} s')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Surface phytoplankton carbon flux from sea ice: (1,2,3) '&
//'corresponds to (diat,sp,phaeo)')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceFluxPhytoC', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'iceFluxPhytoC', r2Ptr)

! Define variable iceFluxDIC
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'iceFluxDIC'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-2} s')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Surface DIC flux from sea ice')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceFluxDIC', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'iceFluxDIC', r1Ptr)

! Define variable iceFluxNO3
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'iceFluxNO3'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol N m^{-2} s')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Surface NO3 flux from sea ice')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceFluxNO3', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'iceFluxNO3', r1Ptr)

! Define variable iceFluxSiO3
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'iceFluxSiO3'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol Si m^{-2} s')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Surface SiO3 flux from sea ice')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceFluxSiO3', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'iceFluxSiO3', r1Ptr)

! Define variable iceFluxNH4
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'iceFluxNH4'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol N m^{-2} s')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Surface NH4 flux from sea ice')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceFluxNH4', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'iceFluxNH4', r1Ptr)

! Define variable iceFluxDOCr
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'iceFluxDOCr'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-2} s')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Surface DOCr (Humics) flux from sea ice')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceFluxDOCr', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'iceFluxDOCr', r1Ptr)

! Define variable iceFluxFeParticulate
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'iceFluxFeParticulate'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol Fe m^{-2} s')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Surface particulate Fe flux from sea ice (set to zero)')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceFluxFeParticulate', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'iceFluxFeParticulate', r1Ptr)

! Define variable iceFluxFeDissolved
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'iceFluxFeDissolved'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol Fe m^{-2} s')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Surface dissolved bioavailable Fe flux from sea ice')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceFluxFeDissolved', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'iceFluxFeDissolved', r1Ptr)

! Define variable iceFluxDust
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'iceFluxDust'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'kg m^{-2} s')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Surface dust flux from sea ice')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceFluxDust', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'iceFluxDust', r1Ptr)

! Define variable iceFluxDOC
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'iceFluxDOC'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'TWO'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-2} s')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Surface Organics flux from sea ice: '&
//'(1,2)=>(polysaccharides,lipids)')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceFluxDOC', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'iceFluxDOC', r2Ptr)

! Define variable iceFluxDON
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'iceFluxDON'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol N m^{-2} s')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Surface Organic Proteins flux from sea ice')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceFluxDON', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'iceFluxDON', r1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_forcing_subpool_ecosysSeaIceCoupling


   subroutine ocn_generate_forcing_subpool_ecosysDiagFieldsLevel1(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'ecosysDiagFieldsLevel1', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'ecosysDiagFieldsLevel1', newSubPool)

! Define variable ecosys_diag_photoC_TOT_zint
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'ecosys_diag_photoC_TOT_zint'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-3} m s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Total C Fixation Vertical Integral')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_photoC_TOT_zint', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_photoC_TOT_zint', r1Ptr)

! Define variable ecosys_diag_photoC_NO3_TOT_zint
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'ecosys_diag_photoC_NO3_TOT_zint'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-3} m s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Total C Fixation from NO3 Vertical Integral')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_photoC_NO3_TOT_zint', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_photoC_NO3_TOT_zint', r1Ptr)

! Define variable ecosys_diag_O2_ZMIN
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'ecosys_diag_O2_ZMIN'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol O2 m^{-3}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Vertical Minimum of O2')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_O2_ZMIN', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_O2_ZMIN', r1Ptr)

! Define variable ecosys_diag_O2_ZMIN_DEPTH
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'ecosys_diag_O2_ZMIN_DEPTH'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Depth of Vertical Minimum of O2')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_O2_ZMIN_DEPTH', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_O2_ZMIN_DEPTH', r1Ptr)

! Define variable ecosys_diag_Chl_TOT_zint_100m
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'ecosys_diag_Chl_TOT_zint_100m'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-3} m s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Vertical Integral of Total Chlorophyll in Top 100m')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_Chl_TOT_zint_100m', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_Chl_TOT_zint_100m', r1Ptr)

! Define variable ecosys_diag_Jint_Ctot
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'ecosys_diag_Jint_Ctot'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-3} m s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Vertical Integral of Conservative Subterms of Source Sink '&
//'Term for Ctot')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_Jint_Ctot', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_Jint_Ctot', r1Ptr)

! Define variable ecosys_diag_Jint_100m_Ctot
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'ecosys_diag_Jint_100m_Ctot'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-3} m s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Vertical Integral of Conservative Subterms of Source Sink '&
//'Term for Ctot, 0-100m')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_Jint_100m_Ctot', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_Jint_100m_Ctot', r1Ptr)

! Define variable ecosys_diag_Jint_Ntot
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'ecosys_diag_Jint_Ntot'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol N m^{-3} m s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Vertical Integral of Conservative Subterms of Source Sink '&
//'Term for Ntot')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_Jint_Ntot', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_Jint_Ntot', r1Ptr)

! Define variable ecosys_diag_Jint_100m_Ntot
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'ecosys_diag_Jint_100m_Ntot'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol N m^{-3} m s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Vertical Integral of Conservative Subterms of Source Sink '&
//'Term for Ntot, 0-100m')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_Jint_100m_Ntot', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_Jint_100m_Ntot', r1Ptr)

! Define variable ecosys_diag_Jint_Ptot
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'ecosys_diag_Jint_Ptot'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol P m^{-3} m s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Vertical Integral of Conservative Subterms of Source Sink '&
//'Term for Ptot')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_Jint_Ptot', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_Jint_Ptot', r1Ptr)

! Define variable ecosys_diag_Jint_100m_Ptot
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'ecosys_diag_Jint_100m_Ptot'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol P m^{-3} m s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Vertical Integral of Conservative Subterms of Source Sink '&
//'Term for Ptot, 0-100m')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_Jint_100m_Ptot', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_Jint_100m_Ptot', r1Ptr)

! Define variable ecosys_diag_Jint_Sitot
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'ecosys_diag_Jint_Sitot'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol Si m^{-3} m s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Vertical Integral of Conservative Subterms of Source Sink '&
//'Term for Sitot')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_Jint_Sitot', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_Jint_Sitot', r1Ptr)

! Define variable ecosys_diag_Jint_100m_Sitot
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'ecosys_diag_Jint_100m_Sitot'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol Si m^{-3} m s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Vertical Integral of Conservative Subterms of Source Sink '&
//'Term for Sitot, 0-100m')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_Jint_100m_Sitot', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_Jint_100m_Sitot', r1Ptr)

! Define variable ecosys_diag_photoC_zint
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_photoC_zint'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'FOUR'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-3} m s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'C Fixation Vertical Integral for sp, diat, diaz, phaeo')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_photoC_zint', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_photoC_zint', r2Ptr)

! Define variable ecosys_diag_photoC_NO3_zint
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_photoC_NO3_zint'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'FOUR'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-3} m s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'C Fixation from NO3 Vertical Integral for sp, diat, diaz, '&
//'phaeo')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_photoC_NO3_zint', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_photoC_NO3_zint', r2Ptr)

! Define variable ecosys_diag_PAR_avg
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_PAR_avg'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'W m^{-2}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'PAR Average over Model Cell')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_PAR_avg', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_PAR_avg', r2Ptr)

! Define variable ecosys_diag_POC_FLUX_IN
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_POC_FLUX_IN'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-3} m s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'POC Flux into Cell')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_POC_FLUX_IN', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_POC_FLUX_IN', r2Ptr)

! Define variable ecosys_diag_CaCO3_FLUX_IN
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_CaCO3_FLUX_IN'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-3} m s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'CaCO3 Flux into Cell')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_CaCO3_FLUX_IN', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_CaCO3_FLUX_IN', r2Ptr)

! Define variable ecosys_diag_auto_graze_TOT
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_auto_graze_TOT'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-3} s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Total Autotroph Grazing')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_auto_graze_TOT', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_auto_graze_TOT', r2Ptr)

! Define variable ecosys_diag_zoo_loss
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_zoo_loss'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-3} s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Zooplankton Loss')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_zoo_loss', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_zoo_loss', r2Ptr)

! Define variable ecosys_diag_photoC_TOT
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_photoC_TOT'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-3} s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Total C Fixation Vertical Integral')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_photoC_TOT', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_photoC_TOT', r2Ptr)

! Define variable ecosys_diag_photoC_NO3_TOT
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_photoC_NO3_TOT'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-3} s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Total C Fixation from NO3 Vertical Integral')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_photoC_NO3_TOT', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_photoC_NO3_TOT', r2Ptr)

! Define variable ecosys_diag_NITRIF
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_NITRIF'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol N m^{-3} s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Nitrification')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_NITRIF', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_NITRIF', r2Ptr)

! Define variable ecosys_diag_DENITRIF
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_DENITRIF'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol N m^{-3} s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Denitrification')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_DENITRIF', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_DENITRIF', r2Ptr)

! Define variable ecosys_diag_calcToSed
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_calcToSed'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-3} m s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'CaCO3 Flux to Sediments')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_calcToSed', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_calcToSed', r2Ptr)

! Define variable ecosys_diag_pocToSed
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_pocToSed'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-3} m s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'POC Flux to Sediments')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_pocToSed', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_pocToSed', r2Ptr)

! Define variable ecosys_diag_pfeToSed
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_pfeToSed'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol Fe m^{-3} m s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Fe Flux to Sediments')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_pfeToSed', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_pfeToSed', r2Ptr)

! Define variable ecosys_diag_SedDenitrif
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_SedDenitrif'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol N m^{-3} m s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Nitrogen Loss in Sediments')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_SedDenitrif', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_SedDenitrif', r2Ptr)

! Define variable ecosys_diag_tot_Nfix
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_tot_Nfix'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol N m^{-3} s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Total N Fixation')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_tot_Nfix', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_tot_Nfix', r2Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_forcing_subpool_ecosysDiagFieldsLevel1


   subroutine ocn_generate_forcing_subpool_ecosysDiagFieldsLevel2(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'ecosysDiagFieldsLevel2', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'ecosysDiagFieldsLevel2', newSubPool)

! Define variable ecosys_diag_O2_PRODUCTION
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_O2_PRODUCTION'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol O2 m^{-3} s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'O2 Production')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_O2_PRODUCTION', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_O2_PRODUCTION', r2Ptr)

! Define variable ecosys_diag_O2_CONSUMPTION
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_O2_CONSUMPTION'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol O2 m^{-3} s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'O2 Consumption')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_O2_CONSUMPTION', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_O2_CONSUMPTION', r2Ptr)

! Define variable ecosys_diag_AOU
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_AOU'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol O2 m^{-3}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Apparent O2 Utilization')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_AOU', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_AOU', r2Ptr)

! Define variable ecosys_diag_pH_3D
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_pH_3D'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'pH')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_pH_3D', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_pH_3D', r2Ptr)

! Define variable ecosys_diag_POC_PROD
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_POC_PROD'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-3} s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'POC Production')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_POC_PROD', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_POC_PROD', r2Ptr)

! Define variable ecosys_diag_POC_REMIN
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_POC_REMIN'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-3} s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'POC Remineralization')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_POC_REMIN', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_POC_REMIN', r2Ptr)

! Define variable ecosys_diag_POC_ACCUM
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_POC_ACCUM'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-3} s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'POC Accumulation')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_POC_ACCUM', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_POC_ACCUM', r2Ptr)

! Define variable ecosys_diag_N_lim
      allocate(r3Ptr(1))

! Setting up time level 1
      r3Ptr(1) % fieldName = 'ecosys_diag_N_lim'
      r3Ptr(1) % isVarArray = .false.
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.
! Setting up dimensions
      r3Ptr(1) % dimNames(1) = 'FOUR'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nCells'
      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(1))
      allocate(r3Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'long_name', 'N Limitation for sp, diat, diaz, phaeo')
      r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r3Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_N_lim', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_N_lim', r3Ptr)

! Define variable ecosys_diag_P_lim
      allocate(r3Ptr(1))

! Setting up time level 1
      r3Ptr(1) % fieldName = 'ecosys_diag_P_lim'
      r3Ptr(1) % isVarArray = .false.
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.
! Setting up dimensions
      r3Ptr(1) % dimNames(1) = 'FOUR'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nCells'
      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(1))
      allocate(r3Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'long_name', 'P Limitation for sp, diat, diaz, phaeo')
      r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r3Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_P_lim', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_P_lim', r3Ptr)

! Define variable ecosys_diag_Fe_lim
      allocate(r3Ptr(1))

! Setting up time level 1
      r3Ptr(1) % fieldName = 'ecosys_diag_Fe_lim'
      r3Ptr(1) % isVarArray = .false.
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.
! Setting up dimensions
      r3Ptr(1) % dimNames(1) = 'FOUR'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nCells'
      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(1))
      allocate(r3Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'long_name', 'Fe Limitation for sp, diat, diaz, phaeo')
      r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r3Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_Fe_lim', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_Fe_lim', r3Ptr)

! Define variable ecosys_diag_SiO3_lim
      allocate(r3Ptr(1))

! Setting up time level 1
      r3Ptr(1) % fieldName = 'ecosys_diag_SiO3_lim'
      r3Ptr(1) % isVarArray = .false.
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.
! Setting up dimensions
      r3Ptr(1) % dimNames(1) = 'FOUR'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nCells'
      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(1))
      allocate(r3Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'long_name', 'SiO3 Limitation for sp, diat, diaz, phaeo')
      r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r3Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_SiO3_lim', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_SiO3_lim', r3Ptr)

! Define variable ecosys_diag_light_lim
      allocate(r3Ptr(1))

! Setting up time level 1
      r3Ptr(1) % fieldName = 'ecosys_diag_light_lim'
      r3Ptr(1) % isVarArray = .false.
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.
! Setting up dimensions
      r3Ptr(1) % dimNames(1) = 'FOUR'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nCells'
      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(1))
      allocate(r3Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'long_name', 'Light Limitation for sp, diat, diaz, phaeo')
      r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r3Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_light_lim', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_light_lim', r3Ptr)

! Define variable ecosys_diag_photoC
      allocate(r3Ptr(1))

! Setting up time level 1
      r3Ptr(1) % fieldName = 'ecosys_diag_photoC'
      r3Ptr(1) % isVarArray = .false.
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.
! Setting up dimensions
      r3Ptr(1) % dimNames(1) = 'FOUR'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nCells'
      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(1))
      allocate(r3Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-3} s^{-1}')
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'long_name', 'C Fixation for sp, diat, diaz, phaeo')
      r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r3Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_photoC', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_photoC', r3Ptr)

! Define variable ecosys_diag_photoC_NO3
      allocate(r3Ptr(1))

! Setting up time level 1
      r3Ptr(1) % fieldName = 'ecosys_diag_photoC_NO3'
      r3Ptr(1) % isVarArray = .false.
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.
! Setting up dimensions
      r3Ptr(1) % dimNames(1) = 'FOUR'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nCells'
      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(1))
      allocate(r3Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-3} s^{-1}')
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'long_name', 'C Fixation from NO3 for sp, diat, diaz, phaeo')
      r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r3Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_photoC_NO3', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_photoC_NO3', r3Ptr)

! Define variable ecosys_diag_photoFe
      allocate(r3Ptr(1))

! Setting up time level 1
      r3Ptr(1) % fieldName = 'ecosys_diag_photoFe'
      r3Ptr(1) % isVarArray = .false.
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.
! Setting up dimensions
      r3Ptr(1) % dimNames(1) = 'FOUR'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nCells'
      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(1))
      allocate(r3Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'units', 'mmol Fe m^{-3} s^{-1}')
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'long_name', 'Fe Uptake')
      r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r3Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_photoFe', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_photoFe', r3Ptr)

! Define variable ecosys_diag_photoNO3
      allocate(r3Ptr(1))

! Setting up time level 1
      r3Ptr(1) % fieldName = 'ecosys_diag_photoNO3'
      r3Ptr(1) % isVarArray = .false.
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.
! Setting up dimensions
      r3Ptr(1) % dimNames(1) = 'FOUR'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nCells'
      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(1))
      allocate(r3Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'units', 'mmol N m^{-3} s^{-1}')
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'long_name', 'NO3 Uptake')
      r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r3Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_photoNO3', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_photoNO3', r3Ptr)

! Define variable ecosys_diag_photoNH4
      allocate(r3Ptr(1))

! Setting up time level 1
      r3Ptr(1) % fieldName = 'ecosys_diag_photoNH4'
      r3Ptr(1) % isVarArray = .false.
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.
! Setting up dimensions
      r3Ptr(1) % dimNames(1) = 'FOUR'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nCells'
      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(1))
      allocate(r3Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'units', 'mmol N m^{-3} s^{-1}')
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'long_name', 'NH4 Uptake')
      r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r3Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_photoNH4', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_photoNH4', r3Ptr)

! Define variable ecosys_diag_DOP_uptake
      allocate(r3Ptr(1))

! Setting up time level 1
      r3Ptr(1) % fieldName = 'ecosys_diag_DOP_uptake'
      r3Ptr(1) % isVarArray = .false.
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.
! Setting up dimensions
      r3Ptr(1) % dimNames(1) = 'FOUR'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nCells'
      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(1))
      allocate(r3Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'units', 'mmol P m^{-3} s^{-1}')
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'long_name', 'DOP Uptake')
      r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r3Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_DOP_uptake', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_DOP_uptake', r3Ptr)

! Define variable ecosys_diag_PO4_uptake
      allocate(r3Ptr(1))

! Setting up time level 1
      r3Ptr(1) % fieldName = 'ecosys_diag_PO4_uptake'
      r3Ptr(1) % isVarArray = .false.
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.
! Setting up dimensions
      r3Ptr(1) % dimNames(1) = 'FOUR'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nCells'
      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(1))
      allocate(r3Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'units', 'mmol P m^{-3} s^{-1}')
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'long_name', 'PO4 Uptake')
      r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r3Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_PO4_uptake', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_PO4_uptake', r3Ptr)

! Define variable ecosys_diag_auto_graze
      allocate(r3Ptr(1))

! Setting up time level 1
      r3Ptr(1) % fieldName = 'ecosys_diag_auto_graze'
      r3Ptr(1) % isVarArray = .false.
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.
! Setting up dimensions
      r3Ptr(1) % dimNames(1) = 'FOUR'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nCells'
      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(1))
      allocate(r3Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-3} s^{-1}')
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'long_name', 'Grazing for sp, diat, diaz, phaeo')
      r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r3Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_auto_graze', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_auto_graze', r3Ptr)

! Define variable ecosys_diag_auto_loss
      allocate(r3Ptr(1))

! Setting up time level 1
      r3Ptr(1) % fieldName = 'ecosys_diag_auto_loss'
      r3Ptr(1) % isVarArray = .false.
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.
! Setting up dimensions
      r3Ptr(1) % dimNames(1) = 'FOUR'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nCells'
      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(1))
      allocate(r3Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-3} s^{-1}')
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'long_name', 'Loss for sp, diat, diaz, phaeo')
      r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r3Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_auto_loss', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_auto_loss', r3Ptr)

! Define variable ecosys_diag_auto_agg
      allocate(r3Ptr(1))

! Setting up time level 1
      r3Ptr(1) % fieldName = 'ecosys_diag_auto_agg'
      r3Ptr(1) % isVarArray = .false.
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.
! Setting up dimensions
      r3Ptr(1) % dimNames(1) = 'FOUR'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nCells'
      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(1))
      allocate(r3Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-3} s^{-1}')
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'long_name', 'Aggregate for sp, diat, diaz, phaeo')
      r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r3Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_auto_agg', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_auto_agg', r3Ptr)

! Define variable ecosys_diag_Nfix
      allocate(r3Ptr(1))

! Setting up time level 1
      r3Ptr(1) % fieldName = 'ecosys_diag_Nfix'
      r3Ptr(1) % isVarArray = .false.
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.
! Setting up dimensions
      r3Ptr(1) % dimNames(1) = 'FOUR'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nCells'
      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(1))
      allocate(r3Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'units', 'mmol N m^{-3} s^{-1}')
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'long_name', 'N Fixation for sp, diat, diaz, phaeo')
      r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r3Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_Nfix', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_Nfix', r3Ptr)

! Define variable ecosys_diag_pistonVel_O2
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'ecosys_diag_pistonVel_O2'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Piston Velocity for O2 Surface Flux')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_pistonVel_O2', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_pistonVel_O2', r1Ptr)

! Define variable ecosys_diag_pistonVel_CO2
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'ecosys_diag_pistonVel_CO2'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Piston Velocity for CO2 Surface Flux')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_pistonVel_CO2', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_pistonVel_CO2', r1Ptr)

! Define variable ecosys_diag_Schmidt_O2
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'ecosys_diag_Schmidt_O2'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'O2 Schmidt Number')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_Schmidt_O2', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_Schmidt_O2', r1Ptr)

! Define variable ecosys_diag_Schmidt_CO2
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'ecosys_diag_Schmidt_CO2'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'CO2 Schmidt Number')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_Schmidt_CO2', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_Schmidt_CO2', r1Ptr)

! Define variable ecosys_diag_O2_saturation
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'ecosys_diag_O2_saturation'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol O2 m^{-3}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Surface O2 Saturation')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_O2_saturation', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_O2_saturation', r1Ptr)

! Define variable ecosys_diag_xkw
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'ecosys_diag_xkw'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Schmidt Number Independent Piston Velocity Factor')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_xkw', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_xkw', r1Ptr)

! Define variable ecosys_diag_CO2star
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'ecosys_diag_CO2star'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-3}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'CO2 Star')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_CO2star', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_CO2star', r1Ptr)

! Define variable ecosys_diag_dCO2star
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'ecosys_diag_dCO2star'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-3}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'd CO2 Star')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_dCO2star', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_dCO2star', r1Ptr)

! Define variable ecosys_diag_pCO2surface
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'ecosys_diag_pCO2surface'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'ppmv')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Surface pCO2')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_pCO2surface', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_pCO2surface', r1Ptr)

! Define variable ecosys_diag_dpCO2
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'ecosys_diag_dpCO2'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'ppmv')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'd Surface pCO2')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_dpCO2', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_dpCO2', r1Ptr)

! Define variable ecosys_diag_CO2star_ALT_CO2
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'ecosys_diag_CO2star_ALT_CO2'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-3}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'CO2 Star for Alternate CO2')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_CO2star_ALT_CO2', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_CO2star_ALT_CO2', r1Ptr)

! Define variable ecosys_diag_dCO2star_ALT_CO2
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'ecosys_diag_dCO2star_ALT_CO2'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-3}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'd CO2 Star for Alternate CO2')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_dCO2star_ALT_CO2', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_dCO2star_ALT_CO2', r1Ptr)

! Define variable ecosys_diag_pCO2surface_ALT_CO2
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'ecosys_diag_pCO2surface_ALT_CO2'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'ppmv')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Surface pCO2 for Alternate CO2')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_pCO2surface_ALT_CO2', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_pCO2surface_ALT_CO2', r1Ptr)

! Define variable ecosys_diag_dpCO2_ALT_CO2
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'ecosys_diag_dpCO2_ALT_CO2'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'ppmv')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'd Surface pCO2 for Alternate CO2')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_dpCO2_ALT_CO2', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_dpCO2_ALT_CO2', r1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_forcing_subpool_ecosysDiagFieldsLevel2


   subroutine ocn_generate_forcing_subpool_ecosysDiagFieldsLevel3(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'ecosysDiagFieldsLevel3', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'ecosysDiagFieldsLevel3', newSubPool)

! Define variable ecosys_diag_tot_bSi_form
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'ecosys_diag_tot_bSi_form'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol Si m^{-3} s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Si Uptake')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_tot_bSi_form', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_tot_bSi_form', r1Ptr)

! Define variable ecosys_diag_SiO2_FLUX_IN
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_SiO2_FLUX_IN'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol Si m^{-3} m s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'SiO2 Flux into Cell')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_SiO2_FLUX_IN', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_SiO2_FLUX_IN', r2Ptr)

! Define variable ecosys_diag_SiO2_PROD
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_SiO2_PROD'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol Si m^{-3} s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'SiO2 Production')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_SiO2_PROD', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_SiO2_PROD', r2Ptr)

! Define variable ecosys_diag_SiO2_REMIN
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_SiO2_REMIN'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol Si m^{-3} s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'SiO2 Remineralization')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_SiO2_REMIN', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_SiO2_REMIN', r2Ptr)

! Define variable ecosys_diag_dust_FLUX_IN
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_dust_FLUX_IN'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'ng m^{-2} s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Dust Flux into Cell')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_dust_FLUX_IN', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_dust_FLUX_IN', r2Ptr)

! Define variable ecosys_diag_dust_REMIN
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_dust_REMIN'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol m^{-3} s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Dust Remineralization')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_dust_REMIN', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_dust_REMIN', r2Ptr)

! Define variable ecosys_diag_P_iron_FLUX_IN
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_P_iron_FLUX_IN'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol Fe m^{-3} m s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'P_iron Flux into Cell')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_P_iron_FLUX_IN', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_P_iron_FLUX_IN', r2Ptr)

! Define variable ecosys_diag_P_iron_PROD
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_P_iron_PROD'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol Fe m^{-3} s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'P_iron Production')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_P_iron_PROD', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_P_iron_PROD', r2Ptr)

! Define variable ecosys_diag_P_iron_REMIN
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_P_iron_REMIN'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol Fe m^{-3} s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'P_iron Remineralization')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_P_iron_REMIN', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_P_iron_REMIN', r2Ptr)

! Define variable ecosys_diag_DOC_prod
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_DOC_prod'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-3} s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'DOC Production')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_DOC_prod', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_DOC_prod', r2Ptr)

! Define variable ecosys_diag_DOC_remin
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_DOC_remin'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-3} s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'DOC Remineralization')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_DOC_remin', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_DOC_remin', r2Ptr)

! Define variable ecosys_diag_DON_prod
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_DON_prod'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol N m^{-3} s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'DON Production')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_DON_prod', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_DON_prod', r2Ptr)

! Define variable ecosys_diag_DON_remin
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_DON_remin'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol N m^{-3} s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'DON Remineralization')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_DON_remin', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_DON_remin', r2Ptr)

! Define variable ecosys_diag_DOP_prod
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_DOP_prod'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol P m^{-3} s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'DOP Production')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_DOP_prod', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_DOP_prod', r2Ptr)

! Define variable ecosys_diag_DOP_remin
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_DOP_remin'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol P m^{-3} s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'DOP Remineralization')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_DOP_remin', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_DOP_remin', r2Ptr)

! Define variable ecosys_diag_DOFe_prod
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_DOFe_prod'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol Fe m^{-3} s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'DOFe Production')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_DOFe_prod', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_DOFe_prod', r2Ptr)

! Define variable ecosys_diag_DOFe_remin
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_DOFe_remin'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol Fe m^{-3} s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'DOFe Remineralization')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_DOFe_remin', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_DOFe_remin', r2Ptr)

! Define variable ecosys_diag_Fe_scavenge
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_Fe_scavenge'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol Fe m^{-3} s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Iron Scavenging')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_Fe_scavenge', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_Fe_scavenge', r2Ptr)

! Define variable ecosys_diag_Fe_scavenge_rate
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_Fe_scavenge_rate'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'year^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Iron Scavenging Rate')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_Fe_scavenge_rate', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_Fe_scavenge_rate', r2Ptr)

! Define variable ecosys_diag_DONr_remin
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_DONr_remin'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol N m^{-3} s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'DONr Remineralization')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_DONr_remin', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_DONr_remin', r2Ptr)

! Define variable ecosys_diag_DOPr_remin
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_DOPr_remin'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol P m^{-3} s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'DOPr Remineralization')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_DOPr_remin', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_DOPr_remin', r2Ptr)

! Define variable ecosys_diag_ponToSed
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_ponToSed'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol N m^{-3} m s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'N Burial Flux to Sediments')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_ponToSed', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_ponToSed', r2Ptr)

! Define variable ecosys_diag_popToSed
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_popToSed'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol P m^{-3} m s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'P Flux to Sediments')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_popToSed', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_popToSed', r2Ptr)

! Define variable ecosys_diag_bsiToSed
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_bsiToSed'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol Si m^{-3} m s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Biogenic Si Flux to Sediments')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_bsiToSed', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_bsiToSed', r2Ptr)

! Define variable ecosys_diag_dustToSed
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_dustToSed'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'kg m^{-2} s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Dust Flux to Sediments')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_dustToSed', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_dustToSed', r2Ptr)

! Define variable ecosys_diag_OtherRemin
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_OtherRemin'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-3} m s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Non-Oxic, Non-Dentr Remineralization in Sediments')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_OtherRemin', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_OtherRemin', r2Ptr)

! Define variable ecosys_diag_bSi_form
      allocate(r3Ptr(1))

! Setting up time level 1
      r3Ptr(1) % fieldName = 'ecosys_diag_bSi_form'
      r3Ptr(1) % isVarArray = .false.
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.
! Setting up dimensions
      r3Ptr(1) % dimNames(1) = 'FOUR'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nCells'
      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(1))
      allocate(r3Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'units', 'mmol Si m^{-3} s^{-1}')
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'long_name', 'Si Uptake for sp, diat, diaz, phaeo')
      r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r3Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_bSi_form', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_bSi_form', r3Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_forcing_subpool_ecosysDiagFieldsLevel3


   subroutine ocn_generate_forcing_subpool_ecosysDiagFieldsLevel4(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'ecosysDiagFieldsLevel4', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'ecosysDiagFieldsLevel4', newSubPool)

! Define variable ecosys_diag_tot_CaCO3_form_zint
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'ecosys_diag_tot_CaCO3_form_zint'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-3} m s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Total CaCO3 Formation Vertical Integral')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_tot_CaCO3_form_zint', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_tot_CaCO3_form_zint', r1Ptr)

! Define variable ecosys_diag_zsatcalc
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'ecosys_diag_zsatcalc'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Calcite Saturation Depth')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_zsatcalc', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_zsatcalc', r1Ptr)

! Define variable ecosys_diag_zsatarag
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'ecosys_diag_zsatarag'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Aragonite Saturation Depth')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_zsatarag', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_zsatarag', r1Ptr)

! Define variable ecosys_diag_CaCO3_form_zint
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_CaCO3_form_zint'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'FOUR'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-3} m s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'CaCO3 Formation Vertical Integral for sp, diat, diaz, '&
//'phaeo')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_CaCO3_form_zint', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_CaCO3_form_zint', r2Ptr)

! Define variable ecosys_diag_CaCO3_PROD
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_CaCO3_PROD'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-3} s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'CaCO3 Production')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_CaCO3_PROD', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_CaCO3_PROD', r2Ptr)

! Define variable ecosys_diag_CaCO3_REMIN
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_CaCO3_REMIN'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-3} s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'CaCO3 Remineralization')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_CaCO3_REMIN', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_CaCO3_REMIN', r2Ptr)

! Define variable ecosys_diag_tot_CaCO3_form
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_tot_CaCO3_form'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-3} s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Total CaCO3 Formation')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_tot_CaCO3_form', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_tot_CaCO3_form', r2Ptr)

! Define variable ecosys_diag_CO3
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_CO3'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-3}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Carbonate Ion Concentration')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_CO3', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_CO3', r2Ptr)

! Define variable ecosys_diag_HCO3
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_HCO3'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-3}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Bicarbonate Ion Concentration')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_HCO3', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_HCO3', r2Ptr)

! Define variable ecosys_diag_H2CO3
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_H2CO3'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-3}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Carbonic Acid Concentration')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_H2CO3', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_H2CO3', r2Ptr)

! Define variable ecosys_diag_CO3_ALT_CO2
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_CO3_ALT_CO2'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-3}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Carbonate Ion Concentration, Alternative CO2')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_CO3_ALT_CO2', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_CO3_ALT_CO2', r2Ptr)

! Define variable ecosys_diag_HCO3_ALT_CO2
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_HCO3_ALT_CO2'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-3}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Bicarbonate Ion Concentration, Alternative CO2')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_HCO3_ALT_CO2', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_HCO3_ALT_CO2', r2Ptr)

! Define variable ecosys_diag_H2CO3_ALT_CO2
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_H2CO3_ALT_CO2'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-3}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Carbonic Acid Concentration, Alternative CO2')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_H2CO3_ALT_CO2', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_H2CO3_ALT_CO2', r2Ptr)

! Define variable ecosys_diag_pH_3D_ALT_CO2
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_pH_3D_ALT_CO2'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'pH, Alternative CO2')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_pH_3D_ALT_CO2', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_pH_3D_ALT_CO2', r2Ptr)

! Define variable ecosys_diag_co3_sat_calc
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_co3_sat_calc'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-3}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'CO3 concentration at calcite saturation')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_co3_sat_calc', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_co3_sat_calc', r2Ptr)

! Define variable ecosys_diag_co3_sat_arag
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_co3_sat_arag'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-3}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'CO3 concentration at aragonite saturation')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_co3_sat_arag', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_co3_sat_arag', r2Ptr)

! Define variable ecosys_diag_CaCO3_form
      allocate(r3Ptr(1))

! Setting up time level 1
      r3Ptr(1) % fieldName = 'ecosys_diag_CaCO3_form'
      r3Ptr(1) % isVarArray = .false.
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.
! Setting up dimensions
      r3Ptr(1) % dimNames(1) = 'FOUR'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nCells'
      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(1))
      allocate(r3Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-3} s^{-1}')
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'long_name', 'CaCO3 Formation for sp, diat, diaz, phaeo')
      r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r3Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_CaCO3_form', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_CaCO3_form', r3Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_forcing_subpool_ecosysDiagFieldsLevel4


   subroutine ocn_generate_forcing_subpool_ecosysDiagFieldsLevel5(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'ecosysDiagFieldsLevel5', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'ecosysDiagFieldsLevel5', newSubPool)

! Define variable ecosys_diag_PO4_RESTORE
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_PO4_RESTORE'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol P m^{-3} s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'PO4 Restoring')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_PO4_RESTORE', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_PO4_RESTORE', r2Ptr)

! Define variable ecosys_diag_NO3_RESTORE
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_NO3_RESTORE'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol N m^{-3} s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'NO3 Restoring')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_NO3_RESTORE', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_NO3_RESTORE', r2Ptr)

! Define variable ecosys_diag_SiO3_RESTORE
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ecosys_diag_SiO3_RESTORE'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmol Si m^{-3} s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'SiO3 Restoring')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (ecosysTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ecosys_diag_SiO3_RESTORE', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ecosys_diag_SiO3_RESTORE', r2Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_forcing_subpool_ecosysDiagFieldsLevel5


   subroutine ocn_generate_forcing_subpool_DMSSeaIceCoupling(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'DMSSeaIceCoupling', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'DMSSeaIceCoupling', newSubPool)

! Define variable avgOceanSurfaceDMS
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'avgOceanSurfaceDMS'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmolS m^{-3}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Ocean Surface DMS concentration')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (DMSTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'avgOceanSurfaceDMS', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'avgOceanSurfaceDMS', r1Ptr)

! Define variable avgOceanSurfaceDMSP
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'avgOceanSurfaceDMSP'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmolS m^{-3}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Ocean Surface DMSP concentration')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (DMSTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'avgOceanSurfaceDMSP', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'avgOceanSurfaceDMSP', r1Ptr)

! Define variable iceFluxDMS
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'iceFluxDMS'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmolS m^{-2} s')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Surface DMS flux from sea ice')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (DMSTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceFluxDMS', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'iceFluxDMS', r1Ptr)

! Define variable iceFluxDMSP
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'iceFluxDMSP'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmolS m^{-2} s')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Surface DMSP flux from sea ice')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (DMSTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceFluxDMSP', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'iceFluxDMSP', r1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_forcing_subpool_DMSSeaIceCoupling


   subroutine ocn_generate_forcing_subpool_DMSFluxDiagnostics(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'DMSFluxDiagnostics', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'DMSFluxDiagnostics', newSubPool)

! Define variable dms_flux_diag_ifrac
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'dms_flux_diag_ifrac'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'none')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Ice Fraction used in DMS flux calculation')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (DMSTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'dms_flux_diag_ifrac', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'dms_flux_diag_ifrac', r1Ptr)

! Define variable dms_flux_diag_xkw
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'dms_flux_diag_xkw'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'none')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'XKW used in DMS flux calculation')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (DMSTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'dms_flux_diag_xkw', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'dms_flux_diag_xkw', r1Ptr)

! Define variable dms_flux_diag_atm_press
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'dms_flux_diag_atm_press'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'unknown')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Atm Pressure used in DMS flux calculation')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (DMSTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'dms_flux_diag_atm_press', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'dms_flux_diag_atm_press', r1Ptr)

! Define variable dms_flux_diag_pv
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'dms_flux_diag_pv'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Piston Velocity used in DMS flux calculation')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (DMSTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'dms_flux_diag_pv', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'dms_flux_diag_pv', r1Ptr)

! Define variable dms_flux_diag_schmidt
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'dms_flux_diag_schmidt'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'none')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Schmidt Number used in DMS flux calculation')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (DMSTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'dms_flux_diag_schmidt', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'dms_flux_diag_schmidt', r1Ptr)

! Define variable dms_flux_diag_sat
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'dms_flux_diag_sat'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmolS m^{3}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'DMS Saturation used in DMS flux calculation')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (DMSTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'dms_flux_diag_sat', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'dms_flux_diag_sat', r1Ptr)

! Define variable dms_flux_diag_surf
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'dms_flux_diag_surf'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmolS m^{3}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Surface DMS Values used in DMS flux calculation')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (DMSTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'dms_flux_diag_surf', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'dms_flux_diag_surf', r1Ptr)

! Define variable dms_flux_diag_ws
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'dms_flux_diag_ws'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Wind Speed used in DMS flux calculation')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (DMSTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'dms_flux_diag_ws', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'dms_flux_diag_ws', r1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_forcing_subpool_DMSFluxDiagnostics


   subroutine ocn_generate_forcing_subpool_MacroMoleculesSeaIceCoupling(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'MacroMoleculesSeaIceCoupling', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'MacroMoleculesSeaIceCoupling', newSubPool)

! Define variable avgOceanSurfaceDOC
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'avgOceanSurfaceDOC'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'TWO'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'mmolC m^{-3}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Ocean Surface Organics concentration: '&
//'(1,2)=>(polysaccharides,lipids)')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (MacroMoleculesTracersPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'avgOceanSurfaceDOC', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'avgOceanSurfaceDOC', r2Ptr)

! Define variable avgOceanSurfaceDON
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'avgOceanSurfaceDON'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmolN m^{-3}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Ocean Surface Organic Proteins concentration')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (MacroMoleculesTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'avgOceanSurfaceDON', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'avgOceanSurfaceDON', r1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_forcing_subpool_MacroMoleculesSeaIceCoupling


   subroutine ocn_generate_pool_forcing(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'forcing', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'forcing', newSubPool)

! Define var array avgTracersSurfaceValue
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group surfaceValues
! Define constituent var avgTemperatureSurfaceValue
! My Packages are forwardMode;analysisMode
      if (forwardModeActive .or. analysisModeActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgTemperatureSurfaceValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'surfaceValues_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_avgTemperatureSurfaceValue', -1)
           end if
      end if
! Define constituent var avgSalinitySurfaceValue
! My packages are forwardMode;analysisMode
      if (forwardModeActive .or. analysisModeActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgSalinitySurfaceValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'surfaceValues_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgSalinitySurfaceValue', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'surfaceValues_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'surfaceValues_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'surfaceValues_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_avgTracersSurfaceValue', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'avgTracersSurfaceValue'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgTemperatureSurfaceValue', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgTemperatureSurfaceValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgSalinitySurfaceValue', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgSalinitySurfaceValue'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_avgTracersSurfaceValue'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgTemperatureSurfaceValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Time averaged potential temperature '&
//'extrapolated to ocean surface')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'degrees Celsius')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgTemperatureSurfaceValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgSalinitySurfaceValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Time averaged salinity extrapolated to ocean '&
//'surface')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'PSU')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgSalinitySurfaceValue'
      end if
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'avgTracersSurfaceValue', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'avgTracersSurfaceValue', r2Ptr)

! Define var array avgSurfaceVelocity
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group vel_zonal
! Define constituent var avgSurfaceVelocityZonal
! My Packages are forwardMode;analysisMode
      if (forwardModeActive .or. analysisModeActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgSurfaceVelocityZonal', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vel_zonal_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_avgSurfaceVelocityZonal', -1)
           end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vel_zonal_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'vel_zonal_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vel_zonal_end', index_counter)
            end if
         end if
! End of group       
! Starting group vel_meridional
! Define constituent var avgSurfaceVelocityMeridional
! My Packages are forwardMode;analysisMode
      if (forwardModeActive .or. analysisModeActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgSurfaceVelocityMeridional', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vel_meridional_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_avgSurfaceVelocityMeridional', -1)
           end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vel_meridional_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'vel_meridional_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vel_meridional_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_avgSurfaceVelocity', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'avgSurfaceVelocity'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgSurfaceVelocityZonal', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgSurfaceVelocityZonal'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgSurfaceVelocityMeridional', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgSurfaceVelocityMeridional'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_avgSurfaceVelocity'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgSurfaceVelocityZonal', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Time averaged zonal surface velocity')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgSurfaceVelocityZonal'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgSurfaceVelocityMeridional', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Time averaged meridional surface velocity')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgSurfaceVelocityMeridional'
      end if
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'avgSurfaceVelocity', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'avgSurfaceVelocity', r2Ptr)

! Define var array avgSSHGradient
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group ssh_zonal
! Define constituent var avgSSHGradientZonal
! My Packages are forwardMode;analysisMode
      if (forwardModeActive .or. analysisModeActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgSSHGradientZonal', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ssh_zonal_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_avgSSHGradientZonal', -1)
           end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ssh_zonal_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'ssh_zonal_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ssh_zonal_end', index_counter)
            end if
         end if
! End of group       
! Starting group ssh_meridional
! Define constituent var avgSSHGradientMeridional
! My Packages are forwardMode;analysisMode
      if (forwardModeActive .or. analysisModeActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgSSHGradientMeridional', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ssh_meridional_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_avgSSHGradientMeridional', -1)
           end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ssh_meridional_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'ssh_meridional_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'ssh_meridional_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_avgSSHGradient', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'avgSSHGradient'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgSSHGradientZonal', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgSSHGradientZonal'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgSSHGradientMeridional', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgSSHGradientMeridional'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_avgSSHGradient'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgSSHGradientZonal', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Time averaged zonal gradient of SSH')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm m^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgSSHGradientZonal'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgSSHGradientMeridional', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Time averaged meridional gradient of SSH')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm m^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgSSHGradientMeridional'
      end if
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'avgSSHGradient', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'avgSSHGradient', r2Ptr)

! Define var array landIceInterfaceTracers
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group landIceInterfaceValues
! Define constituent var landIceInterfaceTemperature
! My Packages are landIceFluxesPKG
      if (landIceFluxesPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_landIceInterfaceTemperature', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'landIceInterfaceValues_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_landIceInterfaceTemperature', -1)
           end if
      end if
! Define constituent var landIceInterfaceSalinity
! My packages are landIceFluxesPKG
      if (landIceFluxesPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_landIceInterfaceSalinity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'landIceInterfaceValues_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_landIceInterfaceSalinity', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'landIceInterfaceValues_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'landIceInterfaceValues_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'landIceInterfaceValues_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_landIceInterfaceTracers', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'landIceInterfaceTracers'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_landIceInterfaceTemperature', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'landIceInterfaceTemperature'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_landIceInterfaceSalinity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'landIceInterfaceSalinity'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_landIceInterfaceTracers'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_landIceInterfaceTemperature', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'The temperature at the land ice-ocean '&
//'interface (the local freezing temperature)')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'C')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'landIceInterfaceTemperature'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_landIceInterfaceSalinity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'The salinity at the land ice-ocean interface')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'PSU')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'landIceInterfaceSalinity'
      end if
      r2Ptr(1) % block => block

      if (landIceFluxesPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'landIceInterfaceTracers', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'landIceInterfaceTracers', r2Ptr)

! Define var array avgLandIceBoundaryLayerTracers
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group landIceBoundaryLayerValues
! Define constituent var avgLandIceBoundaryLayerTemperature
! My Packages are landIceCouplingPKG
      if (landIceCouplingPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLandIceBoundaryLayerTemperature', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'landIceBoundaryLayerValues_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_avgLandIceBoundaryLayerTemperature', -1)
           end if
      end if
! Define constituent var avgLandIceBoundaryLayerSalinity
! My packages are landIceCouplingPKG
      if (landIceCouplingPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLandIceBoundaryLayerSalinity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'landIceBoundaryLayerValues_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLandIceBoundaryLayerSalinity', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'landIceBoundaryLayerValues_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'landIceBoundaryLayerValues_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'landIceBoundaryLayerValues_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_avgLandIceBoundaryLayerTracers', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'avgLandIceBoundaryLayerTracers'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLandIceBoundaryLayerTemperature', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgLandIceBoundaryLayerTemperature'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLandIceBoundaryLayerSalinity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgLandIceBoundaryLayerSalinity'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_avgLandIceBoundaryLayerTracers'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLandIceBoundaryLayerTemperature', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'The time-averaged temperature averaged over '&
//'the sub-ice-shelf boundary layer')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'C')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgLandIceBoundaryLayerTemperature'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLandIceBoundaryLayerSalinity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'The time-averaged salinity averaged over the '&
//'sub-ice-shelf boundary layer')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'PSU')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgLandIceBoundaryLayerSalinity'
      end if
      r2Ptr(1) % block => block

      if (landIceCouplingPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'avgLandIceBoundaryLayerTracers', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'avgLandIceBoundaryLayerTracers', r2Ptr)

! Define var array avgLandIceTracerTransferVelocities
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group landIceTransferVelocityValues
! Define constituent var avgLandIceHeatTransferVelocity
! My Packages are landIceCouplingPKG
      if (landIceCouplingPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLandIceHeatTransferVelocity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'landIceTransferVelocityValues_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_avgLandIceHeatTransferVelocity', -1)
           end if
      end if
! Define constituent var avgLandIceSaltTransferVelocity
! My packages are landIceCouplingPKG
      if (landIceCouplingPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLandIceSaltTransferVelocity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'landIceTransferVelocityValues_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLandIceSaltTransferVelocity', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'landIceTransferVelocityValues_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'landIceTransferVelocityValues_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'landIceTransferVelocityValues_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_avgLandIceTracerTransferVelocities', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'avgLandIceTracerTransferVelocities'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLandIceHeatTransferVelocity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgLandIceHeatTransferVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLandIceSaltTransferVelocity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgLandIceSaltTransferVelocity'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_avgLandIceTracerTransferVelocities'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLandIceHeatTransferVelocity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'time-averaged friction velocity times '&
//'nondimensional heat transfer coefficient')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgLandIceHeatTransferVelocity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLandIceSaltTransferVelocity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'time-averaged friction velocity times '&
//'nondimensional salt transfer coefficient')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgLandIceSaltTransferVelocity'
      end if
      r2Ptr(1) % block => block

      if (landIceCouplingPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'avgLandIceTracerTransferVelocities', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'avgLandIceTracerTransferVelocities', r2Ptr)

! Define variable surfaceStress
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'surfaceStress'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'N m^{-2}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'The component of the total surface stress on the ocean '&
//'defined at edge midpoints and pointing in the direction of the edge normal.  This field the sum of constituent stresses (e.g. '&
//'wind stress and top drag) and is used to compute a tendency in the normal velocity.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'surfaceStress', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'surfaceStress', r1Ptr)

! Define variable surfaceStressMagnitude
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'surfaceStressMagnitude'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'N m^{-2}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Magnitude of surface stress, at cell centers.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'surfaceStressMagnitude', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'surfaceStressMagnitude', r1Ptr)

! Define variable surfaceThicknessFlux
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'surfaceThicknessFlux'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Flux of mass through the ocean surface. Positive into '&
//'ocean.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'surfaceThicknessFlux', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'surfaceThicknessFlux', r1Ptr)

! Define variable surfaceThicknessFluxRunoff
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'surfaceThicknessFluxRunoff'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Flux of mass through the ocean surface due to river '&
//'runoff. Positive into ocean.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'surfaceThicknessFluxRunoff', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'surfaceThicknessFluxRunoff', r1Ptr)

! Define variable windStressZonal
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'windStressZonal'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'N m^{-2}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Zonal (eastward) component of wind stress at cell centers '&
//'from coupler. Positive eastward.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (windStressBulkPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'windStressZonal', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'windStressZonal', r1Ptr)

! Define variable windStressMeridional
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'windStressMeridional'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'N m^{-2}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Meridional (northward) component of wind stress at cell '&
//'centers from coupler. Positive northward.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (windStressBulkPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'windStressMeridional', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'windStressMeridional', r1Ptr)

! Define variable bottomDrag
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'bottomDrag'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Bottom drag Cd coefficient in cells.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (variableBottomDragPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'bottomDrag', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'bottomDrag', r1Ptr)

! Define variable nForcingGroupCounter
      allocate(i0Ptr(1))

! Setting up time level 1
      i0Ptr(1) % fieldName = 'nForcingGroupCounter'
      i0Ptr(1) % isVarArray = .false.
      i0Ptr(1) % isDecomposed = .false.
      i0Ptr(1) % hasTimeDimension = .true.
      i0Ptr(1) % defaultValue = 0
      i0Ptr(1) % scalar = 0
      allocate(i0Ptr(1) % attLists(1))
      allocate(i0Ptr(1) % attLists(1) % attList)
      i0Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i0Ptr(1) % block => block

      i0Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'nForcingGroupCounter', i0Ptr)
      call mpas_pool_add_field(block % allFields, 'nForcingGroupCounter', i0Ptr)

! Define variable forcingGroupNames
      allocate(c1Ptr(1))

! Setting up time level 1
      c1Ptr(1) % fieldName = 'forcingGroupNames'
      c1Ptr(1) % isVarArray = .false.
      c1Ptr(1) % isDecomposed = .false.
      c1Ptr(1) % hasTimeDimension = .true.
      c1Ptr(1) % isPersistent = .true.
      c1Ptr(1) % isActive = .false.
! Setting up dimensions
      c1Ptr(1) % dimNames(1) = 'nForcingGroupsMax'
      c1Ptr(1) % defaultValue = ''
      allocate(c1Ptr(1) % attLists(1))
      allocate(c1Ptr(1) % attLists(1) % attList)
      c1Ptr(1) % missingValue = MPAS_CHAR_FILLVAL
      c1Ptr(1) % block => block

      c1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'forcingGroupNames', c1Ptr)
      call mpas_pool_add_field(block % allFields, 'forcingGroupNames', c1Ptr)

! Define variable forcingGroupRestartTimes
      allocate(c1Ptr(1))

! Setting up time level 1
      c1Ptr(1) % fieldName = 'forcingGroupRestartTimes'
      c1Ptr(1) % isVarArray = .false.
      c1Ptr(1) % isDecomposed = .false.
      c1Ptr(1) % hasTimeDimension = .true.
      c1Ptr(1) % isPersistent = .true.
      c1Ptr(1) % isActive = .false.
! Setting up dimensions
      c1Ptr(1) % dimNames(1) = 'nForcingGroupsMax'
      c1Ptr(1) % defaultValue = ''
      allocate(c1Ptr(1) % attLists(1))
      allocate(c1Ptr(1) % attLists(1) % attList)
      c1Ptr(1) % missingValue = MPAS_CHAR_FILLVAL
      c1Ptr(1) % block => block

      c1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'forcingGroupRestartTimes', c1Ptr)
      call mpas_pool_add_field(block % allFields, 'forcingGroupRestartTimes', c1Ptr)

! Define variable seaIcePressure
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'seaIcePressure'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'Pa')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Pressure at the sea surface due to sea ice.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'seaIcePressure', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'seaIcePressure', r1Ptr)

! Define variable atmosphericPressure
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'atmosphericPressure'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'Pa')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Pressure at the sea surface due to the atmosphere.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'atmosphericPressure', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'atmosphericPressure', r1Ptr)

! Define variable seaIceEnergy
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'seaIceEnergy'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'J m^{-2}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Energy per unit area trapped in frazil ice formation. '&
//'Always $\ge$ 0.0.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (frazilIceActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'seaIceEnergy', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'seaIceEnergy', r1Ptr)

! Define variable penetrativeTemperatureFlux
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'penetrativeTemperatureFlux'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', '^\circ C m s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Penetrative temperature flux at the surface due to solar '&
//'radiation. Positive is into the ocean.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'penetrativeTemperatureFlux', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'penetrativeTemperatureFlux', r1Ptr)

! Define variable fractionAbsorbed
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'fractionAbsorbed'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'fractional')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Divergence of transmission through interfaces of surface '&
//'fluxes below the surface layer at cell centers. These are not applied to short wave.')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'fractionAbsorbed', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'fractionAbsorbed', r2Ptr)

! Define variable fractionAbsorbedRunoff
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'fractionAbsorbedRunoff'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'fractional')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Divergence of transmission through interfaces of surface '&
//'fluxes below the surface layer at cell centers. These are applied only to river runoff.')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'fractionAbsorbedRunoff', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'fractionAbsorbedRunoff', r2Ptr)

! Define variable latentHeatFlux
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'latentHeatFlux'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'W m^{-2}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Latent heat flux at cell centers from coupler. Positive '&
//'into the ocean.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (activeTracersBulkRestoringPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'latentHeatFlux', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'latentHeatFlux', r1Ptr)

! Define variable sensibleHeatFlux
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'sensibleHeatFlux'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'W m^{-2}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Sensible heat flux at cell centers from coupler. Positive '&
//'into the ocean.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (activeTracersBulkRestoringPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'sensibleHeatFlux', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'sensibleHeatFlux', r1Ptr)

! Define variable longWaveHeatFluxUp
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'longWaveHeatFluxUp'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'W m^{-2}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Upward long wave heat flux at cell centers from coupler. '&
//'Positive into the ocean.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (activeTracersBulkRestoringPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'longWaveHeatFluxUp', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'longWaveHeatFluxUp', r1Ptr)

! Define variable longWaveHeatFluxDown
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'longWaveHeatFluxDown'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'W m^{-2}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Downward long wave heat flux at cell centers from coupler. '&
//'Positive into the ocean.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (activeTracersBulkRestoringPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'longWaveHeatFluxDown', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'longWaveHeatFluxDown', r1Ptr)

! Define variable seaIceHeatFlux
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'seaIceHeatFlux'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'W m^{-2}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Sea ice heat flux at cell centers from coupler. Positive '&
//'into the ocean.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (activeTracersBulkRestoringPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'seaIceHeatFlux', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'seaIceHeatFlux', r1Ptr)

! Define variable icebergHeatFlux
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'icebergHeatFlux'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'W m^{-2}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Iceberg heat flux at cell centers from coupler. Positive '&
//'into the ocean.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (activeTracersBulkRestoringPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'icebergHeatFlux', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'icebergHeatFlux', r1Ptr)

! Define variable shortWaveHeatFlux
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'shortWaveHeatFlux'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'W m^{-2}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Short wave flux at cell centers from coupler. Positive '&
//'into the ocean.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (activeTracersBulkRestoringPKGActive .or. ecosysTracersPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'shortWaveHeatFlux', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'shortWaveHeatFlux', r1Ptr)

! Define variable evaporationFlux
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'evaporationFlux'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'kg m^{-2} s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Evaporation flux at cell centers from coupler. Positive '&
//'into the ocean.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'evaporationFlux', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'evaporationFlux', r1Ptr)

! Define variable seaIceSalinityFlux
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'seaIceSalinityFlux'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'kg m^{-2} s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Sea ice salinity flux at cell centers from coupler. '&
//'Positive into the ocean.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (activeTracersBulkRestoringPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'seaIceSalinityFlux', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'seaIceSalinityFlux', r1Ptr)

! Define variable seaIceFreshWaterFlux
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'seaIceFreshWaterFlux'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'kg m^{-2} s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Fresh water flux from sea ice at cell centers from '&
//'coupler. Positive into the ocean.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (thicknessBulkPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'seaIceFreshWaterFlux', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'seaIceFreshWaterFlux', r1Ptr)

! Define variable icebergFreshWaterFlux
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'icebergFreshWaterFlux'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'kg m^{-2} s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Fresh water flux from iceberg melt at cell centers from '&
//'coupler. Positive into the ocean.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (thicknessBulkPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'icebergFreshWaterFlux', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'icebergFreshWaterFlux', r1Ptr)

! Define variable riverRunoffFlux
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'riverRunoffFlux'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'kg m^{-2} s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Fresh water flux from river runoff at cell centers from '&
//'coupler. Positive into the ocean.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (thicknessBulkPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'riverRunoffFlux', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'riverRunoffFlux', r1Ptr)

! Define variable removedRiverRunoffFlux
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'removedRiverRunoffFlux'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'kg m^{-2} s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Fresh water flux from river runoff from the coupler that '&
//'was removed due to config_remove_AIS_coupler_runoff option. Positive into the ocean.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (thicknessBulkPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'removedRiverRunoffFlux', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'removedRiverRunoffFlux', r1Ptr)

! Define variable totalRemovedRiverRunoffFlux
      allocate(r0Ptr(1))

! Setting up time level 1
      r0Ptr(1) % fieldName = 'totalRemovedRiverRunoffFlux'
      r0Ptr(1) % isVarArray = .false.
      r0Ptr(1) % isDecomposed = .false.
      r0Ptr(1) % hasTimeDimension = .true.
      r0Ptr(1) % defaultValue = 0.0
      r0Ptr(1) % scalar = 0.0
      allocate(r0Ptr(1) % attLists(1))
      allocate(r0Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r0Ptr(1) % attLists(1) % attList, 'units', 'kg s^{-1}')
      call mpas_add_att(r0Ptr(1) % attLists(1) % attList, 'long_name', 'Global sum of fresh water flux from river runoff from the '&
//'coupler that was removed due to config_remove_AIS_coupler_runoff option. Positive into the ocean.')
      r0Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r0Ptr(1) % block => block

      if (thicknessBulkPKGActive) then
         r0Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'totalRemovedRiverRunoffFlux', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'totalRemovedRiverRunoffFlux', r0Ptr)

! Define variable iceRunoffFlux
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'iceRunoffFlux'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'kg m^{-2} s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Fresh water flux from ice runoff at cell centers from '&
//'coupler. Positive into the ocean.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (thicknessBulkPKGActive .or. activeTracersBulkRestoringPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'iceRunoffFlux', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'iceRunoffFlux', r1Ptr)

! Define variable removedIceRunoffFlux
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'removedIceRunoffFlux'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'kg m^{-2} s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Fresh water flux from ice runoff from the coupler that was '&
//'removed due to config_remove_AIS_coupler_runoff option. Positive into the ocean.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (thicknessBulkPKGActive .or. activeTracersBulkRestoringPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'removedIceRunoffFlux', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'removedIceRunoffFlux', r1Ptr)

! Define variable totalRemovedIceRunoffFlux
      allocate(r0Ptr(1))

! Setting up time level 1
      r0Ptr(1) % fieldName = 'totalRemovedIceRunoffFlux'
      r0Ptr(1) % isVarArray = .false.
      r0Ptr(1) % isDecomposed = .false.
      r0Ptr(1) % hasTimeDimension = .true.
      r0Ptr(1) % defaultValue = 0.0
      r0Ptr(1) % scalar = 0.0
      allocate(r0Ptr(1) % attLists(1))
      allocate(r0Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r0Ptr(1) % attLists(1) % attList, 'units', 'kg s^{-1}')
      call mpas_add_att(r0Ptr(1) % attLists(1) % attList, 'long_name', 'Global sum of fresh water flux from ice runoff from the '&
//'coupler that was removed due to config_remove_AIS_coupler_runoff option. Positive into the ocean.')
      r0Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r0Ptr(1) % block => block

      if (thicknessBulkPKGActive .or. activeTracersBulkRestoringPKGActive) then
         r0Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'totalRemovedIceRunoffFlux', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'totalRemovedIceRunoffFlux', r0Ptr)

! Define variable rainFlux
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'rainFlux'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'kg m^{-2} s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Fresh water flux from rain at cell centers from coupler. '&
//'Positive into the ocean.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'rainFlux', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'rainFlux', r1Ptr)

! Define variable snowFlux
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'snowFlux'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'kg m^{-2} s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Fresh water flux from snow at cell centers from coupler. '&
//'Positive into the ocean.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (activeTracersBulkRestoringPKGActive .or. thicknessBulkPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'snowFlux', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'snowFlux', r1Ptr)

! Define variable iceFraction
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'iceFraction'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'fractional')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Fraction of sea ice coverage at cell centers from coupler. '&
//'Positive into the ocean.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'iceFraction', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'iceFraction', r1Ptr)

! Define variable windSpeed10m
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'windSpeed10m'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Wind speed at 10 meter.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'windSpeed10m', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'windSpeed10m', r1Ptr)

! Define variable nAccumulatedCoupled
      allocate(i0Ptr(1))

! Setting up time level 1
      i0Ptr(1) % fieldName = 'nAccumulatedCoupled'
      i0Ptr(1) % isVarArray = .false.
      i0Ptr(1) % isDecomposed = .false.
      i0Ptr(1) % hasTimeDimension = .true.
      i0Ptr(1) % defaultValue = 0
      i0Ptr(1) % scalar = 0
      allocate(i0Ptr(1) % attLists(1))
      allocate(i0Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i0Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i0Ptr(1) % attLists(1) % attList, 'long_name', 'Number of accumulations in time averaging of coupler '&
//'fields')
      i0Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i0Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         i0Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'nAccumulatedCoupled', i0Ptr)
      call mpas_pool_add_field(block % allFields, 'nAccumulatedCoupled', i0Ptr)

! Define variable filteredSSHGradientZonal
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'filteredSSHGradientZonal'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm m^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Time filtered zonal gradient of SSH')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'filteredSSHGradientZonal', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'filteredSSHGradientZonal', r1Ptr)

! Define variable filteredSSHGradientMeridional
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'filteredSSHGradientMeridional'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm m^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Time filtered meridional gradient of SSH')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'filteredSSHGradientMeridional', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'filteredSSHGradientMeridional', r1Ptr)

! Define variable landIceFraction
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'landIceFraction'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'The fraction of each cell covered by land ice')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (landIcePressurePKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'landIceFraction', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'landIceFraction', r1Ptr)

! Define variable landIceMask
      allocate(i1Ptr(1))

! Setting up time level 1
      i1Ptr(1) % fieldName = 'landIceMask'
      i1Ptr(1) % isVarArray = .false.
      i1Ptr(1) % isDecomposed = .true.
      i1Ptr(1) % hasTimeDimension = .true.
      i1Ptr(1) % isPersistent = .true.
      i1Ptr(1) % isActive = .false.
! Setting up dimensions
      i1Ptr(1) % dimNames(1) = 'nCells'
      i1Ptr(1) % defaultValue = 0
      allocate(i1Ptr(1) % attLists(1))
      allocate(i1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'long_name', 'Mask indicating where land-ice is present (1) or absent '&
//'(0)')
      i1Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i1Ptr(1) % block => block

      if (landIcePressurePKGActive) then
         i1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'landIceMask', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'landIceMask', i1Ptr)

! Define variable landIcePressure
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'landIcePressure'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'Pa')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Pressure defined at the sea surface due to land ice.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (landIcePressurePKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'landIcePressure', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'landIcePressure', r1Ptr)

! Define variable landIceDraft
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'landIceDraft'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'The elevation of the interface between land ice and the '&
//'ocean.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (landIcePressurePKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'landIceDraft', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'landIceDraft', r1Ptr)

! Define variable landIceSurfaceTemperature
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'landIceSurfaceTemperature'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'C')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'temperature at the surface of land ice')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (landIceFluxesPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'landIceSurfaceTemperature', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'landIceSurfaceTemperature', r1Ptr)

! Define variable landIceFreshwaterFlux
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'landIceFreshwaterFlux'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'kg m^{-2} s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Flux of mass through the ocean surface. Positive into '&
//'ocean.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (landIceFluxesPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'landIceFreshwaterFlux', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'landIceFreshwaterFlux', r1Ptr)

! Define variable landIceHeatFlux
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'landIceHeatFlux'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'W m^{-2}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Flux of heat into the ocean at land ice-ocean interface. '&
//'Positive into ocean.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (landIceFluxesPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'landIceHeatFlux', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'landIceHeatFlux', r1Ptr)

! Define variable heatFluxToLandIce
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'heatFluxToLandIce'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'W m^{-2}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Flux of heat out of ice at land ice-ocean interface. '&
//'Positive into ocean.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (landIceFluxesPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'heatFluxToLandIce', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'heatFluxToLandIce', r1Ptr)

! Define variable avgEffectiveDensityInLandIce
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'avgEffectiveDensityInLandIce'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'kg m^{-3}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'The time-averaged effective ocean density within ice '&
//'shelves based on Archimedes'' principle.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (landIceCouplingPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'avgEffectiveDensityInLandIce', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'avgEffectiveDensityInLandIce', r1Ptr)

! Define variable tidalInputMask
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'tidalInputMask'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Input mask for application of tidal forcing where 1 is '&
//'applied tidal forcing')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (tidalForcingActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'tidalInputMask', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'tidalInputMask', r1Ptr)

! Define variable tidalBCValue
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'tidalBCValue'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Value of ssh height in cell for tidal boundary condition')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (tidalForcingActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'tidalBCValue', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'tidalBCValue', r1Ptr)

! Define variable tidalLayerThicknessTendency
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'tidalLayerThicknessTendency'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'layer thickness tendency due to tidal forcing')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (tidalForcingActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'tidalLayerThicknessTendency', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'tidalLayerThicknessTendency', r2Ptr)

! Define variable frazilLayerThicknessTendency
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'frazilLayerThicknessTendency'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'layer thickness tendency due to frazil processes')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (frazilIceActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'frazilLayerThicknessTendency', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'frazilLayerThicknessTendency', r2Ptr)

! Define variable frazilTemperatureTendency
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'frazilTemperatureTendency'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm C s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'temperature tendency due to frazil processes')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (frazilIceActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'frazilTemperatureTendency', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'frazilTemperatureTendency', r2Ptr)

! Define variable frazilSalinityTendency
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'frazilSalinityTendency'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm PSU s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'salinity tendency due to frazil processes')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (frazilIceActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'frazilSalinityTendency', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'frazilSalinityTendency', r2Ptr)

! Define variable frazilSurfacePressure
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'frazilSurfacePressure'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'Pa')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'surface pressure forcing due to weight of frazil ice')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (frazilIceActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'frazilSurfacePressure', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'frazilSurfacePressure', r1Ptr)

! Define variable tidalPotentialEta
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'tidalPotentialEta'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Equilibrium tidal potential')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (forwardModeActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'tidalPotentialEta', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'tidalPotentialEta', r1Ptr)

! Define variable nTidalPotentialConstituents
      allocate(i0Ptr(1))

! Setting up time level 1
      i0Ptr(1) % fieldName = 'nTidalPotentialConstituents'
      i0Ptr(1) % isVarArray = .false.
      i0Ptr(1) % isDecomposed = .false.
      i0Ptr(1) % hasTimeDimension = .true.
      i0Ptr(1) % defaultValue = 0
      i0Ptr(1) % scalar = 0
      allocate(i0Ptr(1) % attLists(1))
      allocate(i0Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i0Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i0Ptr(1) % attLists(1) % attList, 'long_name', 'Number of tidal constituents')
      i0Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i0Ptr(1) % block => block

      if (tidalPotentialForcingPKGActive) then
         i0Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'nTidalPotentialConstituents', i0Ptr)
      call mpas_pool_add_field(block % allFields, 'nTidalPotentialConstituents', i0Ptr)

! Define variable tidalPotentialConstituentFrequency
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'tidalPotentialConstituentFrequency'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .false.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'maxTidalConstituents'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 's^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Frequency of tidal constituents')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (tidalPotentialForcingPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'tidalPotentialConstituentFrequency', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'tidalPotentialConstituentFrequency', r1Ptr)

! Define variable tidalPotentialConstituentAmplitude
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'tidalPotentialConstituentAmplitude'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .false.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'maxTidalConstituents'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Amplitude of tidal constituents')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (tidalPotentialForcingPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'tidalPotentialConstituentAmplitude', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'tidalPotentialConstituentAmplitude', r1Ptr)

! Define variable tidalPotentialConstituentLoveNumbers
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'tidalPotentialConstituentLoveNumbers'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .false.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'maxTidalConstituents'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Love number combinations for tidal constituents')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (tidalPotentialForcingPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'tidalPotentialConstituentLoveNumbers', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'tidalPotentialConstituentLoveNumbers', r1Ptr)

! Define variable tidalPotentialConstituentNodalAmplitude
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'tidalPotentialConstituentNodalAmplitude'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .false.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'maxTidalConstituents'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Amplitude nodal factor for tidal constituents')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (tidalPotentialForcingPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'tidalPotentialConstituentNodalAmplitude', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'tidalPotentialConstituentNodalAmplitude', r1Ptr)

! Define variable tidalPotentialConstituentNodalPhase
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'tidalPotentialConstituentNodalPhase'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .false.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'maxTidalConstituents'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 's^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Phase nodal factor for tidal constituents')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (tidalPotentialForcingPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'tidalPotentialConstituentNodalPhase', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'tidalPotentialConstituentNodalPhase', r1Ptr)

! Define variable tidalPotentialConstituentAstronomical
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'tidalPotentialConstituentAstronomical'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .false.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'maxTidalConstituents'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 's^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Astronomical argument for tidal constituents')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (tidalPotentialForcingPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'tidalPotentialConstituentAstronomical', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'tidalPotentialConstituentAstronomical', r1Ptr)

! Define variable tidalPotentialConstituentType
      allocate(i1Ptr(1))

! Setting up time level 1
      i1Ptr(1) % fieldName = 'tidalPotentialConstituentType'
      i1Ptr(1) % isVarArray = .false.
      i1Ptr(1) % isDecomposed = .false.
      i1Ptr(1) % hasTimeDimension = .true.
      i1Ptr(1) % isPersistent = .true.
      i1Ptr(1) % isActive = .false.
! Setting up dimensions
      i1Ptr(1) % dimNames(1) = 'maxTidalConstituents'
      i1Ptr(1) % defaultValue = 0
      allocate(i1Ptr(1) % attLists(1))
      allocate(i1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'long_name', 'Spieces code for tidal constituents: long-period = 0, '&
//'diurnal = 1, semi-diurnal = 2')
      i1Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i1Ptr(1) % block => block

      if (tidalPotentialForcingPKGActive) then
         i1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'tidalPotentialConstituentType', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'tidalPotentialConstituentType', i1Ptr)

! Define variable tidalPotentialLatitudeFunction
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'tidalPotentialLatitudeFunction'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nCells'
      r2Ptr(1) % dimNames(2) = 'R3'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Latitude function for tidal constituents: long-period = '&
//'3\sin^2(\phi)-1, diurnal = \sin(2\phi), semi-diurnal = \cos^2(\phi)')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (tidalPotentialForcingPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'tidalPotentialLatitudeFunction', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'tidalPotentialLatitudeFunction', r2Ptr)

! Define variable tidalPotentialZMid
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'tidalPotentialZMid'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'zMid - Equilibrium tidal potential in RK4')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (tidalPotentialForcingPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'tidalPotentialZMid', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'tidalPotentialZMid', r2Ptr)

! Define variable sshSubcycleCurWithTides
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'sshSubcycleCurWithTides'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'SSH - tidal potential in split explicit ')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (tidalPotentialForcingPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'sshSubcycleCurWithTides', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'sshSubcycleCurWithTides', r1Ptr)

! Define variable sshSubcycleNewWithTides
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'sshSubcycleNewWithTides'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'SSH - tidal potential in split explicit ')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (tidalPotentialForcingPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'sshSubcycleNewWithTides', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'sshSubcycleNewWithTides', r1Ptr)


      call ocn_generate_forcing_subpool_tracersSurfaceFlux(block, newSubPool, dimensionPool, packagePool)
      call ocn_generate_forcing_subpool_tracersSurfaceRestoringFields(block, newSubPool, dimensionPool, packagePool)
      call ocn_generate_forcing_subpool_tracersInteriorRestoringFields(block, newSubPool, dimensionPool, packagePool)
      call ocn_generate_forcing_subpool_tracersExponentialDecayFields(block, newSubPool, dimensionPool, packagePool)
      call ocn_generate_forcing_subpool_tracersIdealAgeFields(block, newSubPool, dimensionPool, packagePool)
      call ocn_generate_forcing_subpool_tracersTTDFields(block, newSubPool, dimensionPool, packagePool)
      call ocn_generate_forcing_subpool_ecosysAuxiliary(block, newSubPool, dimensionPool, packagePool)
      call ocn_generate_forcing_subpool_ecosysSeaIceCoupling(block, newSubPool, dimensionPool, packagePool)
      call ocn_generate_forcing_subpool_ecosysDiagFieldsLevel1(block, newSubPool, dimensionPool, packagePool)
      call ocn_generate_forcing_subpool_ecosysDiagFieldsLevel2(block, newSubPool, dimensionPool, packagePool)
      call ocn_generate_forcing_subpool_ecosysDiagFieldsLevel3(block, newSubPool, dimensionPool, packagePool)
      call ocn_generate_forcing_subpool_ecosysDiagFieldsLevel4(block, newSubPool, dimensionPool, packagePool)
      call ocn_generate_forcing_subpool_ecosysDiagFieldsLevel5(block, newSubPool, dimensionPool, packagePool)
      call ocn_generate_forcing_subpool_DMSSeaIceCoupling(block, newSubPool, dimensionPool, packagePool)
      call ocn_generate_forcing_subpool_DMSFluxDiagnostics(block, newSubPool, dimensionPool, packagePool)
      call ocn_generate_forcing_subpool_MacroMoleculesSeaIceCoupling(block, newSubPool, dimensionPool, packagePool)

      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_pool_forcing


   subroutine ocn_generate_pool_timeVaryingForcing(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'timeVaryingForcing', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'timeVaryingForcing', newSubPool)

! Define variable windSpeedU
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'windSpeedU'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm/s')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Zonal (eastward) component of wind speed at cell centers '&
//'from coupler. Positive easthward.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (timeVaryingAtmosphericForcingPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'windSpeedU', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'windSpeedU', r1Ptr)

! Define variable windSpeedV
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'windSpeedV'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm/s')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Meridional (northward) component of wind speed at cell '&
//'centers from coupler. Positive northward.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (timeVaryingAtmosphericForcingPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'windSpeedV', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'windSpeedV', r1Ptr)

! Define variable windSpeedMagnitude
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'windSpeedMagnitude'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm/s')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Magnitude of wind speed at cell centers from coupler.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (timeVaryingAtmosphericForcingPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'windSpeedMagnitude', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'windSpeedMagnitude', r1Ptr)

! Define variable atmosPressure
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'atmosPressure'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'Pa')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Pressure at the sea surface due to the atmosphere.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (timeVaryingAtmosphericForcingPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'atmosPressure', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'atmosPressure', r1Ptr)

! Define variable landIceFractionForcing
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'landIceFractionForcing'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'The fraction of each cell covered by land ice')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (timeVaryingLandIceForcingPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'landIceFractionForcing', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'landIceFractionForcing', r1Ptr)

! Define variable landIcePressureForcing
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'landIcePressureForcing'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'Pa')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Pressure defined at the sea surface due to land ice.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (timeVaryingLandIceForcingPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'landIcePressureForcing', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'landIcePressureForcing', r1Ptr)

! Define variable landIceDraftForcing
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'landIceDraftForcing'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'The elevation of the interface between land ice and the '&
//'ocean.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (timeVaryingLandIceForcingPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'landIceDraftForcing', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'landIceDraftForcing', r1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_pool_timeVaryingForcing


   subroutine ocn_generate_pool_scratch(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'scratch', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'scratch', newSubPool)

! Define var array delsq_tracer
      allocate(r3Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group dynamics
! Define constituent var delsq_temperature
! My Packages are (null)
      index_counter = index_counter + 1
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'index_delsq_temperature', index_counter)
      end if
      group_counter = group_counter + 1
      if (.not. group_started) then
         group_start = index_counter
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'dynamics_start', group_start)
         end if
         group_started = .true.
      end if
! Define constituent var delsq_salinity
! My packages are (null)
      index_counter = index_counter + 1
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'index_delsq_salinity', index_counter)
      end if
      group_counter = group_counter + 1
      if (.not. group_started) then
         group_start = index_counter
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'dynamics_start', group_start)
         end if
         group_started = .true.
      end if
! Define constituent var delsq_tracer1
! My packages are (null)
      index_counter = index_counter + 1
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'index_delsq_tracer1', index_counter)
      end if
      group_counter = group_counter + 1
      if (.not. group_started) then
         group_start = index_counter
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'dynamics_start', group_start)
         end if
         group_started = .true.
      end if
      if (.not. group_started) then
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'dynamics_start', -1)
            call mpas_pool_add_dimension(newSubPool, 'dynamics_end', -1)
         end if
      else
         group_started = .false.
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'dynamics_end', index_counter)
         end if
      end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_delsq_tracer', numConstituents)
      end if
! Defining time level 1
      allocate( r3Ptr(1) % constituentNames(numConstituents) )
      r3Ptr(1) % fieldName = 'delsq_tracer'
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .false.
      r3Ptr(1) % isVarArray = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_delsq_temperature', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'delsq_temperature'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_delsq_salinity', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'delsq_salinity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_delsq_tracer1', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'delsq_tracer1'
      end if

! Setup dimensions for       
      r3Ptr(1) % dimNames(1) = 'num_delsq_tracer'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nCells'

      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(size(r3Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r3Ptr(1) % constituentNames, dim=1)
         allocate(r3Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_delsq_temperature', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'potential temperature')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'degrees Celsius')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'delsq_temperature'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_delsq_salinity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'salinity')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'grams salt per kilogram seawater')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'delsq_salinity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_delsq_tracer1', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'tracer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'na')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'delsq_tracer1'
      end if
      r3Ptr(1) % block => block

            r3Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'delsq_tracer', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'delsq_tracer', r3Ptr)

! Define variable normalThicknessFlux
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'normalThicknessFlux'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nEdges'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm^{2} s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Flux of thickness through an edge')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'normalThicknessFlux', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'normalThicknessFlux', r2Ptr)

! Define variable normalThicknessFluxSum
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'normalThicknessFluxSum'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .false.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm^{2} s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Flux of thickness through an edge over full column, '&
//'sum(h*u)')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'normalThicknessFluxSum', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'normalThicknessFluxSum', r1Ptr)

! Define variable layerThicknessSumEdge
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'layerThicknessSumEdge'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .false.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'total thickness at edge, sum(h)')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'layerThicknessSumEdge', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'layerThicknessSumEdge', r1Ptr)

! Define variable vorticityGradientTangentialComponent
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'vorticityGradientTangentialComponent'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nEdges'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 's^{-1} m^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'gradient of vorticity in the tangent direction (positive '&
//'points from vertex1 to vertex2)')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'vorticityGradientTangentialComponent', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'vorticityGradientTangentialComponent', r2Ptr)

! Define variable vorticityGradientNormalComponent
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'vorticityGradientNormalComponent'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nEdges'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 's^{-1} m^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'gradient of vorticity in the normal direction (positive '&
//'points from cell1 to cell2)')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'vorticityGradientNormalComponent', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'vorticityGradientNormalComponent', r2Ptr)

! Define variable normalizedRelativeVorticityVertex
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'normalizedRelativeVorticityVertex'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nVertices'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 's^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'curl of horizontal velocity divided by layer thickness, '&
//'defined at vertices')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'normalizedRelativeVorticityVertex', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'normalizedRelativeVorticityVertex', r2Ptr)

! Define variable normalizedPlanetaryVorticityVertex
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'normalizedPlanetaryVorticityVertex'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nVertices'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 's^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'earth''s rotational rate (Coriolis parameter, f) divided '&
//'by layer thickness, defined at vertices')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'normalizedPlanetaryVorticityVertex', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'normalizedPlanetaryVorticityVertex', r2Ptr)

! Define variable kineticEnergyVertex
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'kineticEnergyVertex'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nVertices'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm^2 s^{-2}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'kinetic energy of horizonal velocity defined at vertices')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'kineticEnergyVertex', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'kineticEnergyVertex', r2Ptr)

! Define variable kineticEnergyVertexOnCells
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'kineticEnergyVertexOnCells'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm^2 s^{-2}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'kinetic energy of horizonal velocity defined at vertices')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'kineticEnergyVertexOnCells', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'kineticEnergyVertexOnCells', r2Ptr)

! Define variable densitySurfaceDisplaced
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'densitySurfaceDisplaced'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'kg m^{-3}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Density computed by displacing SST and SSS to every '&
//'vertical layer within the column')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'densitySurfaceDisplaced', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'densitySurfaceDisplaced', r2Ptr)

! Define variable thermalExpansionCoeff
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'thermalExpansionCoeff'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'C^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Thermal expansion coefficient (alpha), defined as $-1/\rho '&
//'d\rho/dT$ (note negative sign).')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'thermalExpansionCoeff', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'thermalExpansionCoeff', r2Ptr)

! Define variable salineContractionCoeff
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'salineContractionCoeff'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'PSU^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Saline contraction coefficient (beta), defined as $1/\rho '&
//'d\rho/dS$. This is also called the haline contraction coefficient.')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'salineContractionCoeff', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'salineContractionCoeff', r2Ptr)

! Define variable normalVelocityTest
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'normalVelocityTest'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nEdges'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'horizonal velocity, normal component to an edge, for '&
//'testing')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'normalVelocityTest', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'normalVelocityTest', r2Ptr)

! Define variable tangentialVelocityTest
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'tangentialVelocityTest'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nEdges'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'horizonal velocity, tangential component to an edge, for '&
//'testing')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'tangentialVelocityTest', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'tangentialVelocityTest', r2Ptr)

! Define variable strainRateR3Cell
      allocate(r3Ptr(1))

! Setting up time level 1
      r3Ptr(1) % fieldName = 'strainRateR3Cell'
      r3Ptr(1) % isVarArray = .false.
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .false.
      r3Ptr(1) % isPersistent = .false.
      r3Ptr(1) % isActive = .false.
! Setting up dimensions
      r3Ptr(1) % dimNames(1) = 'SIX'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nCells'
      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(1))
      allocate(r3Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'units', 's^{-1}')
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'long_name', 'strain rate tensor at cell center, R3, in symmetric '&
//'6-index form')
      r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r3Ptr(1) % block => block

      r3Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'strainRateR3Cell', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'strainRateR3Cell', r3Ptr)

! Define variable strainRateR3CellSolution
      allocate(r3Ptr(1))

! Setting up time level 1
      r3Ptr(1) % fieldName = 'strainRateR3CellSolution'
      r3Ptr(1) % isVarArray = .false.
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .false.
      r3Ptr(1) % isPersistent = .false.
      r3Ptr(1) % isActive = .false.
! Setting up dimensions
      r3Ptr(1) % dimNames(1) = 'SIX'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nCells'
      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(1))
      allocate(r3Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'units', 's^{-1}')
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'long_name', 'strain rate solution tensor at cell center, R3, in '&
//'symmetric 6-index form')
      r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r3Ptr(1) % block => block

      r3Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'strainRateR3CellSolution', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'strainRateR3CellSolution', r3Ptr)

! Define variable strainRateR3Edge
      allocate(r3Ptr(1))

! Setting up time level 1
      r3Ptr(1) % fieldName = 'strainRateR3Edge'
      r3Ptr(1) % isVarArray = .false.
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .false.
      r3Ptr(1) % isPersistent = .false.
      r3Ptr(1) % isActive = .false.
! Setting up dimensions
      r3Ptr(1) % dimNames(1) = 'SIX'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nEdges'
      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(1))
      allocate(r3Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'units', 's^{-1}')
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'long_name', 'strain rate tensor at edge, R3, in symmetric 6-index form')
      r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r3Ptr(1) % block => block

      r3Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'strainRateR3Edge', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'strainRateR3Edge', r3Ptr)

! Define variable strainRateLonLatRCell
      allocate(r3Ptr(1))

! Setting up time level 1
      r3Ptr(1) % fieldName = 'strainRateLonLatRCell'
      r3Ptr(1) % isVarArray = .false.
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .false.
      r3Ptr(1) % isPersistent = .false.
      r3Ptr(1) % isActive = .false.
! Setting up dimensions
      r3Ptr(1) % dimNames(1) = 'SIX'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nCells'
      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(1))
      allocate(r3Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'units', 's^{-1}')
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'long_name', 'strain rate tensor at cell center, 3D, lon-lat-r in '&
//'symmetric 6-index form, {\color{red}Temporary only}')
      r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r3Ptr(1) % block => block

      r3Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'strainRateLonLatRCell', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'strainRateLonLatRCell', r3Ptr)

! Define variable strainRateLonLatRCellSolution
      allocate(r3Ptr(1))

! Setting up time level 1
      r3Ptr(1) % fieldName = 'strainRateLonLatRCellSolution'
      r3Ptr(1) % isVarArray = .false.
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .false.
      r3Ptr(1) % isPersistent = .false.
      r3Ptr(1) % isActive = .false.
! Setting up dimensions
      r3Ptr(1) % dimNames(1) = 'SIX'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nCells'
      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(1))
      allocate(r3Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'units', 's^{-1}')
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'long_name', 'strain rate tensor at cell center, 3D, lon-lat-r in '&
//'symmetric 6-index form, {\color{red}Temporary only}')
      r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r3Ptr(1) % block => block

      r3Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'strainRateLonLatRCellSolution', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'strainRateLonLatRCellSolution', r3Ptr)

! Define variable strainRateLonLatREdge
      allocate(r3Ptr(1))

! Setting up time level 1
      r3Ptr(1) % fieldName = 'strainRateLonLatREdge'
      r3Ptr(1) % isVarArray = .false.
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .false.
      r3Ptr(1) % isPersistent = .false.
      r3Ptr(1) % isActive = .false.
! Setting up dimensions
      r3Ptr(1) % dimNames(1) = 'SIX'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nEdges'
      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(1))
      allocate(r3Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'units', 's^{-1}')
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'long_name', 'strain rate tensor at edge, 3D, lon-lat-r in symmetric '&
//'6-index form, {\color{red}Temporary only}')
      r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r3Ptr(1) % block => block

      r3Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'strainRateLonLatREdge', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'strainRateLonLatREdge', r3Ptr)

! Define variable divTensorR3Cell
      allocate(r3Ptr(1))

! Setting up time level 1
      r3Ptr(1) % fieldName = 'divTensorR3Cell'
      r3Ptr(1) % isVarArray = .false.
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .false.
      r3Ptr(1) % isPersistent = .false.
      r3Ptr(1) % isActive = .false.
! Setting up dimensions
      r3Ptr(1) % dimNames(1) = 'R3'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nCells'
      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(1))
      allocate(r3Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'units', 's^{-2}')
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'long_name', 'divergence of the tensor at cell center, as an R3 vector')
      r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r3Ptr(1) % block => block

      r3Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'divTensorR3Cell', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'divTensorR3Cell', r3Ptr)

! Define variable divTensorR3CellSolution
      allocate(r3Ptr(1))

! Setting up time level 1
      r3Ptr(1) % fieldName = 'divTensorR3CellSolution'
      r3Ptr(1) % isVarArray = .false.
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .false.
      r3Ptr(1) % isPersistent = .false.
      r3Ptr(1) % isActive = .false.
! Setting up dimensions
      r3Ptr(1) % dimNames(1) = 'R3'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nCells'
      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(1))
      allocate(r3Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'units', 's^{-2}')
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'long_name', 'divergence of the tensor solution at cell center, as an R3 '&
//'vector')
      r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r3Ptr(1) % block => block

      r3Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'divTensorR3CellSolution', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'divTensorR3CellSolution', r3Ptr)

! Define variable divTensorLonLatRCell
      allocate(r3Ptr(1))

! Setting up time level 1
      r3Ptr(1) % fieldName = 'divTensorLonLatRCell'
      r3Ptr(1) % isVarArray = .false.
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .false.
      r3Ptr(1) % isPersistent = .false.
      r3Ptr(1) % isActive = .false.
! Setting up dimensions
      r3Ptr(1) % dimNames(1) = 'R3'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nCells'
      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(1))
      allocate(r3Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'units', 's^{-2}')
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'long_name', 'divergence of the tensor at cell center, as a lon-lat-r '&
//'vector')
      r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r3Ptr(1) % block => block

      r3Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'divTensorLonLatRCell', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'divTensorLonLatRCell', r3Ptr)

! Define variable divTensorLonLatRCellSolution
      allocate(r3Ptr(1))

! Setting up time level 1
      r3Ptr(1) % fieldName = 'divTensorLonLatRCellSolution'
      r3Ptr(1) % isVarArray = .false.
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .false.
      r3Ptr(1) % isPersistent = .false.
      r3Ptr(1) % isActive = .false.
! Setting up dimensions
      r3Ptr(1) % dimNames(1) = 'R3'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nCells'
      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(1))
      allocate(r3Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'units', 's^{-2}')
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'long_name', 'divergence of the tensor at cell center, as a lon-lat-r '&
//'vector, solution')
      r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r3Ptr(1) % block => block

      r3Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'divTensorLonLatRCellSolution', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'divTensorLonLatRCellSolution', r3Ptr)

! Define variable outerProductEdge
      allocate(r3Ptr(1))

! Setting up time level 1
      r3Ptr(1) % fieldName = 'outerProductEdge'
      r3Ptr(1) % isVarArray = .false.
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .false.
      r3Ptr(1) % isPersistent = .false.
      r3Ptr(1) % isActive = .false.
! Setting up dimensions
      r3Ptr(1) % dimNames(1) = 'SIX'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nEdges'
      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(1))
      allocate(r3Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'units', 'm^2 s^{-1}')
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'long_name', 'Outer product, $u_e \otimes n_e$, at each edge.')
      r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r3Ptr(1) % block => block

      r3Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'outerProductEdge', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'outerProductEdge', r3Ptr)

! Define variable normalVectorEdge
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'normalVectorEdge'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nEdges'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Vector component normal to an edge.')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'normalVectorEdge', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'normalVectorEdge', r2Ptr)

! Define variable tangentialVectorEdge
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'tangentialVectorEdge'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nEdges'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Vector component tangent to an edge.')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'tangentialVectorEdge', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'tangentialVectorEdge', r2Ptr)

! Define variable windStressFullScratch
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'windStressFullScratch'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nEdges'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'N m^{-2}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Wind stress used for reconstructing diagnostic output '&
//'fields.')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'windStressFullScratch', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'windStressFullScratch', r2Ptr)

! Define variable windStressXScratch
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'windStressXScratch'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'N m^{-2}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'reconstructed surface wind stress in the x direction. Used '&
//'for diagnostics.')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'windStressXScratch', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'windStressXScratch', r2Ptr)

! Define variable windStressYScratch
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'windStressYScratch'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'N m^{-2}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'reconstructed surface wind stress in the y direction. User '&
//'for diagnostics.')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'windStressYScratch', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'windStressYScratch', r2Ptr)

! Define variable windStressZScratch
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'windStressZScratch'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'N m^{-2}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'reconstructed surface wind stress in the z direction. User '&
//'for diagnostics.')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'windStressZScratch', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'windStressZScratch', r2Ptr)

! Define variable windStressZonalScratch
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'windStressZonalScratch'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'N m^{-2}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'reconstructed surface wind stress in the eastward '&
//'direction. Used for diagnostics.')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'windStressZonalScratch', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'windStressZonalScratch', r2Ptr)

! Define variable windStressMeridionalScratch
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'windStressMeridionalScratch'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'N m^{-2}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'reconstructed surface wind stress in the northward '&
//'direction. User for diagnostics.')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'windStressMeridionalScratch', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'windStressMeridionalScratch', r2Ptr)

! Define variable gradDensityEdge
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'gradDensityEdge'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nEdges'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', '')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Normal gradient of density')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'gradDensityEdge', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'gradDensityEdge', r2Ptr)

! Define variable gradDensityConstZTopOfEdge
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'gradDensityConstZTopOfEdge'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevelsP1'
      r2Ptr(1) % dimNames(2) = 'nEdges'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', '')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Normal gradient of density along constant z-level surface')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'gradDensityConstZTopOfEdge', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'gradDensityConstZTopOfEdge', r2Ptr)

! Define variable gradDensityTopOfEdge
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'gradDensityTopOfEdge'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevelsP1'
      r2Ptr(1) % dimNames(2) = 'nEdges'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', '')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Normal gradient of density at layer interfaces')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'gradDensityTopOfEdge', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'gradDensityTopOfEdge', r2Ptr)

! Define variable gradTracerEdge
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'gradTracerEdge'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nEdges'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', '')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Normal gradient of tracer field at edges')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'gradTracerEdge', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'gradTracerEdge', r2Ptr)

! Define variable gradTracerTopOfEdge
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'gradTracerTopOfEdge'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevelsP1'
      r2Ptr(1) % dimNames(2) = 'nEdges'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', '')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Normal gradient of tracer field at layer interfaces')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'gradTracerTopOfEdge', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'gradTracerTopOfEdge', r2Ptr)

! Define variable gradHTracerSlopedTopOfCell
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'gradHTracerSlopedTopOfCell'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevelsP1'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'tracer m s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Dot product of relative slope with gradient of tracer '&
//'averaged to cell centers')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'gradHTracerSlopedTopOfCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'gradHTracerSlopedTopOfCell', r2Ptr)

! Define variable dDensityDzTopOfCell
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'dDensityDzTopOfCell'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevelsP1'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', '')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Vertical gradient of potential density')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'dDensityDzTopOfCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'dDensityDzTopOfCell', r2Ptr)

! Define variable dDensityDzTopOfEdge
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'dDensityDzTopOfEdge'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevelsP1'
      r2Ptr(1) % dimNames(2) = 'nEdges'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', '')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Vertical gradient of potential density at edge and top of '&
//'layer.')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'dDensityDzTopOfEdge', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'dDensityDzTopOfEdge', r2Ptr)

! Define variable dDispDensityDzTopOfCell
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'dDispDensityDzTopOfCell'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevelsP1'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', '')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Vertical gradient of density')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'dDispDensityDzTopOfCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'dDispDensityDzTopOfCell', r2Ptr)

! Define variable dDispDensityDzTopOfEdge
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'dDispDensityDzTopOfEdge'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevelsP1'
      r2Ptr(1) % dimNames(2) = 'nEdges'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', '')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Vertical gradient of density at edge and top of layer.')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'dDispDensityDzTopOfEdge', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'dDispDensityDzTopOfEdge', r2Ptr)

! Define variable dTracerdZTopOfCell
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'dTracerdZTopOfCell'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevelsP1'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', '')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Vertical gradient of tracer field at cell centers')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'dTracerdZTopOfCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'dTracerdZTopOfCell', r2Ptr)

! Define variable dTracerdZTopOfEdge
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'dTracerdZTopOfEdge'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevelsP1'
      r2Ptr(1) % dimNames(2) = 'nEdges'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', '')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Vertical gradient of tracer field at cell edges')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'dTracerdZTopOfEdge', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'dTracerdZTopOfEdge', r2Ptr)

! Define variable gradZMidEdge
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'gradZMidEdge'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nEdges'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', '')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Gradient of zMid')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'gradZMidEdge', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'gradZMidEdge', r2Ptr)

! Define variable gradZMidTopOfEdge
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'gradZMidTopOfEdge'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevelsP1'
      r2Ptr(1) % dimNames(2) = 'nEdges'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', '')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Gradient of zMid at layer interfaces')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'gradZMidTopOfEdge', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'gradZMidTopOfEdge', r2Ptr)

! Define variable tridiagA
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'tridiagA'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .false.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .false.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nVertLevels'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', '')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'The lower band of a tridiagonal matrix')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'tridiagA', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'tridiagA', r1Ptr)

! Define variable tridiagB
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'tridiagB'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .false.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .false.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nVertLevels'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', '')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'The central band of a tridiagonal matrix')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'tridiagB', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'tridiagB', r1Ptr)

! Define variable tridiagC
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'tridiagC'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .false.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .false.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nVertLevels'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', '')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'The upper band of a tridiagonal matrix')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'tridiagC', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'tridiagC', r1Ptr)

! Define variable areaCellSum
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'areaCellSum'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm^{2}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Accumulated cell area for normalization')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'areaCellSum', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'areaCellSum', r2Ptr)

! Define variable rightHandSide
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'rightHandSide'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .false.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .false.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nVertLevels'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', '')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'A vector')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'rightHandSide', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'rightHandSide', r1Ptr)

! Define variable yRelativeSlopeSolution
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'yRelativeSlopeSolution'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevelsP1'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Slope of isopycnal surface for analytic solution')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'yRelativeSlopeSolution', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'yRelativeSlopeSolution', r2Ptr)

! Define variable yGMStreamFuncSolution
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'yGMStreamFuncSolution'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevelsP1'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm^2 s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'GM stream function reconstructed to the cell centers, for '&
//'analytic solution')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'yGMStreamFuncSolution', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'yGMStreamFuncSolution', r2Ptr)

! Define variable yGMBolusVelocitySolution
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'yGMBolusVelocitySolution'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Bolus velocity in Gent-McWilliams eddy parameterization, '&
//'y-direction, for analytic solution')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'yGMBolusVelocitySolution', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'yGMBolusVelocitySolution', r2Ptr)

! Define variable div_hu
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'div_hu'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', '')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'div_hu')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'div_hu', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'div_hu', r2Ptr)

! Define variable projectedSSH
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'projectedSSH'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .false.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', '')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'projectedSSH')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'projectedSSH', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'projectedSSH', r1Ptr)

! Define variable ALE_Thickness
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ALE_Thickness'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', '')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'ALE_Thickness')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'ALE_Thickness', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ALE_Thickness', r2Ptr)

! Define variable delsq_u
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'delsq_u'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .false.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nEdgesP1'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', '')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'delsq_u')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'delsq_u', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'delsq_u', r2Ptr)

! Define variable delsq_divergence
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'delsq_divergence'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .false.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCellsP1'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', '')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'delsq_divergence')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'delsq_divergence', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'delsq_divergence', r2Ptr)

! Define variable delsq_relativeVorticity
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'delsq_relativeVorticity'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .false.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nVerticesP1'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', '')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'delsq_relativeVorticity')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'delsq_relativeVorticity', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'delsq_relativeVorticity', r2Ptr)

! Define variable ddensityTopOfCell
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ddensityTopOfCell'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .false.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevelsP1'
      r2Ptr(1) % dimNames(2) = 'nCellsP1'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', '')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'ddensityTopOfCell')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'ddensityTopOfCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ddensityTopOfCell', r2Ptr)

! Define variable ddensityTopOfEdge
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ddensityTopOfEdge'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevelsP1'
      r2Ptr(1) % dimNames(2) = 'nEdges'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', '')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'ddensityTopOfEdge')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'ddensityTopOfEdge', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ddensityTopOfEdge', r2Ptr)

! Define variable du2TopOfCell
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'du2TopOfCell'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .false.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevelsP1'
      r2Ptr(1) % dimNames(2) = 'nCellsP1'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', '')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'du2TopOfCell')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'du2TopOfCell', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'du2TopOfCell', r2Ptr)

! Define variable du2TopOfEdge
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'du2TopOfEdge'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevelsP1'
      r2Ptr(1) % dimNames(2) = 'nEdges'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', '')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'du2TopOfEdge')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'du2TopOfEdge', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'du2TopOfEdge', r2Ptr)

! Define variable tracerCur
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'tracerCur'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', '')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Current single tracer value for advection')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'tracerCur', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'tracerCur', r2Ptr)

! Define variable hNewInv
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'hNewInv'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', '')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Inverse layer thickness for advection')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'hNewInv', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'hNewInv', r2Ptr)

! Define variable hProv
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'hProv'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', '')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'provisional layer thickness for advection')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'hProv', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'hProv', r2Ptr)

! Define variable hProvInv
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'hProvInv'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'inverse of provisional layer thickness for advection')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'hProvInv', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'hProvInv', r2Ptr)

! Define variable workTendency
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'workTendency'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', '')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Advective tendency work array')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'workTendency', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'workTendency', r2Ptr)

! Define variable tracerMin
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'tracerMin'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', '')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Min tracer value for monotonic advection')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'tracerMin', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'tracerMin', r2Ptr)

! Define variable tracerMax
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'tracerMax'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', '')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Max tracer value for monotonic advection')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'tracerMax', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'tracerMax', r2Ptr)

! Define variable fluxIncoming
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'fluxIncoming'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', '')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Incoming flux of a tracer for advection')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'fluxIncoming', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'fluxIncoming', r2Ptr)

! Define variable fluxOutgoing
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'fluxOutgoing'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', '')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Outgoing flux of a tracer for advection')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'fluxOutgoing', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'fluxOutgoing', r2Ptr)

! Define variable lowOrderFlux
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'lowOrderFlux'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevelsP1'
      r2Ptr(1) % dimNames(2) = 'nEdges'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', '')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Low order flux scratch variable for both horizontal and '&
//'vertical advection.')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'lowOrderFlux', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'lowOrderFlux', r2Ptr)

! Define variable highOrderFlux
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'highOrderFlux'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevelsP1'
      r2Ptr(1) % dimNames(2) = 'nEdges'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', '')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'High order flux scratch variable for both horizontal and '&
//'vertical advection.')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'highOrderFlux', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'highOrderFlux', r2Ptr)

! Define variable btrvel_temp
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'btrvel_temp'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .false.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .false.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdgesP1'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', '')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'btrvel_temp')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'btrvel_temp', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'btrvel_temp', r1Ptr)

! Define variable boundaryLayerTemperatureScratch
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'boundaryLayerTemperatureScratch'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .false.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', '^\circ C')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'temperature averaged vertically over the sub-ice-shelf '&
//'boundary layer')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'boundaryLayerTemperatureScratch', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'boundaryLayerTemperatureScratch', r1Ptr)

! Define variable boundaryLayerSalinityScratch
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'boundaryLayerSalinityScratch'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .false.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'PSU')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'salinity averaged vertically over the sub-ice-shelf '&
//'boundary layer')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'boundaryLayerSalinityScratch', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'boundaryLayerSalinityScratch', r1Ptr)

! Define variable freezeInterfaceSalinityScratch
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'freezeInterfaceSalinityScratch'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .false.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'PSU')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'salinity at land ice-ocean interface where freezing is '&
//'occurring')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'freezeInterfaceSalinityScratch', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'freezeInterfaceSalinityScratch', r1Ptr)

! Define variable freezeInterfaceTemperatureScratch
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'freezeInterfaceTemperatureScratch'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .false.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', '^\circ C')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'temperature at land ice-ocean interface where freezing is '&
//'occurring')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'freezeInterfaceTemperatureScratch', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'freezeInterfaceTemperatureScratch', r1Ptr)

! Define variable freezeThicknessFluxScratch
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'freezeThicknessFluxScratch'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .false.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'thickness flux at land ice-ocean interface where freezing '&
//'is occurring')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'freezeThicknessFluxScratch', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'freezeThicknessFluxScratch', r1Ptr)

! Define variable freezeTemperatureFluxScratch
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'freezeTemperatureFluxScratch'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .false.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', '^\circ C m s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'ocean temperature flux at land ice-ocean interface where '&
//'freezing is occurring')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'freezeTemperatureFluxScratch', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'freezeTemperatureFluxScratch', r1Ptr)

! Define variable freezeIceTemperatureFluxScratch
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'freezeIceTemperatureFluxScratch'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .false.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', '^\circ C m s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'ice temperature flux at land ice-ocean interface where '&
//'freezing is occurring')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'freezeIceTemperatureFluxScratch', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'freezeIceTemperatureFluxScratch', r1Ptr)

! Define variable effectiveDensityScratch
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'effectiveDensityScratch'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .false.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'kg m^{-3}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'effective seawater density in land ice before horizontal '&
//'averaging')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'effectiveDensityScratch', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'effectiveDensityScratch', r1Ptr)

! Define variable scratchZMid
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'scratchZMid'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'reference z-midpoint of cells for vertical interpolation '&
//'of tracers')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'scratchZMid', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'scratchZMid', r2Ptr)

! Define variable scratchMaxLevelCell
      allocate(i1Ptr(1))

! Setting up time level 1
      i1Ptr(1) % fieldName = 'scratchMaxLevelCell'
      i1Ptr(1) % isVarArray = .false.
      i1Ptr(1) % isDecomposed = .true.
      i1Ptr(1) % hasTimeDimension = .false.
      i1Ptr(1) % isPersistent = .false.
      i1Ptr(1) % isActive = .false.
! Setting up dimensions
      i1Ptr(1) % dimNames(1) = 'nCells'
      i1Ptr(1) % defaultValue = 0
      allocate(i1Ptr(1) % attLists(1))
      allocate(i1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'long_name', 'reference maxLevelCell for vertical interpolation of '&
//'tracers')
      i1Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i1Ptr(1) % block => block

      i1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'scratchMaxLevelCell', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'scratchMaxLevelCell', i1Ptr)

! Define variable smoothedField
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'smoothedField'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .false.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'various')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'the smoothed version of a field on cells during iterative '&
//'smoothing')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'smoothedField', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'smoothedField', r1Ptr)

! Define variable zInterfaceScratch
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'zInterfaceScratch'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevelsP1'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'location of layer interfaces at cell centers, used for '&
//'thickening layers constrained by the Haney number (rx1)')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'zInterfaceScratch', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'zInterfaceScratch', r2Ptr)

! Define variable goalStretchScratch
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'goalStretchScratch'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'the goal stretch field for the vertical coordinate')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'goalStretchScratch', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'goalStretchScratch', r2Ptr)

! Define variable goalWeightScratch
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'goalWeightScratch'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'the sum of weights used to determine the goal stretch '&
//'field')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'goalWeightScratch', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'goalWeightScratch', r2Ptr)

! Define variable zTopScratch
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'zTopScratch'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .false.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'location of the upper layer used to compute the Haney '&
//'number (rx1), equal to ssh for top layer and zMid of the layer for subsequent layers')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'zTopScratch', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'zTopScratch', r1Ptr)

! Define variable zBotScratch
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'zBotScratch'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .false.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'location of the lower layer used to compute the Haney '&
//'number (rx1), equal zMid of the layer lower layer (but a 1D filed is needed for halo exchanges)')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'zBotScratch', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'zBotScratch', r1Ptr)

! Define variable zBotNewScratch
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'zBotNewScratch'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .false.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'updated location of the lower layer used to compute the '&
//'Haney number (rx1), needed so update is agnostic to the order in which cells are accessed')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'zBotNewScratch', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'zBotNewScratch', r1Ptr)

! Define variable smoothingMaskNewScratch
      allocate(i1Ptr(1))

! Setting up time level 1
      i1Ptr(1) % fieldName = 'smoothingMaskNewScratch'
      i1Ptr(1) % isVarArray = .false.
      i1Ptr(1) % isDecomposed = .true.
      i1Ptr(1) % hasTimeDimension = .false.
      i1Ptr(1) % isPersistent = .false.
      i1Ptr(1) % isActive = .false.
! Setting up dimensions
      i1Ptr(1) % dimNames(1) = 'nCells'
      i1Ptr(1) % defaultValue = 0
      allocate(i1Ptr(1) % attLists(1))
      allocate(i1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'long_name', 'a copy of the smoothing mask used to iteratively expand '&
//'the field into a buffer region of open ocean around land ice.')
      i1Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i1Ptr(1) % block => block

      i1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'smoothingMaskNewScratch', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'smoothingMaskNewScratch', i1Ptr)

! Define variable smoothedLevels
      allocate(i1Ptr(1))

! Setting up time level 1
      i1Ptr(1) % fieldName = 'smoothedLevels'
      i1Ptr(1) % isVarArray = .false.
      i1Ptr(1) % isDecomposed = .true.
      i1Ptr(1) % hasTimeDimension = .false.
      i1Ptr(1) % isPersistent = .false.
      i1Ptr(1) % isActive = .false.
! Setting up dimensions
      i1Ptr(1) % dimNames(1) = 'nCells'
      i1Ptr(1) % defaultValue = 0
      allocate(i1Ptr(1) % attLists(1))
      allocate(i1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'long_name', 'Temporary space to hold smoothed maxLevelCell to allow '&
//'bit-reproducibility.')
      i1Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i1Ptr(1) % block => block

      i1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'smoothedLevels', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'smoothedLevels', i1Ptr)

! Define variable cullStack
      allocate(i1Ptr(1))

! Setting up time level 1
      i1Ptr(1) % fieldName = 'cullStack'
      i1Ptr(1) % isVarArray = .false.
      i1Ptr(1) % isDecomposed = .true.
      i1Ptr(1) % hasTimeDimension = .false.
      i1Ptr(1) % isPersistent = .false.
      i1Ptr(1) % isActive = .false.
! Setting up dimensions
      i1Ptr(1) % dimNames(1) = 'nCells'
      i1Ptr(1) % defaultValue = 0
      allocate(i1Ptr(1) % attLists(1))
      allocate(i1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'long_name', 'Temporary space to hold a stack for culling inland seas.')
      i1Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i1Ptr(1) % block => block

      i1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'cullStack', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'cullStack', i1Ptr)

! Define variable touchedCell
      allocate(i1Ptr(1))

! Setting up time level 1
      i1Ptr(1) % fieldName = 'touchedCell'
      i1Ptr(1) % isVarArray = .false.
      i1Ptr(1) % isDecomposed = .true.
      i1Ptr(1) % hasTimeDimension = .false.
      i1Ptr(1) % isPersistent = .false.
      i1Ptr(1) % isActive = .false.
! Setting up dimensions
      i1Ptr(1) % dimNames(1) = 'nCells'
      i1Ptr(1) % defaultValue = 0
      allocate(i1Ptr(1) % attLists(1))
      allocate(i1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'long_name', 'Temporary space to a hold mask if the cell has been '&
//'touched or not, when culling inland seas.')
      i1Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i1Ptr(1) % block => block

      i1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'touchedCell', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'touchedCell', i1Ptr)

! Define variable oceanCell
      allocate(i1Ptr(1))

! Setting up time level 1
      i1Ptr(1) % fieldName = 'oceanCell'
      i1Ptr(1) % isVarArray = .false.
      i1Ptr(1) % isDecomposed = .true.
      i1Ptr(1) % hasTimeDimension = .false.
      i1Ptr(1) % isPersistent = .false.
      i1Ptr(1) % isActive = .false.
! Setting up dimensions
      i1Ptr(1) % dimNames(1) = 'nCells'
      i1Ptr(1) % defaultValue = 0
      allocate(i1Ptr(1) % attLists(1))
      allocate(i1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'long_name', 'Temporary space to a hold mask if the cell is an active '&
//'ocean cell or not.')
      i1Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i1Ptr(1) % block => block

      i1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'oceanCell', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'oceanCell', i1Ptr)

! Define variable cullStackSize
      allocate(i0Ptr(1))

! Setting up time level 1
      i0Ptr(1) % fieldName = 'cullStackSize'
      i0Ptr(1) % isVarArray = .false.
      i0Ptr(1) % isDecomposed = .false.
      i0Ptr(1) % hasTimeDimension = .true.
      i0Ptr(1) % defaultValue = 0
      i0Ptr(1) % scalar = 0
      allocate(i0Ptr(1) % attLists(1))
      allocate(i0Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i0Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i0Ptr(1) % attLists(1) % attList, 'long_name', 'Integer to hold the size of the cullStack for each block.')
      i0Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i0Ptr(1) % block => block

      i0Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'cullStackSize', i0Ptr)
      call mpas_pool_add_field(block % allFields, 'cullStackSize', i0Ptr)

! Define variable interpActiveTracer
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'interpActiveTracer'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nDepthTracerIC'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'various')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'temporary space for holding one tracer at a time as part '&
//'of horizontal interpolation')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'interpActiveTracer', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'interpActiveTracer', r2Ptr)

! Define variable interpEcosysTracer
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'interpEcosysTracer'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nDepthEcosysIC'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'various')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'temporary space for holding one tracer at a time as part '&
//'of horizontal interpolation')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'interpEcosysTracer', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'interpEcosysTracer', r2Ptr)

! Define variable interpActiveTracerSmooth
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'interpActiveTracerSmooth'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nDepthTracerIC'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'various')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'temporary space for holding one tracer at a time as part '&
//'of horizontal interpolation')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'interpActiveTracerSmooth', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'interpActiveTracerSmooth', r2Ptr)

! Define variable interpEcosysTracerSmooth
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'interpEcosysTracerSmooth'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nDepthEcosysIC'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'various')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'temporary space for holding one tracer at a time as part '&
//'of horizontal interpolation')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'interpEcosysTracerSmooth', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'interpEcosysTracerSmooth', r2Ptr)

! Define variable psiVertex
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'psiVertex'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .false.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nVertices'
      r1Ptr(1) % defaultValue = 0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Temporary space to hold vertex values for psi.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'psiVertex', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'psiVertex', r1Ptr)

! Define variable isomip_bottomPressure
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'isomip_bottomPressure'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .false.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'Pa')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Temporary space to hold the pressure at the bottom of the '&
//'ocean, used to compute estimated sea-surface pressure under landice.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'isomip_bottomPressure', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'isomip_bottomPressure', r1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_pool_scratch


   subroutine ocn_generate_pool_pointLocations(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'pointLocations', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'pointLocations', newSubPool)

! Define variable pointCellGlobalID
      allocate(i1Ptr(1))

! Setting up time level 1
      i1Ptr(1) % fieldName = 'pointCellGlobalID'
      i1Ptr(1) % isVarArray = .false.
      i1Ptr(1) % isDecomposed = .false.
      i1Ptr(1) % hasTimeDimension = .false.
      i1Ptr(1) % isPersistent = .true.
      i1Ptr(1) % isActive = .false.
! Setting up dimensions
      i1Ptr(1) % dimNames(1) = 'nPoints'
      i1Ptr(1) % defaultValue = 0
      allocate(i1Ptr(1) % attLists(1))
      allocate(i1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'long_name', 'List of global cell IDs in point set.')
      i1Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i1Ptr(1) % block => block

      i1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'pointCellGlobalID', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'pointCellGlobalID', i1Ptr)

! Define variable pointCellLocalID
      allocate(i1Ptr(1))

! Setting up time level 1
      i1Ptr(1) % fieldName = 'pointCellLocalID'
      i1Ptr(1) % isVarArray = .false.
      i1Ptr(1) % isDecomposed = .false.
      i1Ptr(1) % hasTimeDimension = .false.
      i1Ptr(1) % isPersistent = .true.
      i1Ptr(1) % isActive = .false.
! Setting up dimensions
      i1Ptr(1) % dimNames(1) = 'nPoints'
      i1Ptr(1) % defaultValue = 0
      allocate(i1Ptr(1) % attLists(1))
      allocate(i1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'long_name', 'List of local cell IDs in point set.')
      i1Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i1Ptr(1) % block => block

      i1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'pointCellLocalID', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'pointCellLocalID', i1Ptr)

! Define variable indexToPointCellLocalID
      allocate(i1Ptr(1))

! Setting up time level 1
      i1Ptr(1) % fieldName = 'indexToPointCellLocalID'
      i1Ptr(1) % isVarArray = .false.
      i1Ptr(1) % isDecomposed = .false.
      i1Ptr(1) % hasTimeDimension = .false.
      i1Ptr(1) % isPersistent = .true.
      i1Ptr(1) % isActive = .false.
! Setting up dimensions
      i1Ptr(1) % dimNames(1) = 'nPoints'
      i1Ptr(1) % defaultValue = 0
      allocate(i1Ptr(1) % attLists(1))
      allocate(i1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'long_name', 'Index to list of local cell IDs in point set.')
      i1Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i1Ptr(1) % block => block

      i1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'indexToPointCellLocalID', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'indexToPointCellLocalID', i1Ptr)

! Define variable pointNames
      allocate(c1Ptr(1))

! Setting up time level 1
      c1Ptr(1) % fieldName = 'pointNames'
      c1Ptr(1) % isVarArray = .false.
      c1Ptr(1) % isDecomposed = .false.
      c1Ptr(1) % hasTimeDimension = .false.
      c1Ptr(1) % isPersistent = .true.
      c1Ptr(1) % isActive = .false.
! Setting up dimensions
      c1Ptr(1) % dimNames(1) = 'nPoints'
      c1Ptr(1) % defaultValue = ''
      allocate(c1Ptr(1) % attLists(1))
      allocate(c1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(c1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(c1Ptr(1) % attLists(1) % attList, 'long_name', 'The names of each point.')
      c1Ptr(1) % missingValue = MPAS_CHAR_FILLVAL
      c1Ptr(1) % block => block

      c1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'pointNames', c1Ptr)
      call mpas_pool_add_field(block % allFields, 'pointNames', c1Ptr)

! Define variable pointGroupNames
      allocate(c1Ptr(1))

! Setting up time level 1
      c1Ptr(1) % fieldName = 'pointGroupNames'
      c1Ptr(1) % isVarArray = .false.
      c1Ptr(1) % isDecomposed = .false.
      c1Ptr(1) % hasTimeDimension = .false.
      c1Ptr(1) % isPersistent = .true.
      c1Ptr(1) % isActive = .false.
! Setting up dimensions
      c1Ptr(1) % dimNames(1) = 'nPointGroups'
      c1Ptr(1) % defaultValue = ''
      allocate(c1Ptr(1) % attLists(1))
      allocate(c1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(c1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(c1Ptr(1) % attLists(1) % attList, 'long_name', 'The names of each point group.')
      c1Ptr(1) % missingValue = MPAS_CHAR_FILLVAL
      c1Ptr(1) % block => block

      c1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'pointGroupNames', c1Ptr)
      call mpas_pool_add_field(block % allFields, 'pointGroupNames', c1Ptr)

! Define variable nPointsInGroup
      allocate(i1Ptr(1))

! Setting up time level 1
      i1Ptr(1) % fieldName = 'nPointsInGroup'
      i1Ptr(1) % isVarArray = .false.
      i1Ptr(1) % isDecomposed = .false.
      i1Ptr(1) % hasTimeDimension = .false.
      i1Ptr(1) % isPersistent = .true.
      i1Ptr(1) % isActive = .false.
! Setting up dimensions
      i1Ptr(1) % dimNames(1) = 'nPointGroups'
      i1Ptr(1) % defaultValue = 0
      allocate(i1Ptr(1) % attLists(1))
      allocate(i1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'long_name', 'The number of points in each point group.')
      i1Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i1Ptr(1) % block => block

      i1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'nPointsInGroup', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'nPointsInGroup', i1Ptr)

! Define variable pointsInGroup
      allocate(i2Ptr(1))

! Setting up time level 1
      i2Ptr(1) % fieldName = 'pointsInGroup'
      i2Ptr(1) % isVarArray = .false.
      i2Ptr(1) % isDecomposed = .false.
      i2Ptr(1) % hasTimeDimension = .false.
      i2Ptr(1) % isPersistent = .true.
      i2Ptr(1) % isActive = .false.
! Setting up dimensions
      i2Ptr(1) % dimNames(1) = 'maxPointsInGroup'
      i2Ptr(1) % dimNames(2) = 'nPointGroups'
      i2Ptr(1) % defaultValue = 0
      allocate(i2Ptr(1) % attLists(1))
      allocate(i2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'long_name', 'The indices of each point in a each group.')
      i2Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i2Ptr(1) % block => block

      i2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'pointsInGroup', i2Ptr)
      call mpas_pool_add_field(block % allFields, 'pointsInGroup', i2Ptr)

! Define variable xPoint
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'xPoint'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .false.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nPoints'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'X Coordinate in cartesian space of point locations.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'xPoint', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'xPoint', r1Ptr)

! Define variable yPoint
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'yPoint'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .false.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nPoints'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Y Coordinate in cartesian space of point locations.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'yPoint', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'yPoint', r1Ptr)

! Define variable zPoint
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'zPoint'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .false.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nPoints'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Z Coordinate in cartesian space of point locations.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'zPoint', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'zPoint', r1Ptr)

! Define variable latPoint
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'latPoint'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .false.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nPoints'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'radians')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Latitude of point locations.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'latPoint', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'latPoint', r1Ptr)

! Define variable lonPoint
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'lonPoint'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .false.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nPoints'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'radians')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Longitude of point locations.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'lonPoint', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'lonPoint', r1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_pool_pointLocations


   subroutine ocn_generate_pool_regions(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'regions', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'regions', newSubPool)

! Define variable regionCellMasks
      allocate(i2Ptr(1))

! Setting up time level 1
      i2Ptr(1) % fieldName = 'regionCellMasks'
      i2Ptr(1) % isVarArray = .false.
      i2Ptr(1) % isDecomposed = .true.
      i2Ptr(1) % hasTimeDimension = .false.
      i2Ptr(1) % isPersistent = .true.
      i2Ptr(1) % isActive = .false.
! Setting up dimensions
      i2Ptr(1) % dimNames(1) = 'nRegions'
      i2Ptr(1) % dimNames(2) = 'nCells'
      i2Ptr(1) % defaultValue = 0
      allocate(i2Ptr(1) % attLists(1))
      allocate(i2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'long_name', 'The region masks for each cell.')
      i2Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i2Ptr(1) % block => block

      i2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'regionCellMasks', i2Ptr)
      call mpas_pool_add_field(block % allFields, 'regionCellMasks', i2Ptr)

! Define variable regionVertexMasks
      allocate(i2Ptr(1))

! Setting up time level 1
      i2Ptr(1) % fieldName = 'regionVertexMasks'
      i2Ptr(1) % isVarArray = .false.
      i2Ptr(1) % isDecomposed = .true.
      i2Ptr(1) % hasTimeDimension = .false.
      i2Ptr(1) % isPersistent = .true.
      i2Ptr(1) % isActive = .false.
! Setting up dimensions
      i2Ptr(1) % dimNames(1) = 'nRegions'
      i2Ptr(1) % dimNames(2) = 'nVertices'
      i2Ptr(1) % defaultValue = 0
      allocate(i2Ptr(1) % attLists(1))
      allocate(i2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'long_name', 'The region masks for each vertex.')
      i2Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i2Ptr(1) % block => block

      i2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'regionVertexMasks', i2Ptr)
      call mpas_pool_add_field(block % allFields, 'regionVertexMasks', i2Ptr)

! Define variable regionsInGroup
      allocate(i2Ptr(1))

! Setting up time level 1
      i2Ptr(1) % fieldName = 'regionsInGroup'
      i2Ptr(1) % isVarArray = .false.
      i2Ptr(1) % isDecomposed = .false.
      i2Ptr(1) % hasTimeDimension = .false.
      i2Ptr(1) % isPersistent = .true.
      i2Ptr(1) % isActive = .false.
! Setting up dimensions
      i2Ptr(1) % dimNames(1) = 'maxRegionsInGroup'
      i2Ptr(1) % dimNames(2) = 'nRegionGroups'
      i2Ptr(1) % defaultValue = 0
      allocate(i2Ptr(1) % attLists(1))
      allocate(i2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'long_name', 'The list of region indices in each group.')
      i2Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i2Ptr(1) % block => block

      i2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'regionsInGroup', i2Ptr)
      call mpas_pool_add_field(block % allFields, 'regionsInGroup', i2Ptr)

! Define variable nRegionsInGroup
      allocate(i1Ptr(1))

! Setting up time level 1
      i1Ptr(1) % fieldName = 'nRegionsInGroup'
      i1Ptr(1) % isVarArray = .false.
      i1Ptr(1) % isDecomposed = .false.
      i1Ptr(1) % hasTimeDimension = .false.
      i1Ptr(1) % isPersistent = .true.
      i1Ptr(1) % isActive = .false.
! Setting up dimensions
      i1Ptr(1) % dimNames(1) = 'nRegionGroups'
      i1Ptr(1) % defaultValue = 0
      allocate(i1Ptr(1) % attLists(1))
      allocate(i1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'long_name', 'The number of regions in each group.')
      i1Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i1Ptr(1) % block => block

      i1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'nRegionsInGroup', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'nRegionsInGroup', i1Ptr)

! Define variable regionNames
      allocate(c1Ptr(1))

! Setting up time level 1
      c1Ptr(1) % fieldName = 'regionNames'
      c1Ptr(1) % isVarArray = .false.
      c1Ptr(1) % isDecomposed = .false.
      c1Ptr(1) % hasTimeDimension = .false.
      c1Ptr(1) % isPersistent = .true.
      c1Ptr(1) % isActive = .false.
! Setting up dimensions
      c1Ptr(1) % dimNames(1) = 'nRegions'
      c1Ptr(1) % defaultValue = ''
      allocate(c1Ptr(1) % attLists(1))
      allocate(c1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(c1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(c1Ptr(1) % attLists(1) % attList, 'long_name', 'The name for each region.')
      c1Ptr(1) % missingValue = MPAS_CHAR_FILLVAL
      c1Ptr(1) % block => block

      c1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'regionNames', c1Ptr)
      call mpas_pool_add_field(block % allFields, 'regionNames', c1Ptr)

! Define variable regionGroupNames
      allocate(c1Ptr(1))

! Setting up time level 1
      c1Ptr(1) % fieldName = 'regionGroupNames'
      c1Ptr(1) % isVarArray = .false.
      c1Ptr(1) % isDecomposed = .false.
      c1Ptr(1) % hasTimeDimension = .false.
      c1Ptr(1) % isPersistent = .true.
      c1Ptr(1) % isActive = .false.
! Setting up dimensions
      c1Ptr(1) % dimNames(1) = 'nRegionGroups'
      c1Ptr(1) % defaultValue = ''
      allocate(c1Ptr(1) % attLists(1))
      allocate(c1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(c1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(c1Ptr(1) % attLists(1) % attList, 'long_name', 'The name for each region group.')
      c1Ptr(1) % missingValue = MPAS_CHAR_FILLVAL
      c1Ptr(1) % block => block

      c1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'regionGroupNames', c1Ptr)
      call mpas_pool_add_field(block % allFields, 'regionGroupNames', c1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_pool_regions


   subroutine ocn_generate_pool_transects(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'transects', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'transects', newSubPool)

! Define variable transectEdgeMasks
      allocate(i2Ptr(1))

! Setting up time level 1
      i2Ptr(1) % fieldName = 'transectEdgeMasks'
      i2Ptr(1) % isVarArray = .false.
      i2Ptr(1) % isDecomposed = .true.
      i2Ptr(1) % hasTimeDimension = .false.
      i2Ptr(1) % isPersistent = .true.
      i2Ptr(1) % isActive = .false.
! Setting up dimensions
      i2Ptr(1) % dimNames(1) = 'nTransects'
      i2Ptr(1) % dimNames(2) = 'nEdges'
      i2Ptr(1) % defaultValue = 0
      allocate(i2Ptr(1) % attLists(1))
      allocate(i2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'units', 'NA')
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'long_name', 'Mask of edges for measuring transport across transects')
      i2Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i2Ptr(1) % block => block

      i2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'transectEdgeMasks', i2Ptr)
      call mpas_pool_add_field(block % allFields, 'transectEdgeMasks', i2Ptr)

! Define variable transectEdgeMaskSigns
      allocate(i2Ptr(1))

! Setting up time level 1
      i2Ptr(1) % fieldName = 'transectEdgeMaskSigns'
      i2Ptr(1) % isVarArray = .false.
      i2Ptr(1) % isDecomposed = .true.
      i2Ptr(1) % hasTimeDimension = .false.
      i2Ptr(1) % isPersistent = .true.
      i2Ptr(1) % isActive = .false.
! Setting up dimensions
      i2Ptr(1) % dimNames(1) = 'nTransects'
      i2Ptr(1) % dimNames(2) = 'nEdges'
      i2Ptr(1) % defaultValue = 0
      allocate(i2Ptr(1) % attLists(1))
      allocate(i2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'units', 'NA')
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'long_name', 'Sign of normalVelocity on edge for this transect')
      i2Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i2Ptr(1) % block => block

      i2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'transectEdgeMaskSigns', i2Ptr)
      call mpas_pool_add_field(block % allFields, 'transectEdgeMaskSigns', i2Ptr)

! Define variable transectsInGroup
      allocate(i2Ptr(1))

! Setting up time level 1
      i2Ptr(1) % fieldName = 'transectsInGroup'
      i2Ptr(1) % isVarArray = .false.
      i2Ptr(1) % isDecomposed = .false.
      i2Ptr(1) % hasTimeDimension = .false.
      i2Ptr(1) % isPersistent = .true.
      i2Ptr(1) % isActive = .false.
! Setting up dimensions
      i2Ptr(1) % dimNames(1) = 'maxTransectsInGroup'
      i2Ptr(1) % dimNames(2) = 'nTransectGroups'
      i2Ptr(1) % defaultValue = 0
      allocate(i2Ptr(1) % attLists(1))
      allocate(i2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'long_name', 'The list of transect indices in each group.')
      i2Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i2Ptr(1) % block => block

      i2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'transectsInGroup', i2Ptr)
      call mpas_pool_add_field(block % allFields, 'transectsInGroup', i2Ptr)

! Define variable nTransectsInGroup
      allocate(i1Ptr(1))

! Setting up time level 1
      i1Ptr(1) % fieldName = 'nTransectsInGroup'
      i1Ptr(1) % isVarArray = .false.
      i1Ptr(1) % isDecomposed = .false.
      i1Ptr(1) % hasTimeDimension = .false.
      i1Ptr(1) % isPersistent = .true.
      i1Ptr(1) % isActive = .false.
! Setting up dimensions
      i1Ptr(1) % dimNames(1) = 'nTransectGroups'
      i1Ptr(1) % defaultValue = 0
      allocate(i1Ptr(1) % attLists(1))
      allocate(i1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'long_name', 'The number of transects in each group.')
      i1Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i1Ptr(1) % block => block

      i1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'nTransectsInGroup', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'nTransectsInGroup', i1Ptr)

! Define variable transectNames
      allocate(c1Ptr(1))

! Setting up time level 1
      c1Ptr(1) % fieldName = 'transectNames'
      c1Ptr(1) % isVarArray = .false.
      c1Ptr(1) % isDecomposed = .false.
      c1Ptr(1) % hasTimeDimension = .false.
      c1Ptr(1) % isPersistent = .true.
      c1Ptr(1) % isActive = .false.
! Setting up dimensions
      c1Ptr(1) % dimNames(1) = 'nTransects'
      c1Ptr(1) % defaultValue = ''
      allocate(c1Ptr(1) % attLists(1))
      allocate(c1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(c1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(c1Ptr(1) % attLists(1) % attList, 'long_name', 'The name for each transect.')
      c1Ptr(1) % missingValue = MPAS_CHAR_FILLVAL
      c1Ptr(1) % block => block

      c1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'transectNames', c1Ptr)
      call mpas_pool_add_field(block % allFields, 'transectNames', c1Ptr)

! Define variable transectGroupNames
      allocate(c1Ptr(1))

! Setting up time level 1
      c1Ptr(1) % fieldName = 'transectGroupNames'
      c1Ptr(1) % isVarArray = .false.
      c1Ptr(1) % isDecomposed = .false.
      c1Ptr(1) % hasTimeDimension = .false.
      c1Ptr(1) % isPersistent = .true.
      c1Ptr(1) % isActive = .false.
! Setting up dimensions
      c1Ptr(1) % dimNames(1) = 'nTransectGroups'
      c1Ptr(1) % defaultValue = ''
      allocate(c1Ptr(1) % attLists(1))
      allocate(c1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(c1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(c1Ptr(1) % attLists(1) % attList, 'long_name', 'The name for each transect group.')
      c1Ptr(1) % missingValue = MPAS_CHAR_FILLVAL
      c1Ptr(1) % block => block

      c1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'transectGroupNames', c1Ptr)
      call mpas_pool_add_field(block % allFields, 'transectGroupNames', c1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_pool_transects


   subroutine ocn_generate_pool_surfaceSalinityMonthlyForcing(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'surfaceSalinityMonthlyForcing', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'surfaceSalinityMonthlyForcing', newSubPool)

! Define variable surfaceSalinityMonthlyClimatologyValue
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'surfaceSalinityMonthlyClimatologyValue'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'psu')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'monthly surface salinity climatology interpolated to '&
//'current timestep')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'surfaceSalinityMonthlyClimatologyValue', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'surfaceSalinityMonthlyClimatologyValue', r1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_pool_surfaceSalinityMonthlyForcing


   subroutine ocn_generate_pool_ecosysMonthlyForcing(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'ecosysMonthlyForcing', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'ecosysMonthlyForcing', newSubPool)

! Define variable depositionFluzNO3
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'depositionFluzNO3'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol N m^{-3} m s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Atmospheric Deposition of NO3')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'depositionFluzNO3', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'depositionFluzNO3', r1Ptr)

! Define variable depositionFluzNH4
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'depositionFluzNH4'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol N m^{-3} m s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Atmospheric Deposition of NH4')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'depositionFluzNH4', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'depositionFluzNH4', r1Ptr)

! Define variable riverFluzNO3
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'riverFluzNO3'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol N m^{-3} m s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'River Runoff Fluz of NO3')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'riverFluzNO3', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'riverFluzNO3', r1Ptr)

! Define variable riverFluzPO4
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'riverFluzPO4'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol P m^{-3} m s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'River Runoff Fluz of PO4')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'riverFluzPO4', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'riverFluzPO4', r1Ptr)

! Define variable riverFluzSiO3
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'riverFluzSiO3'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol Si m^{-3} m s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'River Runoff Fluz of SiO3')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'riverFluzSiO3', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'riverFluzSiO3', r1Ptr)

! Define variable riverFluzFe
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'riverFluzFe'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol Fe m^{-3} m s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'River Runoff Fluz of Fe')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'riverFluzFe', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'riverFluzFe', r1Ptr)

! Define variable riverFluzDOC
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'riverFluzDOC'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-3} m s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'River Runoff Fluz of DOC')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'riverFluzDOC', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'riverFluzDOC', r1Ptr)

! Define variable riverFluzDON
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'riverFluzDON'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol N m^{-3} m s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'River Runoff Fluz of DON')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'riverFluzDON', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'riverFluzDON', r1Ptr)

! Define variable riverFluzDOP
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'riverFluzDOP'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol P m^{-3} m s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'River Runoff Fluz of DOP')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'riverFluzDOP', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'riverFluzDOP', r1Ptr)

! Define variable riverFluzDIC
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'riverFluzDIC'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol C m^{-3} m s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'River Runoff Fluz of DIC')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'riverFluzDIC', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'riverFluzDIC', r1Ptr)

! Define variable riverFluzALK
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'riverFluzALK'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'meq m^{-3} m s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'River Runoff Fluz of ALK')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'riverFluzALK', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'riverFluzALK', r1Ptr)

! Define variable dust_FLUZ_IN
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'dust_FLUZ_IN'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'kg m^{-2} s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Surface Dust Flux')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'dust_FLUZ_IN', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'dust_FLUZ_IN', r1Ptr)

! Define variable IRON_FLUZ_IN
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'IRON_FLUZ_IN'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'mmol Fe m^{-3} m s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Surface Fe Flux')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'IRON_FLUZ_IN', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'IRON_FLUZ_IN', r1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_pool_ecosysMonthlyForcing


   subroutine ocn_generate_pool_globalStatsAM(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'globalStatsAM', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'globalStatsAM', newSubPool)

! Define var array minGlobalStats
      allocate(r1Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group mins
! Define constituent var layerThicknessMin
! My Packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_layerThicknessMin', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_layerThicknessMin', -1)
           end if
      end if
! Define constituent var normalVelocityMin
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_normalVelocityMin', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_normalVelocityMin', -1)
         end if
      end if
! Define constituent var tangentialVelocityMin
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_tangentialVelocityMin', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_tangentialVelocityMin', -1)
         end if
      end if
! Define constituent var layerThicknessEdgeMin
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_layerThicknessEdgeMin', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_layerThicknessEdgeMin', -1)
         end if
      end if
! Define constituent var relativeVorticityMin
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_relativeVorticityMin', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_relativeVorticityMin', -1)
         end if
      end if
! Define constituent var enstrophyMin
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_enstrophyMin', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_enstrophyMin', -1)
         end if
      end if
! Define constituent var kineticEnergyCellMin
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_kineticEnergyCellMin', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_kineticEnergyCellMin', -1)
         end if
      end if
! Define constituent var normalizedAbsoluteVorticityMin
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_normalizedAbsoluteVorticityMin', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_normalizedAbsoluteVorticityMin', -1)
         end if
      end if
! Define constituent var pressureMin
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_pressureMin', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_pressureMin', -1)
         end if
      end if
! Define constituent var montgomeryPotentialMin
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_montgomeryPotentialMin', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_montgomeryPotentialMin', -1)
         end if
      end if
! Define constituent var vertVelocityTopMin
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_vertVelocityTopMin', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_vertVelocityTopMin', -1)
         end if
      end if
! Define constituent var vertAleTransportTopMin
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_vertAleTransportTopMin', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_vertAleTransportTopMin', -1)
         end if
      end if
! Define constituent var lowFreqDivergenceMin
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_lowFreqDivergenceMin', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_lowFreqDivergenceMin', -1)
         end if
      end if
! Define constituent var highFreqThicknessMin
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_highFreqThicknessMin', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_highFreqThicknessMin', -1)
         end if
      end if
! Define constituent var temperatureMin
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureMin', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureMin', -1)
         end if
      end if
! Define constituent var salinityMin
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityMin', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityMin', -1)
         end if
      end if
! Define constituent var layerThicknessPreviousTimestepMin
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_layerThicknessPreviousTimestepMin', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_layerThicknessPreviousTimestepMin', -1)
         end if
      end if
! Define constituent var frazilLayerThicknessTendencyMin
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_frazilLayerThicknessTendencyMin', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_frazilLayerThicknessTendencyMin', -1)
         end if
      end if
! Define constituent var evaporationFluxMin
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_evaporationFluxMin', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_evaporationFluxMin', -1)
         end if
      end if
! Define constituent var rainFluxMin
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_rainFluxMin', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_rainFluxMin', -1)
         end if
      end if
! Define constituent var snowFluxMin
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_snowFluxMin', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_snowFluxMin', -1)
         end if
      end if
! Define constituent var seaIceFreshWaterFluxMin
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_seaIceFreshWaterFluxMin', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_seaIceFreshWaterFluxMin', -1)
         end if
      end if
! Define constituent var riverRunoffFluxMin
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_riverRunoffFluxMin', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_riverRunoffFluxMin', -1)
         end if
      end if
! Define constituent var iceRunoffFluxMin
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_iceRunoffFluxMin', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_iceRunoffFluxMin', -1)
         end if
      end if
! Define constituent var temperatureFluxMin
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureFluxMin', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureFluxMin', -1)
         end if
      end if
! Define constituent var salinityFluxMin
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityFluxMin', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityFluxMin', -1)
         end if
      end if
! Define constituent var salinityRestoringFluxMin
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityRestoringFluxMin', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityRestoringFluxMin', -1)
         end if
      end if
! Define constituent var landIceFreshwaterFluxMin
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_landIceFreshwaterFluxMin', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_landIceFreshwaterFluxMin', -1)
         end if
      end if
! Define constituent var accumulatedLandIceMassMin
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_accumulatedLandIceMassMin', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_accumulatedLandIceMassMin', -1)
         end if
      end if
! Define constituent var accumulatedLandIceHeatMin
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_accumulatedLandIceHeatMin', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_accumulatedLandIceHeatMin', -1)
         end if
      end if
! Define constituent var accumulatedLandIceFrazilMassMin
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_accumulatedLandIceFrazilMassMin', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_accumulatedLandIceFrazilMassMin', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'mins_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_minGlobalStats', numConstituents)
      end if
! Defining time level 1
      allocate( r1Ptr(1) % constituentNames(numConstituents) )
      r1Ptr(1) % fieldName = 'minGlobalStats'
      r1Ptr(1) % isDecomposed = .false.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isVarArray = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_layerThicknessMin', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'layerThicknessMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_normalVelocityMin', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'normalVelocityMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_tangentialVelocityMin', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'tangentialVelocityMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_layerThicknessEdgeMin', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'layerThicknessEdgeMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_relativeVorticityMin', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'relativeVorticityMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_enstrophyMin', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'enstrophyMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_kineticEnergyCellMin', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'kineticEnergyCellMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_normalizedAbsoluteVorticityMin', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'normalizedAbsoluteVorticityMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_pressureMin', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'pressureMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_montgomeryPotentialMin', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'montgomeryPotentialMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_vertVelocityTopMin', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'vertVelocityTopMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_vertAleTransportTopMin', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'vertAleTransportTopMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_lowFreqDivergenceMin', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'lowFreqDivergenceMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_highFreqThicknessMin', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'highFreqThicknessMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureMin', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'temperatureMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityMin', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'salinityMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_layerThicknessPreviousTimestepMin', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'layerThicknessPreviousTimestepMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_frazilLayerThicknessTendencyMin', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'frazilLayerThicknessTendencyMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_evaporationFluxMin', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'evaporationFluxMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_rainFluxMin', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'rainFluxMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_snowFluxMin', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'snowFluxMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_seaIceFreshWaterFluxMin', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'seaIceFreshWaterFluxMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_riverRunoffFluxMin', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'riverRunoffFluxMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_iceRunoffFluxMin', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'iceRunoffFluxMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureFluxMin', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'temperatureFluxMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityFluxMin', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'salinityFluxMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityRestoringFluxMin', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'salinityRestoringFluxMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_landIceFreshwaterFluxMin', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'landIceFreshwaterFluxMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_accumulatedLandIceMassMin', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'accumulatedLandIceMassMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_accumulatedLandIceHeatMin', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'accumulatedLandIceHeatMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_accumulatedLandIceFrazilMassMin', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'accumulatedLandIceFrazilMassMin'
      end if

! Setup dimensions for       
      r1Ptr(1) % dimNames(1) = 'num_minGlobalStats'

      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(size(r1Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r1Ptr(1) % constituentNames, dim=1)
         allocate(r1Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_layerThicknessMin', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum global value of layerThickness in '&
//'ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'layerThicknessMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_normalVelocityMin', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum global value of normalVelocity on '&
//'ocean edges.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'normalVelocityMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_tangentialVelocityMin', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum global value of tangentialVelocity on '&
//'ocean edges.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'tangentialVelocityMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_layerThicknessEdgeMin', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum global value of layerThicknessEdge on '&
//'ocean edges.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'layerThicknessEdgeMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_relativeVorticityMin', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum global value of relativeVorticity on '&
//'ocean vertices.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'relativeVorticityMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_enstrophyMin', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum global value of enstrophy in ocean '&
//'cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-2}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'enstrophyMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_kineticEnergyCellMin', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum global value of kineticEnergy in '&
//'ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm^2 s^{-2}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'kineticEnergyCellMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_normalizedAbsoluteVorticityMin', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum global value of '&
//'normalizedAbsoluteVorticity on ocean vertices.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'normalizedAbsoluteVorticityMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_pressureMin', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum global value of pressure in ocean '&
//'cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'N m^{-2}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'pressureMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_montgomeryPotentialMin', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum global value of the Montgomery '&
//'Potential in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm^2 s^{-2}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'montgomeryPotentialMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_vertVelocityTopMin', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum global value of vertVelocityTop in '&
//'ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'vertVelocityTopMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_vertAleTransportTopMin', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum global value of vertAleTransportTop '&
//'in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'vertAleTransportTopMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_lowFreqDivergenceMin', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum global value of lowFreqDivergence in '&
//'ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'lowFreqDivergenceMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_highFreqThicknessMin', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum global value of highFreqThickness in '&
//'ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'highFreqThicknessMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureMin', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum global value of temperature in ocean '&
//'cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', '^\circ C')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'temperatureMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityMin', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum global value of salinity in ocean '&
//'cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'PSU')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'salinityMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_layerThicknessPreviousTimestepMin', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum global value of previous step '&
//'layerThickness in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'layerThicknessPreviousTimestepMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_frazilLayerThicknessTendencyMin', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum global value of layer thickness '&
//'tendency due to frazil formation in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'frazilLayerThicknessTendencyMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_evaporationFluxMin', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum global value of evaporationFlux in '&
//'ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'evaporationFluxMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_rainFluxMin', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum global value of rainFlux in ocean '&
//'cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'rainFluxMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_snowFluxMin', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum global value of snowFlux in ocean '&
//'cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'snowFluxMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_seaIceFreshWaterFluxMin', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum global value of seaIceFreshWaterFlux '&
//'in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'seaIceFreshWaterFluxMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_riverRunoffFluxMin', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum global value of riverRunoffFlux in '&
//'ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'riverRunoffFluxMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_iceRunoffFluxMin', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum global value of iceRunoffFlux in '&
//'ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'iceRunoffFluxMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureFluxMin', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum global value of temperatureFlux in '&
//'ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'temperatureFluxMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityFluxMin', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum global value of salinityFlux in ocean '&
//'cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'salinityFluxMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityRestoringFluxMin', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum global value of salinityRestoringFlux '&
//'in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'salinityRestoringFluxMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_landIceFreshwaterFluxMin', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum global value of landIceFreshwaterFlux '&
//'in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'landIceFreshwaterFluxMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_accumulatedLandIceMassMin', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum global value of '&
//'accumulatedLandIceMass in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'accumulatedLandIceMassMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_accumulatedLandIceHeatMin', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum global value of '&
//'accumulatedLandIceHeat in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'J m^{-2}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'accumulatedLandIceHeatMin'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_accumulatedLandIceFrazilMassMin', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum global value of '&
//'accumulatedLandIceFrazilMass in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'accumulatedLandIceFrazilMassMin'
      end if
      r1Ptr(1) % block => block

      if (globalStatsAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'minGlobalStats', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'minGlobalStats', r1Ptr)

! Define var array maxGlobalStats
      allocate(r1Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group maxes
! Define constituent var layerThicknessMax
! My Packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_layerThicknessMax', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxes_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_layerThicknessMax', -1)
           end if
      end if
! Define constituent var normalVelocityMax
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_normalVelocityMax', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxes_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_normalVelocityMax', -1)
         end if
      end if
! Define constituent var tangentialVelocityMax
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_tangentialVelocityMax', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxes_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_tangentialVelocityMax', -1)
         end if
      end if
! Define constituent var layerThicknessEdgeMax
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_layerThicknessEdgeMax', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxes_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_layerThicknessEdgeMax', -1)
         end if
      end if
! Define constituent var relativeVorticityMax
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_relativeVorticityMax', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxes_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_relativeVorticityMax', -1)
         end if
      end if
! Define constituent var enstrophyMax
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_enstrophyMax', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxes_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_enstrophyMax', -1)
         end if
      end if
! Define constituent var kineticEnergyCellMax
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_kineticEnergyCellMax', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxes_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_kineticEnergyCellMax', -1)
         end if
      end if
! Define constituent var normalizedAbsoluteVorticityMax
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_normalizedAbsoluteVorticityMax', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxes_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_normalizedAbsoluteVorticityMax', -1)
         end if
      end if
! Define constituent var pressureMax
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_pressureMax', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxes_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_pressureMax', -1)
         end if
      end if
! Define constituent var montgomeryPotentialMax
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_montgomeryPotentialMax', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxes_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_montgomeryPotentialMax', -1)
         end if
      end if
! Define constituent var vertVelocityTopMax
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_vertVelocityTopMax', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxes_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_vertVelocityTopMax', -1)
         end if
      end if
! Define constituent var vertAleTransportTopMax
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_vertAleTransportTopMax', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxes_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_vertAleTransportTopMax', -1)
         end if
      end if
! Define constituent var lowFreqDivergenceMax
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_lowFreqDivergenceMax', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxes_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_lowFreqDivergenceMax', -1)
         end if
      end if
! Define constituent var highFreqThicknessMax
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_highFreqThicknessMax', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxes_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_highFreqThicknessMax', -1)
         end if
      end if
! Define constituent var temperatureMax
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureMax', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxes_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureMax', -1)
         end if
      end if
! Define constituent var salinityMax
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityMax', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxes_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityMax', -1)
         end if
      end if
! Define constituent var layerThicknessPreviousTimestepMax
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_layerThicknessPreviousTimestepMax', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxes_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_layerThicknessPreviousTimestepMax', -1)
         end if
      end if
! Define constituent var frazilLayerThicknessTendencyMax
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_frazilLayerThicknessTendencyMax', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxes_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_frazilLayerThicknessTendencyMax', -1)
         end if
      end if
! Define constituent var evaporationFluxMax
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_evaporationFluxMax', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxes_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_evaporationFluxMax', -1)
         end if
      end if
! Define constituent var rainFluxMax
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_rainFluxMax', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxes_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_rainFluxMax', -1)
         end if
      end if
! Define constituent var snowFluxMax
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_snowFluxMax', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxes_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_snowFluxMax', -1)
         end if
      end if
! Define constituent var seaIceFreshWaterFluxMax
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_seaIceFreshWaterFluxMax', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxes_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_seaIceFreshWaterFluxMax', -1)
         end if
      end if
! Define constituent var riverRunoffFluxMax
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_riverRunoffFluxMax', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxes_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_riverRunoffFluxMax', -1)
         end if
      end if
! Define constituent var iceRunoffFluxMax
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_iceRunoffFluxMax', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxes_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_iceRunoffFluxMax', -1)
         end if
      end if
! Define constituent var temperatureFluxMax
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureFluxMax', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxes_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureFluxMax', -1)
         end if
      end if
! Define constituent var salinityFluxMax
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityFluxMax', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxes_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityFluxMax', -1)
         end if
      end if
! Define constituent var salinityRestoringFluxMax
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityRestoringFluxMax', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxes_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityRestoringFluxMax', -1)
         end if
      end if
! Define constituent var landIceFreshwaterFluxMax
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_landIceFreshwaterFluxMax', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxes_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_landIceFreshwaterFluxMax', -1)
         end if
      end if
! Define constituent var accumulatedLandIceMassMax
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_accumulatedLandIceMassMax', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxes_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_accumulatedLandIceMassMax', -1)
         end if
      end if
! Define constituent var accumulatedLandIceHeatMax
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_accumulatedLandIceHeatMax', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxes_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_accumulatedLandIceHeatMax', -1)
         end if
      end if
! Define constituent var accumulatedLandIceFrazilMassMax
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_accumulatedLandIceFrazilMassMax', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxes_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_accumulatedLandIceFrazilMassMax', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxes_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'maxes_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxes_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_maxGlobalStats', numConstituents)
      end if
! Defining time level 1
      allocate( r1Ptr(1) % constituentNames(numConstituents) )
      r1Ptr(1) % fieldName = 'maxGlobalStats'
      r1Ptr(1) % isDecomposed = .false.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isVarArray = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_layerThicknessMax', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'layerThicknessMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_normalVelocityMax', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'normalVelocityMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_tangentialVelocityMax', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'tangentialVelocityMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_layerThicknessEdgeMax', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'layerThicknessEdgeMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_relativeVorticityMax', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'relativeVorticityMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_enstrophyMax', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'enstrophyMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_kineticEnergyCellMax', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'kineticEnergyCellMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_normalizedAbsoluteVorticityMax', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'normalizedAbsoluteVorticityMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_pressureMax', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'pressureMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_montgomeryPotentialMax', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'montgomeryPotentialMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_vertVelocityTopMax', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'vertVelocityTopMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_vertAleTransportTopMax', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'vertAleTransportTopMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_lowFreqDivergenceMax', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'lowFreqDivergenceMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_highFreqThicknessMax', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'highFreqThicknessMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureMax', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'temperatureMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityMax', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'salinityMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_layerThicknessPreviousTimestepMax', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'layerThicknessPreviousTimestepMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_frazilLayerThicknessTendencyMax', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'frazilLayerThicknessTendencyMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_evaporationFluxMax', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'evaporationFluxMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_rainFluxMax', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'rainFluxMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_snowFluxMax', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'snowFluxMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_seaIceFreshWaterFluxMax', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'seaIceFreshWaterFluxMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_riverRunoffFluxMax', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'riverRunoffFluxMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_iceRunoffFluxMax', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'iceRunoffFluxMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureFluxMax', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'temperatureFluxMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityFluxMax', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'salinityFluxMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityRestoringFluxMax', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'salinityRestoringFluxMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_landIceFreshwaterFluxMax', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'landIceFreshwaterFluxMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_accumulatedLandIceMassMax', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'accumulatedLandIceMassMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_accumulatedLandIceHeatMax', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'accumulatedLandIceHeatMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_accumulatedLandIceFrazilMassMax', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'accumulatedLandIceFrazilMassMax'
      end if

! Setup dimensions for       
      r1Ptr(1) % dimNames(1) = 'num_maxGlobalStats'

      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(size(r1Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r1Ptr(1) % constituentNames, dim=1)
         allocate(r1Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_layerThicknessMax', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum global value of layerThickness in '&
//'ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'layerThicknessMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_normalVelocityMax', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum global value of normalVelocity on '&
//'ocean edges.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'normalVelocityMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_tangentialVelocityMax', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum global value of tangentialVelocity on '&
//'ocean edges.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'tangentialVelocityMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_layerThicknessEdgeMax', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum global value of layerThicknessEdge on '&
//'ocean edges.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'layerThicknessEdgeMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_relativeVorticityMax', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum global value of relativeVorticity on '&
//'ocean vertices.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'relativeVorticityMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_enstrophyMax', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum global value of enstrophy in ocean '&
//'cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-2}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'enstrophyMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_kineticEnergyCellMax', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum global value of kineticEnergy in '&
//'ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm^2 s^{-2}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'kineticEnergyCellMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_normalizedAbsoluteVorticityMax', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum global value of '&
//'normalizedAbsoluteVorticity on ocean vertices.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'normalizedAbsoluteVorticityMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_pressureMax', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum global value of pressure in ocean '&
//'cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'N m^{-2}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'pressureMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_montgomeryPotentialMax', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum global value of the Montgomery '&
//'Potential in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm^2 s^{-2}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'montgomeryPotentialMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_vertVelocityTopMax', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum global value of vertVelocityTop in '&
//'ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'vertVelocityTopMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_vertAleTransportTopMax', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum global value of vertAleTransportTop '&
//'in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'vertAleTransportTopMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_lowFreqDivergenceMax', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum global value of lowFreqDivergence in '&
//'ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'lowFreqDivergenceMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_highFreqThicknessMax', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum global value of highFreqThickness in '&
//'ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'highFreqThicknessMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureMax', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum global value of temperature in ocean '&
//'cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', '^\circ C')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'temperatureMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityMax', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum global value of salinity in ocean '&
//'cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'PSU')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'salinityMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_layerThicknessPreviousTimestepMax', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum global value of previous step '&
//'layerThickness in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'layerThicknessPreviousTimestepMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_frazilLayerThicknessTendencyMax', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum global value of layer thickness '&
//'tendency due to frazil formation in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'frazilLayerThicknessTendencyMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_evaporationFluxMax', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum global value of evaporationFlux in '&
//'ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'evaporationFluxMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_rainFluxMax', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum global value of rainFlux in ocean '&
//'cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'rainFluxMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_snowFluxMax', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum global value of snowFlux in ocean '&
//'cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'snowFluxMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_seaIceFreshWaterFluxMax', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum global value of seaIceFreshWaterFlux '&
//'in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'seaIceFreshWaterFluxMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_riverRunoffFluxMax', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum global value of riverRunoffFlux in '&
//'ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'riverRunoffFluxMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_iceRunoffFluxMax', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum global value of iceRunoffFlux in '&
//'ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'iceRunoffFluxMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureFluxMax', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum global value of temperatureFlux in '&
//'ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'temperatureFluxMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityFluxMax', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum global value of salinityFlux in ocean '&
//'cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'salinityFluxMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityRestoringFluxMax', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum global value of salinityRestoringFlux '&
//'in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'salinityRestoringFluxMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_landIceFreshwaterFluxMax', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum global value of landIceFreshwaterFlux '&
//'in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'landIceFreshwaterFluxMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_accumulatedLandIceMassMax', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum global value of '&
//'accumulatedLandIceMass in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'accumulatedLandIceMassMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_accumulatedLandIceHeatMax', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum global value of '&
//'accumulatedLandIceHeat in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'J m^{-2}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'accumulatedLandIceHeatMax'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_accumulatedLandIceFrazilMassMax', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum global value of '&
//'accumulatedLandIceFrazilMass in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'accumulatedLandIceFrazilMassMax'
      end if
      r1Ptr(1) % block => block

      if (globalStatsAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'maxGlobalStats', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'maxGlobalStats', r1Ptr)

! Define var array sumGlobalStats
      allocate(r1Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group sums
! Define constituent var layerThicknessSum
! My Packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_layerThicknessSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'sums_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_layerThicknessSum', -1)
           end if
      end if
! Define constituent var normalVelocitySum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_normalVelocitySum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'sums_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_normalVelocitySum', -1)
         end if
      end if
! Define constituent var tangentialVelocitySum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_tangentialVelocitySum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'sums_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_tangentialVelocitySum', -1)
         end if
      end if
! Define constituent var layerThicknessEdgeSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_layerThicknessEdgeSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'sums_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_layerThicknessEdgeSum', -1)
         end if
      end if
! Define constituent var relativeVorticitySum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_relativeVorticitySum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'sums_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_relativeVorticitySum', -1)
         end if
      end if
! Define constituent var enstrophySum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_enstrophySum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'sums_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_enstrophySum', -1)
         end if
      end if
! Define constituent var kineticEnergyCellSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_kineticEnergyCellSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'sums_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_kineticEnergyCellSum', -1)
         end if
      end if
! Define constituent var normalizedAbsoluteVorticitySum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_normalizedAbsoluteVorticitySum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'sums_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_normalizedAbsoluteVorticitySum', -1)
         end if
      end if
! Define constituent var pressureSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_pressureSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'sums_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_pressureSum', -1)
         end if
      end if
! Define constituent var montgomeryPotentialSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_montgomeryPotentialSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'sums_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_montgomeryPotentialSum', -1)
         end if
      end if
! Define constituent var vertVelocityTopSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_vertVelocityTopSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'sums_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_vertVelocityTopSum', -1)
         end if
      end if
! Define constituent var vertAleTransportTopSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_vertAleTransportTopSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'sums_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_vertAleTransportTopSum', -1)
         end if
      end if
! Define constituent var lowFreqDivergenceSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_lowFreqDivergenceSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'sums_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_lowFreqDivergenceSum', -1)
         end if
      end if
! Define constituent var highFreqThicknessSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_highFreqThicknessSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'sums_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_highFreqThicknessSum', -1)
         end if
      end if
! Define constituent var temperatureSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'sums_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureSum', -1)
         end if
      end if
! Define constituent var salinitySum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinitySum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'sums_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinitySum', -1)
         end if
      end if
! Define constituent var layerThicknessPreviousTimestepSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_layerThicknessPreviousTimestepSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'sums_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_layerThicknessPreviousTimestepSum', -1)
         end if
      end if
! Define constituent var frazilLayerThicknessTendencySum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_frazilLayerThicknessTendencySum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'sums_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_frazilLayerThicknessTendencySum', -1)
         end if
      end if
! Define constituent var evaporationFluxSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_evaporationFluxSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'sums_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_evaporationFluxSum', -1)
         end if
      end if
! Define constituent var rainFluxSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_rainFluxSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'sums_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_rainFluxSum', -1)
         end if
      end if
! Define constituent var snowFluxSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_snowFluxSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'sums_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_snowFluxSum', -1)
         end if
      end if
! Define constituent var seaIceFreshWaterFluxSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_seaIceFreshWaterFluxSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'sums_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_seaIceFreshWaterFluxSum', -1)
         end if
      end if
! Define constituent var riverRunoffFluxSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_riverRunoffFluxSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'sums_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_riverRunoffFluxSum', -1)
         end if
      end if
! Define constituent var iceRunoffFluxSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_iceRunoffFluxSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'sums_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_iceRunoffFluxSum', -1)
         end if
      end if
! Define constituent var temperatureFluxSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureFluxSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'sums_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureFluxSum', -1)
         end if
      end if
! Define constituent var salinityFluxSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityFluxSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'sums_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityFluxSum', -1)
         end if
      end if
! Define constituent var salinityRestoringFluxSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityRestoringFluxSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'sums_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityRestoringFluxSum', -1)
         end if
      end if
! Define constituent var landIceFreshwaterFluxSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_landIceFreshwaterFluxSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'sums_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_landIceFreshwaterFluxSum', -1)
         end if
      end if
! Define constituent var accumulatedLandIceMassSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_accumulatedLandIceMassSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'sums_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_accumulatedLandIceMassSum', -1)
         end if
      end if
! Define constituent var accumulatedLandIceHeatSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_accumulatedLandIceHeatSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'sums_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_accumulatedLandIceHeatSum', -1)
         end if
      end if
! Define constituent var accumulatedLandIceFrazilMassSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_accumulatedLandIceFrazilMassSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'sums_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_accumulatedLandIceFrazilMassSum', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'sums_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'sums_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'sums_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_sumGlobalStats', numConstituents)
      end if
! Defining time level 1
      allocate( r1Ptr(1) % constituentNames(numConstituents) )
      r1Ptr(1) % fieldName = 'sumGlobalStats'
      r1Ptr(1) % isDecomposed = .false.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isVarArray = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_layerThicknessSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'layerThicknessSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_normalVelocitySum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'normalVelocitySum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_tangentialVelocitySum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'tangentialVelocitySum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_layerThicknessEdgeSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'layerThicknessEdgeSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_relativeVorticitySum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'relativeVorticitySum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_enstrophySum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'enstrophySum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_kineticEnergyCellSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'kineticEnergyCellSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_normalizedAbsoluteVorticitySum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'normalizedAbsoluteVorticitySum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_pressureSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'pressureSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_montgomeryPotentialSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'montgomeryPotentialSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_vertVelocityTopSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'vertVelocityTopSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_vertAleTransportTopSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'vertAleTransportTopSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_lowFreqDivergenceSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'lowFreqDivergenceSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_highFreqThicknessSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'highFreqThicknessSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'temperatureSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinitySum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'salinitySum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_layerThicknessPreviousTimestepSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'layerThicknessPreviousTimestepSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_frazilLayerThicknessTendencySum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'frazilLayerThicknessTendencySum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_evaporationFluxSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'evaporationFluxSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_rainFluxSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'rainFluxSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_snowFluxSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'snowFluxSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_seaIceFreshWaterFluxSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'seaIceFreshWaterFluxSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_riverRunoffFluxSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'riverRunoffFluxSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_iceRunoffFluxSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'iceRunoffFluxSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureFluxSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'temperatureFluxSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityFluxSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'salinityFluxSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityRestoringFluxSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'salinityRestoringFluxSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_landIceFreshwaterFluxSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'landIceFreshwaterFluxSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_accumulatedLandIceMassSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'accumulatedLandIceMassSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_accumulatedLandIceHeatSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'accumulatedLandIceHeatSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_accumulatedLandIceFrazilMassSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'accumulatedLandIceFrazilMassSum'
      end if

! Setup dimensions for       
      r1Ptr(1) % dimNames(1) = 'num_sumGlobalStats'

      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(size(r1Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r1Ptr(1) % constituentNames, dim=1)
         allocate(r1Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_layerThicknessSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Accumulated global value of layerThickness in '&
//'ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm^3')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'layerThicknessSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_normalVelocitySum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Accumulated global value of normalVelocity on '&
//'ocean edges.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm^4 s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'normalVelocitySum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_tangentialVelocitySum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Accumulated global value of '&
//'tangentialVelocity on ocean edges.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm^4 s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'tangentialVelocitySum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_layerThicknessEdgeSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Accumulated global value of '&
//'layerThicknessEdge on ocean edges.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm^3')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'layerThicknessEdgeSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_relativeVorticitySum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Accumulated global value of relativeVorticity '&
//'on ocean vertices.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm^2 s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'relativeVorticitySum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_enstrophySum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Accumulated global value of enstrophy in '&
//'ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm^2 s^{-2}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'enstrophySum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_kineticEnergyCellSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Accumulated global value of kineticEnergy in '&
//'ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm^5 s^{-2}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'kineticEnergyCellSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_normalizedAbsoluteVorticitySum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Accumulated global value of '&
//'normalizedAbsoluteVorticity on ocean vertices.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm^3 s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'normalizedAbsoluteVorticitySum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_pressureSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Accumulated global value of pressure in ocean '&
//'cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'N m')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'pressureSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_montgomeryPotentialSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Accumulated global value of the Montgomery '&
//'Potential in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm^5 s^{-2}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'montgomeryPotentialSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_vertVelocityTopSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Accumulated global value of vertVelocityTop '&
//'in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm^4 s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'vertVelocityTopSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_vertAleTransportTopSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Accumulated global value of '&
//'vertAleTransportTop in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm^4 s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'vertAleTransportTopSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_lowFreqDivergenceSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Accumulated global value of lowFreqDivergence '&
//'in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm^3 s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'lowFreqDivergenceSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_highFreqThicknessSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Accumulated global value of highFreqThickness '&
//'in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm^4')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'highFreqThicknessSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Accumulated global value of temperature in '&
//'ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm^3 ^\circ C')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'temperatureSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinitySum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Accumulated global value of salinity in ocean '&
//'cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm^3 PSU')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'salinitySum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_layerThicknessPreviousTimestepSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Accumulated global value of previous step '&
//'layerThickness in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm^3')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'layerThicknessPreviousTimestepSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_frazilLayerThicknessTendencySum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Accumulated global value of layer thickness '&
//'tendency due to frazil formation in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm^3 s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'frazilLayerThicknessTendencySum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_evaporationFluxSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Accumulated global value of evaporationFlux '&
//'in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'evaporationFluxSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_rainFluxSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Accumulated global value of rainFlux in ocean '&
//'cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'rainFluxSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_snowFluxSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Accumulated global value of snowFlux in ocean '&
//'cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'snowFluxSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_seaIceFreshWaterFluxSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Accumulated global value of '&
//'seaIceFreshWaterFlux in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'seaIceFreshWaterFluxSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_riverRunoffFluxSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Accumulated global value of riverRunoffFlux '&
//'in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'riverRunoffFluxSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_iceRunoffFluxSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Accumulated global value of iceRunoffFlux in '&
//'ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'iceRunoffFluxSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureFluxSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Accumulated global value of temperatureFlux '&
//'in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'temperatureFluxSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityFluxSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Accumulated global value of salinityFlux in '&
//'ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'salinityFluxSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityRestoringFluxSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Accumulated global value of '&
//'salinityRestoringFlux in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'salinityRestoringFluxSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_landIceFreshwaterFluxSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Accumulated global value of '&
//'landIceFreshwaterFlux in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'landIceFreshwaterFluxSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_accumulatedLandIceMassSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Accumulated global value of '&
//'accumulatedLandIceMass in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'accumulatedLandIceMassSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_accumulatedLandIceHeatSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Accumulated global value of '&
//'accumulatedLandIceHeat in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'J')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'accumulatedLandIceHeatSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_accumulatedLandIceFrazilMassSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Accumulated global value of '&
//'accumulatedLandIceFrazilMass in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'accumulatedLandIceFrazilMassSum'
      end if
      r1Ptr(1) % block => block

      if (globalStatsAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'sumGlobalStats', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'sumGlobalStats', r1Ptr)

! Define var array rmsGlobalStats
      allocate(r1Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group rms
! Define constituent var layerThicknessRms
! My Packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_layerThicknessRms', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'rms_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_layerThicknessRms', -1)
           end if
      end if
! Define constituent var normalVelocityRms
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_normalVelocityRms', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'rms_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_normalVelocityRms', -1)
         end if
      end if
! Define constituent var tangentialVelocityRms
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_tangentialVelocityRms', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'rms_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_tangentialVelocityRms', -1)
         end if
      end if
! Define constituent var layerThicknessEdgeRms
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_layerThicknessEdgeRms', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'rms_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_layerThicknessEdgeRms', -1)
         end if
      end if
! Define constituent var relativeVorticityRms
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_relativeVorticityRms', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'rms_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_relativeVorticityRms', -1)
         end if
      end if
! Define constituent var enstrophyRms
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_enstrophyRms', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'rms_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_enstrophyRms', -1)
         end if
      end if
! Define constituent var kineticEnergyCellRms
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_kineticEnergyCellRms', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'rms_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_kineticEnergyCellRms', -1)
         end if
      end if
! Define constituent var normalizedAbsoluteVorticityRms
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_normalizedAbsoluteVorticityRms', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'rms_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_normalizedAbsoluteVorticityRms', -1)
         end if
      end if
! Define constituent var pressureRms
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_pressureRms', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'rms_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_pressureRms', -1)
         end if
      end if
! Define constituent var montgomeryPotentialRms
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_montgomeryPotentialRms', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'rms_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_montgomeryPotentialRms', -1)
         end if
      end if
! Define constituent var vertVelocityTopRms
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_vertVelocityTopRms', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'rms_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_vertVelocityTopRms', -1)
         end if
      end if
! Define constituent var vertAleTransportTopRms
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_vertAleTransportTopRms', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'rms_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_vertAleTransportTopRms', -1)
         end if
      end if
! Define constituent var lowFreqDivergenceRms
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_lowFreqDivergenceRms', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'rms_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_lowFreqDivergenceRms', -1)
         end if
      end if
! Define constituent var highFreqThicknessRms
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_highFreqThicknessRms', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'rms_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_highFreqThicknessRms', -1)
         end if
      end if
! Define constituent var temperatureRms
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureRms', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'rms_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureRms', -1)
         end if
      end if
! Define constituent var salinityRms
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityRms', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'rms_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityRms', -1)
         end if
      end if
! Define constituent var layerThicknessPreviousTimestepRms
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_layerThicknessPreviousTimestepRms', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'rms_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_layerThicknessPreviousTimestepRms', -1)
         end if
      end if
! Define constituent var frazilLayerThicknessTendencyRms
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_frazilLayerThicknessTendencyRms', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'rms_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_frazilLayerThicknessTendencyRms', -1)
         end if
      end if
! Define constituent var evaporationFluxRms
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_evaporationFluxRms', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'rms_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_evaporationFluxRms', -1)
         end if
      end if
! Define constituent var rainFluxRms
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_rainFluxRms', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'rms_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_rainFluxRms', -1)
         end if
      end if
! Define constituent var snowFluxRms
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_snowFluxRms', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'rms_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_snowFluxRms', -1)
         end if
      end if
! Define constituent var seaIceFreshWaterFluxRms
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_seaIceFreshWaterFluxRms', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'rms_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_seaIceFreshWaterFluxRms', -1)
         end if
      end if
! Define constituent var riverRunoffFluxRms
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_riverRunoffFluxRms', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'rms_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_riverRunoffFluxRms', -1)
         end if
      end if
! Define constituent var iceRunoffFluxRms
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_iceRunoffFluxRms', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'rms_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_iceRunoffFluxRms', -1)
         end if
      end if
! Define constituent var temperatureFluxRms
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureFluxRms', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'rms_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureFluxRms', -1)
         end if
      end if
! Define constituent var salinityFluxRms
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityFluxRms', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'rms_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityFluxRms', -1)
         end if
      end if
! Define constituent var salinityRestoringFluxRms
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityRestoringFluxRms', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'rms_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityRestoringFluxRms', -1)
         end if
      end if
! Define constituent var landIceFreshwaterFluxRms
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_landIceFreshwaterFluxRms', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'rms_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_landIceFreshwaterFluxRms', -1)
         end if
      end if
! Define constituent var accumulatedLandIceMassRms
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_accumulatedLandIceMassRms', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'rms_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_accumulatedLandIceMassRms', -1)
         end if
      end if
! Define constituent var accumulatedLandIceHeatRms
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_accumulatedLandIceHeatRms', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'rms_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_accumulatedLandIceHeatRms', -1)
         end if
      end if
! Define constituent var accumulatedLandIceFrazilMassRms
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_accumulatedLandIceFrazilMassRms', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'rms_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_accumulatedLandIceFrazilMassRms', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'rms_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'rms_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'rms_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_rmsGlobalStats', numConstituents)
      end if
! Defining time level 1
      allocate( r1Ptr(1) % constituentNames(numConstituents) )
      r1Ptr(1) % fieldName = 'rmsGlobalStats'
      r1Ptr(1) % isDecomposed = .false.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isVarArray = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_layerThicknessRms', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'layerThicknessRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_normalVelocityRms', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'normalVelocityRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_tangentialVelocityRms', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'tangentialVelocityRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_layerThicknessEdgeRms', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'layerThicknessEdgeRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_relativeVorticityRms', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'relativeVorticityRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_enstrophyRms', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'enstrophyRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_kineticEnergyCellRms', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'kineticEnergyCellRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_normalizedAbsoluteVorticityRms', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'normalizedAbsoluteVorticityRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_pressureRms', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'pressureRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_montgomeryPotentialRms', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'montgomeryPotentialRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_vertVelocityTopRms', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'vertVelocityTopRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_vertAleTransportTopRms', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'vertAleTransportTopRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_lowFreqDivergenceRms', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'lowFreqDivergenceRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_highFreqThicknessRms', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'highFreqThicknessRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureRms', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'temperatureRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityRms', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'salinityRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_layerThicknessPreviousTimestepRms', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'layerThicknessPreviousTimestepRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_frazilLayerThicknessTendencyRms', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'frazilLayerThicknessTendencyRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_evaporationFluxRms', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'evaporationFluxRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_rainFluxRms', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'rainFluxRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_snowFluxRms', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'snowFluxRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_seaIceFreshWaterFluxRms', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'seaIceFreshWaterFluxRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_riverRunoffFluxRms', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'riverRunoffFluxRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_iceRunoffFluxRms', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'iceRunoffFluxRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureFluxRms', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'temperatureFluxRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityFluxRms', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'salinityFluxRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityRestoringFluxRms', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'salinityRestoringFluxRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_landIceFreshwaterFluxRms', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'landIceFreshwaterFluxRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_accumulatedLandIceMassRms', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'accumulatedLandIceMassRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_accumulatedLandIceHeatRms', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'accumulatedLandIceHeatRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_accumulatedLandIceFrazilMassRms', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'accumulatedLandIceFrazilMassRms'
      end if

! Setup dimensions for       
      r1Ptr(1) % dimNames(1) = 'num_rmsGlobalStats'

      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(size(r1Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r1Ptr(1) % constituentNames, dim=1)
         allocate(r1Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_layerThicknessRms', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Global root mean square value of '&
//'layerThickness in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'layerThicknessRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_normalVelocityRms', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Global root mean square value of '&
//'normalVelocity on ocean edges.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'normalVelocityRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_tangentialVelocityRms', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Global root mean square value of '&
//'tangentialVelocity on ocean edges.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'tangentialVelocityRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_layerThicknessEdgeRms', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Global root mean square value of '&
//'layerThicknessEdge on ocean edges.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'layerThicknessEdgeRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_relativeVorticityRms', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Global root mean square value of '&
//'relativeVorticity on ocean vertices.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'relativeVorticityRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_enstrophyRms', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Global root mean square value of enstrophy in '&
//'ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-2}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'enstrophyRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_kineticEnergyCellRms', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Global root mean square value of '&
//'kineticEnergy in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm^2 s^{-2}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'kineticEnergyCellRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_normalizedAbsoluteVorticityRms', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Global root mean square value of '&
//'normalizedAbsoluteVorticity on ocean vertices.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'normalizedAbsoluteVorticityRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_pressureRms', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Global root mean square value of pressure in '&
//'ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'N m^{-2}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'pressureRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_montgomeryPotentialRms', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Global root mean square value of the '&
//'Montgomery Potential in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm^2 s^{-2}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'montgomeryPotentialRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_vertVelocityTopRms', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Global root mean square value of '&
//'vertVelocityTop in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'vertVelocityTopRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_vertAleTransportTopRms', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Global root mean square value of '&
//'vertAleTransportTop in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'vertAleTransportTopRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_lowFreqDivergenceRms', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Global root mean square value of '&
//'lowFreqDivergence in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'lowFreqDivergenceRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_highFreqThicknessRms', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Global root mean square value of '&
//'highFreqThickness in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'highFreqThicknessRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureRms', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Global root mean square value of temperature '&
//'in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', '^\circ C')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'temperatureRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityRms', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Global root mean square value of salinity in '&
//'ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'PSU')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'salinityRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_layerThicknessPreviousTimestepRms', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Global root mean square value of previous '&
//'step layerThickness in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'layerThicknessPreviousTimestepRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_frazilLayerThicknessTendencyRms', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Global root mean square value of layer '&
//'thickness tendency due to frazil formation in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'frazilLayerThicknessTendencyRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_evaporationFluxRms', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Global root mean square value of '&
//'evaporationFlux in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'evaporationFluxRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_rainFluxRms', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Global root mean square value of rainFlux in '&
//'ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'rainFluxRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_snowFluxRms', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Global root mean square value of snowFlux in '&
//'ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'snowFluxRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_seaIceFreshWaterFluxRms', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Global root mean square value of '&
//'seaIceFreshWaterFlux in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'seaIceFreshWaterFluxRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_riverRunoffFluxRms', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Global root mean square value of '&
//'riverRunoffFlux in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'riverRunoffFluxRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_iceRunoffFluxRms', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Global root mean square value of '&
//'iceRunoffFlux in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'iceRunoffFluxRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureFluxRms', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Global root mean square value of '&
//'temperatureFlux in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'temperatureFluxRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityFluxRms', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Global root mean square value of salinityFlux '&
//'in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'salinityFluxRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityRestoringFluxRms', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Global root mean square value of '&
//'salinityRestoringFlux in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'salinityRestoringFluxRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_landIceFreshwaterFluxRms', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Global root mean square value of '&
//'landIceFreshwaterFlux in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'landIceFreshwaterFluxRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_accumulatedLandIceMassRms', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Global root mean square value of '&
//'accumulatedLandIceMass in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'accumulatedLandIceMassRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_accumulatedLandIceHeatRms', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Global root mean square value of '&
//'accumulatedLandIceHeat in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'J m^{-2}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'accumulatedLandIceHeatRms'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_accumulatedLandIceFrazilMassRms', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Global root mean square value of '&
//'accumulatedLandIceFrazilMass in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'accumulatedLandIceFrazilMassRms'
      end if
      r1Ptr(1) % block => block

      if (globalStatsAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'rmsGlobalStats', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'rmsGlobalStats', r1Ptr)

! Define var array avgGlobalStats
      allocate(r1Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group avg
! Define constituent var layerThicknessAvg
! My Packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_layerThicknessAvg', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_layerThicknessAvg', -1)
           end if
      end if
! Define constituent var normalVelocityAvg
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_normalVelocityAvg', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_normalVelocityAvg', -1)
         end if
      end if
! Define constituent var tangentialVelocityAvg
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_tangentialVelocityAvg', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_tangentialVelocityAvg', -1)
         end if
      end if
! Define constituent var layerThicknessEdgeAvg
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_layerThicknessEdgeAvg', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_layerThicknessEdgeAvg', -1)
         end if
      end if
! Define constituent var relativeVorticityAvg
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_relativeVorticityAvg', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_relativeVorticityAvg', -1)
         end if
      end if
! Define constituent var enstrophyAvg
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_enstrophyAvg', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_enstrophyAvg', -1)
         end if
      end if
! Define constituent var kineticEnergyCellAvg
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_kineticEnergyCellAvg', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_kineticEnergyCellAvg', -1)
         end if
      end if
! Define constituent var normalizedAbsoluteVorticityAvg
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_normalizedAbsoluteVorticityAvg', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_normalizedAbsoluteVorticityAvg', -1)
         end if
      end if
! Define constituent var pressureAvg
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_pressureAvg', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_pressureAvg', -1)
         end if
      end if
! Define constituent var montgomeryPotentialAvg
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_montgomeryPotentialAvg', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_montgomeryPotentialAvg', -1)
         end if
      end if
! Define constituent var vertVelocityTopAvg
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_vertVelocityTopAvg', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_vertVelocityTopAvg', -1)
         end if
      end if
! Define constituent var vertAleTransportTopAvg
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_vertAleTransportTopAvg', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_vertAleTransportTopAvg', -1)
         end if
      end if
! Define constituent var lowFreqDivergenceAvg
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_lowFreqDivergenceAvg', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_lowFreqDivergenceAvg', -1)
         end if
      end if
! Define constituent var highFreqThicknessAvg
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_highFreqThicknessAvg', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_highFreqThicknessAvg', -1)
         end if
      end if
! Define constituent var temperatureAvg
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureAvg', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureAvg', -1)
         end if
      end if
! Define constituent var salinityAvg
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityAvg', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityAvg', -1)
         end if
      end if
! Define constituent var layerThicknessPreviousTimestepAvg
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_layerThicknessPreviousTimestepAvg', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_layerThicknessPreviousTimestepAvg', -1)
         end if
      end if
! Define constituent var frazilLayerThicknessTendencyAvg
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_frazilLayerThicknessTendencyAvg', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_frazilLayerThicknessTendencyAvg', -1)
         end if
      end if
! Define constituent var evaporationFluxAvg
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_evaporationFluxAvg', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_evaporationFluxAvg', -1)
         end if
      end if
! Define constituent var rainFluxAvg
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_rainFluxAvg', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_rainFluxAvg', -1)
         end if
      end if
! Define constituent var snowFluxAvg
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_snowFluxAvg', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_snowFluxAvg', -1)
         end if
      end if
! Define constituent var seaIceFreshWaterFluxAvg
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_seaIceFreshWaterFluxAvg', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_seaIceFreshWaterFluxAvg', -1)
         end if
      end if
! Define constituent var riverRunoffFluxAvg
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_riverRunoffFluxAvg', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_riverRunoffFluxAvg', -1)
         end if
      end if
! Define constituent var iceRunoffFluxAvg
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_iceRunoffFluxAvg', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_iceRunoffFluxAvg', -1)
         end if
      end if
! Define constituent var temperatureFluxAvg
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureFluxAvg', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureFluxAvg', -1)
         end if
      end if
! Define constituent var salinityFluxAvg
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityFluxAvg', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityFluxAvg', -1)
         end if
      end if
! Define constituent var salinityRestoringFluxAvg
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityRestoringFluxAvg', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityRestoringFluxAvg', -1)
         end if
      end if
! Define constituent var landIceFreshwaterFluxAvg
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_landIceFreshwaterFluxAvg', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_landIceFreshwaterFluxAvg', -1)
         end if
      end if
! Define constituent var accumulatedLandIceMassAvg
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_accumulatedLandIceMassAvg', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_accumulatedLandIceMassAvg', -1)
         end if
      end if
! Define constituent var accumulatedLandIceHeatAvg
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_accumulatedLandIceHeatAvg', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_accumulatedLandIceHeatAvg', -1)
         end if
      end if
! Define constituent var accumulatedLandIceFrazilMassAvg
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_accumulatedLandIceFrazilMassAvg', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_accumulatedLandIceFrazilMassAvg', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'avg_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_avgGlobalStats', numConstituents)
      end if
! Defining time level 1
      allocate( r1Ptr(1) % constituentNames(numConstituents) )
      r1Ptr(1) % fieldName = 'avgGlobalStats'
      r1Ptr(1) % isDecomposed = .false.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isVarArray = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_layerThicknessAvg', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'layerThicknessAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_normalVelocityAvg', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'normalVelocityAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_tangentialVelocityAvg', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'tangentialVelocityAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_layerThicknessEdgeAvg', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'layerThicknessEdgeAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_relativeVorticityAvg', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'relativeVorticityAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_enstrophyAvg', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'enstrophyAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_kineticEnergyCellAvg', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'kineticEnergyCellAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_normalizedAbsoluteVorticityAvg', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'normalizedAbsoluteVorticityAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_pressureAvg', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'pressureAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_montgomeryPotentialAvg', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'montgomeryPotentialAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_vertVelocityTopAvg', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'vertVelocityTopAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_vertAleTransportTopAvg', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'vertAleTransportTopAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_lowFreqDivergenceAvg', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'lowFreqDivergenceAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_highFreqThicknessAvg', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'highFreqThicknessAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureAvg', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'temperatureAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityAvg', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'salinityAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_layerThicknessPreviousTimestepAvg', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'layerThicknessPreviousTimestepAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_frazilLayerThicknessTendencyAvg', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'frazilLayerThicknessTendencyAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_evaporationFluxAvg', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'evaporationFluxAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_rainFluxAvg', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'rainFluxAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_snowFluxAvg', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'snowFluxAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_seaIceFreshWaterFluxAvg', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'seaIceFreshWaterFluxAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_riverRunoffFluxAvg', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'riverRunoffFluxAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_iceRunoffFluxAvg', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'iceRunoffFluxAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureFluxAvg', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'temperatureFluxAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityFluxAvg', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'salinityFluxAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityRestoringFluxAvg', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'salinityRestoringFluxAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_landIceFreshwaterFluxAvg', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'landIceFreshwaterFluxAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_accumulatedLandIceMassAvg', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'accumulatedLandIceMassAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_accumulatedLandIceHeatAvg', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'accumulatedLandIceHeatAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_accumulatedLandIceFrazilMassAvg', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'accumulatedLandIceFrazilMassAvg'
      end if

! Setup dimensions for       
      r1Ptr(1) % dimNames(1) = 'num_avgGlobalStats'

      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(size(r1Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r1Ptr(1) % constituentNames, dim=1)
         allocate(r1Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_layerThicknessAvg', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average value of layerThickness in ocean '&
//'cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'layerThicknessAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_normalVelocityAvg', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average value of normalVelocity on ocean '&
//'edges.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'normalVelocityAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_tangentialVelocityAvg', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average value of tangentialVelocity on ocean '&
//'edges.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'tangentialVelocityAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_layerThicknessEdgeAvg', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average value of layerThicknessEdge on ocean '&
//'edges.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'layerThicknessEdgeAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_relativeVorticityAvg', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average value of relativeVorticity on ocean '&
//'vertices.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'relativeVorticityAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_enstrophyAvg', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average value of enstrophy in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-2}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'enstrophyAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_kineticEnergyCellAvg', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average value of kineticEnergy in ocean '&
//'cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm^2 s^{-2}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'kineticEnergyCellAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_normalizedAbsoluteVorticityAvg', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average value of normalizedAbsoluteVorticity '&
//'on ocean vertices.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'normalizedAbsoluteVorticityAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_pressureAvg', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average value of pressure in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'N m^{-2}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'pressureAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_montgomeryPotentialAvg', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average value of the Montgomery Potential in '&
//'ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm^2 s^{-2}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'montgomeryPotentialAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_vertVelocityTopAvg', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average value of vertVelocityTop in ocean '&
//'cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'vertVelocityTopAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_vertAleTransportTopAvg', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average value of vertAleTransportTop in ocean '&
//'cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'vertAleTransportTopAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_lowFreqDivergenceAvg', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average value of lowFreqDivergence in ocean '&
//'cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'lowFreqDivergenceAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_highFreqThicknessAvg', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average value of highFreqThickness in ocean '&
//'cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'highFreqThicknessAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureAvg', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average value of temperature in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', '^\circ C')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'temperatureAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityAvg', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average value of salinity in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'PSU')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'salinityAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_layerThicknessPreviousTimestepAvg', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average value of previous step layerThickness '&
//'in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'layerThicknessPreviousTimestepAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_frazilLayerThicknessTendencyAvg', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average value of layer thickness tendency due '&
//'to frazil formation in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'frazilLayerThicknessTendencyAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_evaporationFluxAvg', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average value of evaporationFlux in ocean '&
//'cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'evaporationFluxAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_rainFluxAvg', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average value of rainFlux in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'rainFluxAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_snowFluxAvg', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average value of snowFlux in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'snowFluxAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_seaIceFreshWaterFluxAvg', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average value of seaIceFreshWaterFlux in '&
//'ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'seaIceFreshWaterFluxAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_riverRunoffFluxAvg', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average value of riverRunoffFlux in ocean '&
//'cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'riverRunoffFluxAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_iceRunoffFluxAvg', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average value of iceRunoffFlux in ocean '&
//'cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'iceRunoffFluxAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureFluxAvg', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average value of temperatureFlux in ocean '&
//'cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'temperatureFluxAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityFluxAvg', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average value of salinityFlux in ocean '&
//'cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'salinityFluxAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityRestoringFluxAvg', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average value of salinityRestoringFlux in '&
//'ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'salinityRestoringFluxAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_landIceFreshwaterFluxAvg', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average value of landIceFreshwaterFlux in '&
//'ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'landIceFreshwaterFluxAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_accumulatedLandIceMassAvg', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average value of accumulatedLandIceMass in '&
//'ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'accumulatedLandIceMassAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_accumulatedLandIceHeatAvg', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average value of accumulatedLandIceHeat in '&
//'ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'J m^{-2}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'accumulatedLandIceHeatAvg'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_accumulatedLandIceFrazilMassAvg', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average value of accumulatedLandIceFrazilMass '&
//'in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'accumulatedLandIceFrazilMassAvg'
      end if
      r1Ptr(1) % block => block

      if (globalStatsAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'avgGlobalStats', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'avgGlobalStats', r1Ptr)

! Define var array vertSumMinGlobalStats
      allocate(r1Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group vertSumMin
! Define constituent var layerThicknessMinVertSum
! My Packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_layerThicknessMinVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMin_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_layerThicknessMinVertSum', -1)
           end if
      end if
! Define constituent var normalVelocityMinVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_normalVelocityMinVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMin_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_normalVelocityMinVertSum', -1)
         end if
      end if
! Define constituent var tangentialVelocityMinVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_tangentialVelocityMinVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMin_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_tangentialVelocityMinVertSum', -1)
         end if
      end if
! Define constituent var layerThicknessEdgeMinVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_layerThicknessEdgeMinVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMin_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_layerThicknessEdgeMinVertSum', -1)
         end if
      end if
! Define constituent var relativeVorticityMinVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_relativeVorticityMinVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMin_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_relativeVorticityMinVertSum', -1)
         end if
      end if
! Define constituent var enstrophyMinVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_enstrophyMinVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMin_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_enstrophyMinVertSum', -1)
         end if
      end if
! Define constituent var kineticEnergyCellMinVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_kineticEnergyCellMinVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMin_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_kineticEnergyCellMinVertSum', -1)
         end if
      end if
! Define constituent var normalizedAbsoluteVorticityMinVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_normalizedAbsoluteVorticityMinVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMin_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_normalizedAbsoluteVorticityMinVertSum', -1)
         end if
      end if
! Define constituent var pressureMinVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_pressureMinVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMin_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_pressureMinVertSum', -1)
         end if
      end if
! Define constituent var montgomeryPotentialMinVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_montgomeryPotentialMinVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMin_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_montgomeryPotentialMinVertSum', -1)
         end if
      end if
! Define constituent var vertVelocityTopMinVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_vertVelocityTopMinVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMin_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_vertVelocityTopMinVertSum', -1)
         end if
      end if
! Define constituent var vertAleTransportTopMinVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_vertAleTransportTopMinVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMin_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_vertAleTransportTopMinVertSum', -1)
         end if
      end if
! Define constituent var lowFreqDivergenceMinVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_lowFreqDivergenceMinVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMin_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_lowFreqDivergenceMinVertSum', -1)
         end if
      end if
! Define constituent var highFreqThicknessMinVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_highFreqThicknessMinVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMin_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_highFreqThicknessMinVertSum', -1)
         end if
      end if
! Define constituent var temperatureMinVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureMinVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMin_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureMinVertSum', -1)
         end if
      end if
! Define constituent var salinityMinVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityMinVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMin_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityMinVertSum', -1)
         end if
      end if
! Define constituent var layerThicknessPreviousTimestepMinVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_layerThicknessPreviousTimestepMinVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMin_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_layerThicknessPreviousTimestepMinVertSum', -1)
         end if
      end if
! Define constituent var frazilLayerThicknessTendencyMinVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_frazilLayerThicknessTendencyMinVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMin_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_frazilLayerThicknessTendencyMinVertSum', -1)
         end if
      end if
! Define constituent var evaporationFluxMinVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_evaporationFluxMinVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMin_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_evaporationFluxMinVertSum', -1)
         end if
      end if
! Define constituent var rainFluxMinVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_rainFluxMinVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMin_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_rainFluxMinVertSum', -1)
         end if
      end if
! Define constituent var snowFluxMinVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_snowFluxMinVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMin_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_snowFluxMinVertSum', -1)
         end if
      end if
! Define constituent var seaIceFreshWaterFluxMinVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_seaIceFreshWaterFluxMinVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMin_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_seaIceFreshWaterFluxMinVertSum', -1)
         end if
      end if
! Define constituent var riverRunoffFluxMinVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_riverRunoffFluxMinVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMin_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_riverRunoffFluxMinVertSum', -1)
         end if
      end if
! Define constituent var iceRunoffFluxMinVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_iceRunoffFluxMinVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMin_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_iceRunoffFluxMinVertSum', -1)
         end if
      end if
! Define constituent var temperatureFluxMinVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureFluxMinVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMin_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureFluxMinVertSum', -1)
         end if
      end if
! Define constituent var salinityFluxMinVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityFluxMinVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMin_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityFluxMinVertSum', -1)
         end if
      end if
! Define constituent var salinityRestoringFluxMinVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityRestoringFluxMinVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMin_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityRestoringFluxMinVertSum', -1)
         end if
      end if
! Define constituent var landIceFreshwaterFluxMinVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_landIceFreshwaterFluxMinVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMin_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_landIceFreshwaterFluxMinVertSum', -1)
         end if
      end if
! Define constituent var accumulatedLandIceMassMinVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_accumulatedLandIceMassMinVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMin_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_accumulatedLandIceMassMinVertSum', -1)
         end if
      end if
! Define constituent var accumulatedLandIceHeatMinVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_accumulatedLandIceHeatMinVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMin_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_accumulatedLandIceHeatMinVertSum', -1)
         end if
      end if
! Define constituent var accumulatedLandIceFrazilMassMinVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_accumulatedLandIceFrazilMassMinVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMin_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_accumulatedLandIceFrazilMassMinVertSum', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMin_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'vertSumMin_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMin_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_vertSumMinGlobalStats', numConstituents)
      end if
! Defining time level 1
      allocate( r1Ptr(1) % constituentNames(numConstituents) )
      r1Ptr(1) % fieldName = 'vertSumMinGlobalStats'
      r1Ptr(1) % isDecomposed = .false.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isVarArray = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_layerThicknessMinVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'layerThicknessMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_normalVelocityMinVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'normalVelocityMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_tangentialVelocityMinVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'tangentialVelocityMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_layerThicknessEdgeMinVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'layerThicknessEdgeMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_relativeVorticityMinVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'relativeVorticityMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_enstrophyMinVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'enstrophyMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_kineticEnergyCellMinVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'kineticEnergyCellMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_normalizedAbsoluteVorticityMinVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'normalizedAbsoluteVorticityMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_pressureMinVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'pressureMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_montgomeryPotentialMinVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'montgomeryPotentialMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_vertVelocityTopMinVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'vertVelocityTopMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_vertAleTransportTopMinVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'vertAleTransportTopMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_lowFreqDivergenceMinVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'lowFreqDivergenceMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_highFreqThicknessMinVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'highFreqThicknessMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureMinVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'temperatureMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityMinVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'salinityMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_layerThicknessPreviousTimestepMinVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'layerThicknessPreviousTimestepMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_frazilLayerThicknessTendencyMinVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'frazilLayerThicknessTendencyMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_evaporationFluxMinVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'evaporationFluxMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_rainFluxMinVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'rainFluxMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_snowFluxMinVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'snowFluxMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_seaIceFreshWaterFluxMinVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'seaIceFreshWaterFluxMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_riverRunoffFluxMinVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'riverRunoffFluxMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_iceRunoffFluxMinVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'iceRunoffFluxMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureFluxMinVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'temperatureFluxMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityFluxMinVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'salinityFluxMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityRestoringFluxMinVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'salinityRestoringFluxMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_landIceFreshwaterFluxMinVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'landIceFreshwaterFluxMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_accumulatedLandIceMassMinVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'accumulatedLandIceMassMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_accumulatedLandIceHeatMinVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'accumulatedLandIceHeatMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_accumulatedLandIceFrazilMassMinVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'accumulatedLandIceFrazilMassMinVertSum'
      end if

! Setup dimensions for       
      r1Ptr(1) % dimNames(1) = 'num_vertSumMinGlobalStats'

      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(size(r1Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r1Ptr(1) % constituentNames, dim=1)
         allocate(r1Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_layerThicknessMinVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum vertical sum of layerThickness in '&
//'ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'layerThicknessMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_normalVelocityMinVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum vertical sum of normalVelocity on '&
//'ocean edges.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm^2 s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'normalVelocityMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_tangentialVelocityMinVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum vertical sum of tangentialVelocity on '&
//'ocean edges.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm^2 s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'tangentialVelocityMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_layerThicknessEdgeMinVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum vertical sum of layerThicknessEdge on '&
//'ocean edges.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'layerThicknessEdgeMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_relativeVorticityMinVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum vertical sum of relativeVorticity on '&
//'ocean vertices.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'relativeVorticityMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_enstrophyMinVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum vertical sum of enstrophy in ocean '&
//'cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-2}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'enstrophyMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_kineticEnergyCellMinVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum vertical sum of kineticEnergy in '&
//'ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm^3 s^{-2}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'kineticEnergyCellMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_normalizedAbsoluteVorticityMinVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum vertical sum of '&
//'normalizedAbsoluteVorticity on ocean vertices.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'normalizedAbsoluteVorticityMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_pressureMinVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum vertical sum of pressure in ocean '&
//'cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'N m^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'pressureMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_montgomeryPotentialMinVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum vertical sum of the Montgomery '&
//'Potential in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm^3 s^{-2}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'montgomeryPotentialMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_vertVelocityTopMinVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum vertical sum of vertVelocityTop in '&
//'ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm^2 s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'vertVelocityTopMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_vertAleTransportTopMinVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum vertical sum of vertAleTransportTop '&
//'in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm^2 s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'vertAleTransportTopMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_lowFreqDivergenceMinVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum vertical sum of lowFreqDivergence in '&
//'ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'lowFreqDivergenceMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_highFreqThicknessMinVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum vertical sum of highFreqThickness in '&
//'ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm^2')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'highFreqThicknessMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureMinVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum vertical sum of temperature in ocean '&
//'cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm ^\circ C')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'temperatureMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityMinVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum vertical sum of salinity in ocean '&
//'cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm PSU')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'salinityMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_layerThicknessPreviousTimestepMinVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum vertical sum of previous step '&
//'layerThickness in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'layerThicknessPreviousTimestepMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_frazilLayerThicknessTendencyMinVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum vertical sum of layer thickness '&
//'tendency due to frazil formation in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'frazilLayerThicknessTendencyMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_evaporationFluxMinVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum vertical sum of evaporationFlux in '&
//'ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'evaporationFluxMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_rainFluxMinVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum vertical sum of rainFlux in ocean '&
//'cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'rainFluxMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_snowFluxMinVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum vertical sum of snowFlux in ocean '&
//'cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'snowFluxMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_seaIceFreshWaterFluxMinVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum vertical sum of seaIceFreshWaterFlux '&
//'in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'seaIceFreshWaterFluxMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_riverRunoffFluxMinVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum vertical sum of riverRunoffFlux in '&
//'ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'riverRunoffFluxMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_iceRunoffFluxMinVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum vertical sum of iceRunoffFlux in '&
//'ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'iceRunoffFluxMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureFluxMinVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum vertical sum of temperatureFlux in '&
//'ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'temperatureFluxMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityFluxMinVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum vertical sum of salinityFlux in ocean '&
//'cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'salinityFluxMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityRestoringFluxMinVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum vertical sum of salinityRestoringFlux '&
//'in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'salinityRestoringFluxMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_landIceFreshwaterFluxMinVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum vertical sum of landIceFreshwaterFlux '&
//'in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'landIceFreshwaterFluxMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_accumulatedLandIceMassMinVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum vertical sum of '&
//'accumulatedLandIceMass in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'accumulatedLandIceMassMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_accumulatedLandIceHeatMinVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum vertical sum of '&
//'accumulatedLandIceHeat in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'J m^{-2}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'accumulatedLandIceHeatMinVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_accumulatedLandIceFrazilMassMinVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum vertical sum of '&
//'accumulatedLandIceFrazilMass in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'accumulatedLandIceFrazilMassMinVertSum'
      end if
      r1Ptr(1) % block => block

      if (globalStatsAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'vertSumMinGlobalStats', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'vertSumMinGlobalStats', r1Ptr)

! Define var array vertSumMaxGlobalStats
      allocate(r1Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group vertSumMax
! Define constituent var layerThicknessMaxVertSum
! My Packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_layerThicknessMaxVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMax_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_layerThicknessMaxVertSum', -1)
           end if
      end if
! Define constituent var normalVelocityMaxVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_normalVelocityMaxVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMax_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_normalVelocityMaxVertSum', -1)
         end if
      end if
! Define constituent var tangentialVelocityMaxVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_tangentialVelocityMaxVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMax_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_tangentialVelocityMaxVertSum', -1)
         end if
      end if
! Define constituent var layerThicknessEdgeMaxVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_layerThicknessEdgeMaxVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMax_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_layerThicknessEdgeMaxVertSum', -1)
         end if
      end if
! Define constituent var relativeVorticityMaxVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_relativeVorticityMaxVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMax_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_relativeVorticityMaxVertSum', -1)
         end if
      end if
! Define constituent var enstrophyMaxVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_enstrophyMaxVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMax_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_enstrophyMaxVertSum', -1)
         end if
      end if
! Define constituent var kineticEnergyCellMaxVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_kineticEnergyCellMaxVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMax_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_kineticEnergyCellMaxVertSum', -1)
         end if
      end if
! Define constituent var normalizedAbsoluteVorticityMaxVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_normalizedAbsoluteVorticityMaxVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMax_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_normalizedAbsoluteVorticityMaxVertSum', -1)
         end if
      end if
! Define constituent var pressureMaxVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_pressureMaxVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMax_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_pressureMaxVertSum', -1)
         end if
      end if
! Define constituent var montgomeryPotentialMaxVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_montgomeryPotentialMaxVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMax_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_montgomeryPotentialMaxVertSum', -1)
         end if
      end if
! Define constituent var vertVelocityTopMaxVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_vertVelocityTopMaxVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMax_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_vertVelocityTopMaxVertSum', -1)
         end if
      end if
! Define constituent var vertAleTransportTopMaxVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_vertAleTransportTopMaxVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMax_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_vertAleTransportTopMaxVertSum', -1)
         end if
      end if
! Define constituent var lowFreqDivergenceMaxVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_lowFreqDivergenceMaxVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMax_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_lowFreqDivergenceMaxVertSum', -1)
         end if
      end if
! Define constituent var highFreqThicknessMaxVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_highFreqThicknessMaxVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMax_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_highFreqThicknessMaxVertSum', -1)
         end if
      end if
! Define constituent var temperatureMaxVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureMaxVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMax_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureMaxVertSum', -1)
         end if
      end if
! Define constituent var salinityMaxVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityMaxVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMax_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityMaxVertSum', -1)
         end if
      end if
! Define constituent var layerThicknessPreviousTimestepMaxVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_layerThicknessPreviousTimestepMaxVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMax_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_layerThicknessPreviousTimestepMaxVertSum', -1)
         end if
      end if
! Define constituent var frazilLayerThicknessTendencyMaxVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_frazilLayerThicknessTendencyMaxVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMax_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_frazilLayerThicknessTendencyMaxVertSum', -1)
         end if
      end if
! Define constituent var evaporationFluxMaxVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_evaporationFluxMaxVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMax_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_evaporationFluxMaxVertSum', -1)
         end if
      end if
! Define constituent var rainFluxMaxVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_rainFluxMaxVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMax_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_rainFluxMaxVertSum', -1)
         end if
      end if
! Define constituent var snowFluxMaxVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_snowFluxMaxVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMax_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_snowFluxMaxVertSum', -1)
         end if
      end if
! Define constituent var seaIceFreshWaterFluxMaxVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_seaIceFreshWaterFluxMaxVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMax_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_seaIceFreshWaterFluxMaxVertSum', -1)
         end if
      end if
! Define constituent var riverRunoffFluxMaxVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_riverRunoffFluxMaxVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMax_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_riverRunoffFluxMaxVertSum', -1)
         end if
      end if
! Define constituent var iceRunoffFluxMaxVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_iceRunoffFluxMaxVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMax_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_iceRunoffFluxMaxVertSum', -1)
         end if
      end if
! Define constituent var temperatureFluxMaxVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureFluxMaxVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMax_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureFluxMaxVertSum', -1)
         end if
      end if
! Define constituent var salinityFluxMaxVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityFluxMaxVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMax_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityFluxMaxVertSum', -1)
         end if
      end if
! Define constituent var salinityRestoringFluxMaxVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityRestoringFluxMaxVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMax_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityRestoringFluxMaxVertSum', -1)
         end if
      end if
! Define constituent var landIceFreshwaterFluxMaxVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_landIceFreshwaterFluxMaxVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMax_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_landIceFreshwaterFluxMaxVertSum', -1)
         end if
      end if
! Define constituent var accumulatedLandIceMassMaxVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_accumulatedLandIceMassMaxVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMax_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_accumulatedLandIceMassMaxVertSum', -1)
         end if
      end if
! Define constituent var accumulatedLandIceHeatMaxVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_accumulatedLandIceHeatMaxVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMax_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_accumulatedLandIceHeatMaxVertSum', -1)
         end if
      end if
! Define constituent var accumulatedLandIceFrazilMassMaxVertSum
! My packages are globalStatsAMPKG
      if (globalStatsAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_accumulatedLandIceFrazilMassMaxVertSum', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMax_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_accumulatedLandIceFrazilMassMaxVertSum', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMax_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'vertSumMax_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'vertSumMax_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_vertSumMaxGlobalStats', numConstituents)
      end if
! Defining time level 1
      allocate( r1Ptr(1) % constituentNames(numConstituents) )
      r1Ptr(1) % fieldName = 'vertSumMaxGlobalStats'
      r1Ptr(1) % isDecomposed = .false.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isVarArray = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_layerThicknessMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'layerThicknessMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_normalVelocityMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'normalVelocityMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_tangentialVelocityMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'tangentialVelocityMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_layerThicknessEdgeMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'layerThicknessEdgeMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_relativeVorticityMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'relativeVorticityMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_enstrophyMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'enstrophyMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_kineticEnergyCellMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'kineticEnergyCellMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_normalizedAbsoluteVorticityMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'normalizedAbsoluteVorticityMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_pressureMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'pressureMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_montgomeryPotentialMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'montgomeryPotentialMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_vertVelocityTopMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'vertVelocityTopMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_vertAleTransportTopMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'vertAleTransportTopMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_lowFreqDivergenceMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'lowFreqDivergenceMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_highFreqThicknessMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'highFreqThicknessMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'temperatureMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'salinityMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_layerThicknessPreviousTimestepMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'layerThicknessPreviousTimestepMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_frazilLayerThicknessTendencyMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'frazilLayerThicknessTendencyMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_evaporationFluxMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'evaporationFluxMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_rainFluxMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'rainFluxMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_snowFluxMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'snowFluxMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_seaIceFreshWaterFluxMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'seaIceFreshWaterFluxMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_riverRunoffFluxMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'riverRunoffFluxMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_iceRunoffFluxMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'iceRunoffFluxMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureFluxMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'temperatureFluxMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityFluxMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'salinityFluxMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityRestoringFluxMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'salinityRestoringFluxMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_landIceFreshwaterFluxMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'landIceFreshwaterFluxMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_accumulatedLandIceMassMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'accumulatedLandIceMassMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_accumulatedLandIceHeatMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'accumulatedLandIceHeatMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_accumulatedLandIceFrazilMassMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         r1Ptr(1) % constituentNames(const_index) = 'accumulatedLandIceFrazilMassMaxVertSum'
      end if

! Setup dimensions for       
      r1Ptr(1) % dimNames(1) = 'num_vertSumMaxGlobalStats'

      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(size(r1Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r1Ptr(1) % constituentNames, dim=1)
         allocate(r1Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_layerThicknessMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum vertical sum of layerThickness in '&
//'ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'layerThicknessMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_normalVelocityMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum vertical sum of normalVelocity on '&
//'ocean edges.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm^2 s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'normalVelocityMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_tangentialVelocityMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum vertical sum of tangentialVelocity on '&
//'ocean edges.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm^2 s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'tangentialVelocityMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_layerThicknessEdgeMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum vertical sum of layerThicknessEdge on '&
//'ocean edges.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'layerThicknessEdgeMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_relativeVorticityMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum vertical sum of relativeVorticity on '&
//'ocean vertices.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'relativeVorticityMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_enstrophyMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum vertical sum of enstrophy in ocean '&
//'cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 's^{-2}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'enstrophyMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_kineticEnergyCellMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum vertical sum of kineticEnergy in '&
//'ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm^3 s^{-2}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'kineticEnergyCellMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_normalizedAbsoluteVorticityMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum vertical sum of '&
//'normalizedAbsoluteVorticity on ocean vertices.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'normalizedAbsoluteVorticityMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_pressureMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum vertical sum of pressure in ocean '&
//'cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'N m^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'pressureMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_montgomeryPotentialMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum vertical sum of the Montgomery '&
//'Potential in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm^3 s^{-2}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'montgomeryPotentialMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_vertVelocityTopMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum vertical sum of vertVelocityTop in '&
//'ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm^2 s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'vertVelocityTopMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_vertAleTransportTopMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum vertical sum of vertAleTransportTop '&
//'in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm^2 s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'vertAleTransportTopMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_lowFreqDivergenceMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum vertical sum of lowFreqDivergence in '&
//'ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'lowFreqDivergenceMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_highFreqThicknessMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum vertical sum of highFreqThickness in '&
//'ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm^2')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'highFreqThicknessMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum vertical sum of temperature in ocean '&
//'cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm ^\circ C')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'temperatureMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum vertical sum of salinity in ocean '&
//'cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm PSU')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'salinityMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_layerThicknessPreviousTimestepMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum vertical sum of previous step '&
//'layerThickness in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'layerThicknessPreviousTimestepMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_frazilLayerThicknessTendencyMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum vertical sum of layer thickness '&
//'tendency due to frazil formation in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'frazilLayerThicknessTendencyMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_evaporationFluxMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum vertical sum of evaporationFlux in '&
//'ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'evaporationFluxMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_rainFluxMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum vertical sum of rainFlux in ocean '&
//'cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'rainFluxMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_snowFluxMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum vertical sum of snowFlux in ocean '&
//'cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'snowFluxMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_seaIceFreshWaterFluxMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum vertical sum of seaIceFreshWaterFlux '&
//'in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'seaIceFreshWaterFluxMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_riverRunoffFluxMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum vertical sum of riverRunoffFlux in '&
//'ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'riverRunoffFluxMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_iceRunoffFluxMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum vertical sum of iceRunoffFlux in '&
//'ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'iceRunoffFluxMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureFluxMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum vertical sum of temperatureFlux in '&
//'ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'temperatureFluxMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityFluxMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum vertical sum of salinityFlux in ocean '&
//'cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'salinityFluxMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityRestoringFluxMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum vertical sum of salinityRestoringFlux '&
//'in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'salinityRestoringFluxMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_landIceFreshwaterFluxMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum vertical sum of landIceFreshwaterFlux '&
//'in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}m')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'landIceFreshwaterFluxMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_accumulatedLandIceMassMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum vertical sum of '&
//'accumulatedLandIceMass in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'accumulatedLandIceMassMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_accumulatedLandIceHeatMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum vertical sum of '&
//'accumulatedLandIceHeat in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'J m^{-2}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'accumulatedLandIceHeatMaxVertSum'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_accumulatedLandIceFrazilMassMaxVertSum', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum vertical sum of '&
//'accumulatedLandIceFrazilMass in ocean cells.')
         call mpas_add_att(r1Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2}')
         r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r1Ptr(1) % constituentNames(const_index) = 'accumulatedLandIceFrazilMassMaxVertSum'
      end if
      r1Ptr(1) % block => block

      if (globalStatsAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'vertSumMaxGlobalStats', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'vertSumMaxGlobalStats', r1Ptr)

! Define variable areaCellGlobal
      allocate(r0Ptr(1))

! Setting up time level 1
      r0Ptr(1) % fieldName = 'areaCellGlobal'
      r0Ptr(1) % isVarArray = .false.
      r0Ptr(1) % isDecomposed = .false.
      r0Ptr(1) % hasTimeDimension = .true.
      r0Ptr(1) % defaultValue = 0.0
      r0Ptr(1) % scalar = 0.0
      allocate(r0Ptr(1) % attLists(1))
      allocate(r0Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r0Ptr(1) % attLists(1) % attList, 'units', 'm^2')
      call mpas_add_att(r0Ptr(1) % attLists(1) % attList, 'long_name', 'sum of the areaCell variable over the full domain, used to '&
//'normalize global statistics')
      r0Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r0Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r0Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'areaCellGlobal', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'areaCellGlobal', r0Ptr)

! Define variable areaEdgeGlobal
      allocate(r0Ptr(1))

! Setting up time level 1
      r0Ptr(1) % fieldName = 'areaEdgeGlobal'
      r0Ptr(1) % isVarArray = .false.
      r0Ptr(1) % isDecomposed = .false.
      r0Ptr(1) % hasTimeDimension = .true.
      r0Ptr(1) % defaultValue = 0.0
      r0Ptr(1) % scalar = 0.0
      allocate(r0Ptr(1) % attLists(1))
      allocate(r0Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r0Ptr(1) % attLists(1) % attList, 'units', 'm^2')
      call mpas_add_att(r0Ptr(1) % attLists(1) % attList, 'long_name', 'sum of the areaEdge variable over the full domain, used to '&
//'normalize global statistics')
      r0Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r0Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r0Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'areaEdgeGlobal', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'areaEdgeGlobal', r0Ptr)

! Define variable areaTriangleGlobal
      allocate(r0Ptr(1))

! Setting up time level 1
      r0Ptr(1) % fieldName = 'areaTriangleGlobal'
      r0Ptr(1) % isVarArray = .false.
      r0Ptr(1) % isDecomposed = .false.
      r0Ptr(1) % hasTimeDimension = .true.
      r0Ptr(1) % defaultValue = 0.0
      r0Ptr(1) % scalar = 0.0
      allocate(r0Ptr(1) % attLists(1))
      allocate(r0Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r0Ptr(1) % attLists(1) % attList, 'units', 'm^2')
      call mpas_add_att(r0Ptr(1) % attLists(1) % attList, 'long_name', 'sum of the areaTriangle variable over the full domain, '&
//'used to normalize global statistics')
      r0Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r0Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r0Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'areaTriangleGlobal', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'areaTriangleGlobal', r0Ptr)

! Define variable volumeCellGlobal
      allocate(r0Ptr(1))

! Setting up time level 1
      r0Ptr(1) % fieldName = 'volumeCellGlobal'
      r0Ptr(1) % isVarArray = .false.
      r0Ptr(1) % isDecomposed = .false.
      r0Ptr(1) % hasTimeDimension = .true.
      r0Ptr(1) % defaultValue = 0.0
      r0Ptr(1) % scalar = 0.0
      allocate(r0Ptr(1) % attLists(1))
      allocate(r0Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r0Ptr(1) % attLists(1) % attList, 'units', 'm^3')
      call mpas_add_att(r0Ptr(1) % attLists(1) % attList, 'long_name', 'sum of the volumeCell variable over the full domain, used '&
//'to normalize global statistics')
      r0Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r0Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r0Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'volumeCellGlobal', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'volumeCellGlobal', r0Ptr)

! Define variable volumeEdgeGlobal
      allocate(r0Ptr(1))

! Setting up time level 1
      r0Ptr(1) % fieldName = 'volumeEdgeGlobal'
      r0Ptr(1) % isVarArray = .false.
      r0Ptr(1) % isDecomposed = .false.
      r0Ptr(1) % hasTimeDimension = .true.
      r0Ptr(1) % defaultValue = 0.0
      r0Ptr(1) % scalar = 0.0
      allocate(r0Ptr(1) % attLists(1))
      allocate(r0Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r0Ptr(1) % attLists(1) % attList, 'units', 'm^3')
      call mpas_add_att(r0Ptr(1) % attLists(1) % attList, 'long_name', 'sum of the volumeEdge variable over the full domain, used '&
//'to normalize global statistics')
      r0Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r0Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r0Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'volumeEdgeGlobal', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'volumeEdgeGlobal', r0Ptr)

! Define variable CFLNumberGlobal
      allocate(r0Ptr(1))

! Setting up time level 1
      r0Ptr(1) % fieldName = 'CFLNumberGlobal'
      r0Ptr(1) % isVarArray = .false.
      r0Ptr(1) % isDecomposed = .false.
      r0Ptr(1) % hasTimeDimension = .true.
      r0Ptr(1) % defaultValue = 0.0
      r0Ptr(1) % scalar = 0.0
      allocate(r0Ptr(1) % attLists(1))
      allocate(r0Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r0Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r0Ptr(1) % attLists(1) % attList, 'long_name', 'maximum CFL number over the full domain')
      r0Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r0Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r0Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'CFLNumberGlobal', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'CFLNumberGlobal', r0Ptr)

! Define variable landIceFloatingAreaSum
      allocate(r0Ptr(1))

! Setting up time level 1
      r0Ptr(1) % fieldName = 'landIceFloatingAreaSum'
      r0Ptr(1) % isVarArray = .false.
      r0Ptr(1) % isDecomposed = .false.
      r0Ptr(1) % hasTimeDimension = .true.
      r0Ptr(1) % defaultValue = 0.0
      r0Ptr(1) % scalar = 0.0
      allocate(r0Ptr(1) % attLists(1))
      allocate(r0Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r0Ptr(1) % attLists(1) % attList, 'units', 'm^2')
      call mpas_add_att(r0Ptr(1) % attLists(1) % attList, 'long_name', 'sum of areaCell where landIceMask == 1, used to normalize '&
//'global statistics in land-ice cavities')
      r0Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r0Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r0Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'landIceFloatingAreaSum', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'landIceFloatingAreaSum', r0Ptr)

! Define variable totalVolumeChange
      allocate(r0Ptr(1))

! Setting up time level 1
      r0Ptr(1) % fieldName = 'totalVolumeChange'
      r0Ptr(1) % isVarArray = .false.
      r0Ptr(1) % isDecomposed = .false.
      r0Ptr(1) % hasTimeDimension = .true.
      r0Ptr(1) % defaultValue = 0.0
      r0Ptr(1) % scalar = 0.0
      allocate(r0Ptr(1) % attLists(1))
      allocate(r0Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r0Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r0Ptr(1) % attLists(1) % attList, 'long_name', 'Total volume change of the ocean relative to previous '&
//'timestep')
      r0Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r0Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r0Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'totalVolumeChange', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'totalVolumeChange', r0Ptr)

! Define variable netFreshwaterInput
      allocate(r0Ptr(1))

! Setting up time level 1
      r0Ptr(1) % fieldName = 'netFreshwaterInput'
      r0Ptr(1) % isVarArray = .false.
      r0Ptr(1) % isDecomposed = .false.
      r0Ptr(1) % hasTimeDimension = .true.
      r0Ptr(1) % defaultValue = 0.0
      r0Ptr(1) % scalar = 0.0
      allocate(r0Ptr(1) % attLists(1))
      allocate(r0Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r0Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r0Ptr(1) % attLists(1) % attList, 'long_name', 'Net fresh water change (input-output) over the timestep '&
//'due to surface fluxes and frazil formation')
      r0Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r0Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r0Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'netFreshwaterInput', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'netFreshwaterInput', r0Ptr)

! Define variable absoluteFreshWaterConservation
      allocate(r0Ptr(1))

! Setting up time level 1
      r0Ptr(1) % fieldName = 'absoluteFreshWaterConservation'
      r0Ptr(1) % isVarArray = .false.
      r0Ptr(1) % isDecomposed = .false.
      r0Ptr(1) % hasTimeDimension = .true.
      r0Ptr(1) % defaultValue = 0.0
      r0Ptr(1) % scalar = 0.0
      allocate(r0Ptr(1) % attLists(1))
      allocate(r0Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r0Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r0Ptr(1) % attLists(1) % attList, 'long_name', 'Difference between change in ocean volume and freshwater '&
//'input')
      r0Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r0Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r0Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'absoluteFreshWaterConservation', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'absoluteFreshWaterConservation', r0Ptr)

! Define variable relativeFreshWaterConservation
      allocate(r0Ptr(1))

! Setting up time level 1
      r0Ptr(1) % fieldName = 'relativeFreshWaterConservation'
      r0Ptr(1) % isVarArray = .false.
      r0Ptr(1) % isDecomposed = .false.
      r0Ptr(1) % hasTimeDimension = .true.
      r0Ptr(1) % defaultValue = 0.0
      r0Ptr(1) % scalar = 0.0
      allocate(r0Ptr(1) % attLists(1))
      allocate(r0Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r0Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r0Ptr(1) % attLists(1) % attList, 'long_name', 'Difference between change in ocean volume and freshwater '&
//'input divided by volume change')
      r0Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r0Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r0Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'relativeFreshWaterConservation', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'relativeFreshWaterConservation', r0Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_pool_globalStatsAM


   subroutine ocn_generate_pool_surfaceAreaWeightedAveragesAM(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'surfaceAreaWeightedAveragesAM', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'surfaceAreaWeightedAveragesAM', newSubPool)

! Define var array minValueWithinOceanRegion
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group mins
! Define constituent var minSurfaceMaskValue
! My Packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minSurfaceMaskValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_minSurfaceMaskValue', -1)
           end if
      end if
! Define constituent var minSurfaceArea
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minSurfaceArea', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minSurfaceArea', -1)
         end if
      end if
! Define constituent var minLatentHeatFlux
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLatentHeatFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLatentHeatFlux', -1)
         end if
      end if
! Define constituent var minSensibleHeatFlux
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minSensibleHeatFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minSensibleHeatFlux', -1)
         end if
      end if
! Define constituent var minLongWaveHeatFluxUp
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLongWaveHeatFluxUp', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLongWaveHeatFluxUp', -1)
         end if
      end if
! Define constituent var minLongWaveHeatFluxDown
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLongWaveHeatFluxDown', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLongWaveHeatFluxDown', -1)
         end if
      end if
! Define constituent var minSeaIceHeatFlux
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minSeaIceHeatFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minSeaIceHeatFlux', -1)
         end if
      end if
! Define constituent var minShortWaveHeatFlux
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minShortWaveHeatFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minShortWaveHeatFlux', -1)
         end if
      end if
! Define constituent var minEvaporationFlux
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minEvaporationFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minEvaporationFlux', -1)
         end if
      end if
! Define constituent var minSeaIceFreshWaterFlux
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minSeaIceFreshWaterFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minSeaIceFreshWaterFlux', -1)
         end if
      end if
! Define constituent var minRiverRunoffFlux
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minRiverRunoffFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minRiverRunoffFlux', -1)
         end if
      end if
! Define constituent var minIceRunoffFlux
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minIceRunoffFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minIceRunoffFlux', -1)
         end if
      end if
! Define constituent var minRainFlux
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minRainFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minRainFlux', -1)
         end if
      end if
! Define constituent var minSnowFlux
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minSnowFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minSnowFlux', -1)
         end if
      end if
! Define constituent var minSeaIceEnergy
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minSeaIceEnergy', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minSeaIceEnergy', -1)
         end if
      end if
! Define constituent var minSurfaceThicknessFlux
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minSurfaceThicknessFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minSurfaceThicknessFlux', -1)
         end if
      end if
! Define constituent var minSurfaceTemperatureFlux
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minSurfaceTemperatureFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minSurfaceTemperatureFlux', -1)
         end if
      end if
! Define constituent var minSurfaceSalinityFlux
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minSurfaceSalinityFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minSurfaceSalinityFlux', -1)
         end if
      end if
! Define constituent var minSeaIceSalinityFlux
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minSeaIceSalinityFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minSeaIceSalinityFlux', -1)
         end if
      end if
! Define constituent var minSurfaceWindStressMagnitude
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minSurfaceWindStressMagnitude', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minSurfaceWindStressMagnitude', -1)
         end if
      end if
! Define constituent var minWindStressZonal
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minWindStressZonal', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minWindStressZonal', -1)
         end if
      end if
! Define constituent var minWindStressMeridional
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minWindStressMeridional', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minWindStressMeridional', -1)
         end if
      end if
! Define constituent var minSeaSurfacePressure
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minSeaSurfacePressure', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minSeaSurfacePressure', -1)
         end if
      end if
! Define constituent var minSurfaceSSH
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minSurfaceSSH', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minSurfaceSSH', -1)
         end if
      end if
! Define constituent var minSurfaceTemperature
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minSurfaceTemperature', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minSurfaceTemperature', -1)
         end if
      end if
! Define constituent var minSurfaceSalinity
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minSurfaceSalinity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minSurfaceSalinity', -1)
         end if
      end if
! Define constituent var minBoundaryLayerDepth
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minBoundaryLayerDepth', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minBoundaryLayerDepth', -1)
         end if
      end if
! Define constituent var minSurfaceNetHeatFlux
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minSurfaceNetHeatFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minSurfaceNetHeatFlux', -1)
         end if
      end if
! Define constituent var minSurfaceNetSalinitFlux
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minSurfaceNetSalinitFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minSurfaceNetSalinitFlux', -1)
         end if
      end if
! Define constituent var minSurfaceNetFreshWaterFlux
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minSurfaceNetFreshWaterFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minSurfaceNetFreshWaterFlux', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'mins_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'mins_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_minValueWithinOceanRegion', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'minValueWithinOceanRegion'
      r2Ptr(1) % isDecomposed = .false.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minSurfaceMaskValue', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minSurfaceMaskValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minSurfaceArea', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minSurfaceArea'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLatentHeatFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minLatentHeatFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minSensibleHeatFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minSensibleHeatFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLongWaveHeatFluxUp', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minLongWaveHeatFluxUp'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLongWaveHeatFluxDown', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minLongWaveHeatFluxDown'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minSeaIceHeatFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minSeaIceHeatFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minShortWaveHeatFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minShortWaveHeatFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minEvaporationFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minEvaporationFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minSeaIceFreshWaterFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minSeaIceFreshWaterFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minRiverRunoffFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minRiverRunoffFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minIceRunoffFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minIceRunoffFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minRainFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minRainFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minSnowFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minSnowFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minSeaIceEnergy', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minSeaIceEnergy'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minSurfaceThicknessFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minSurfaceThicknessFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minSurfaceTemperatureFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minSurfaceTemperatureFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minSurfaceSalinityFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minSurfaceSalinityFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minSeaIceSalinityFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minSeaIceSalinityFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minSurfaceWindStressMagnitude', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minSurfaceWindStressMagnitude'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minWindStressZonal', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minWindStressZonal'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minWindStressMeridional', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minWindStressMeridional'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minSeaSurfacePressure', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minSeaSurfacePressure'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minSurfaceSSH', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minSurfaceSSH'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minSurfaceTemperature', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minSurfaceTemperature'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minSurfaceSalinity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minSurfaceSalinity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minBoundaryLayerDepth', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minBoundaryLayerDepth'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minSurfaceNetHeatFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minSurfaceNetHeatFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minSurfaceNetSalinitFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minSurfaceNetSalinitFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minSurfaceNetFreshWaterFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minSurfaceNetFreshWaterFlux'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_minValueWithinOceanRegion'
      r2Ptr(1) % dimNames(2) = 'nOceanRegions'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minSurfaceMaskValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum value of region mask (should always '&
//'be 1 for valid regions)')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'none')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minSurfaceMaskValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minSurfaceArea', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum area of a surface cell in each '&
//'region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm^2')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minSurfaceArea'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLatentHeatFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum latent heat flux in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'W m^{-2}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minLatentHeatFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minSensibleHeatFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum sensible heat flux in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'W m^{-2}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minSensibleHeatFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLongWaveHeatFluxUp', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum upwelling long wave heat flux in each '&
//'region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'W m^{-2}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minLongWaveHeatFluxUp'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLongWaveHeatFluxDown', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum downwelling long wave heat flux in '&
//'each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'W m^{-2}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minLongWaveHeatFluxDown'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minSeaIceHeatFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum sea ice heat flux in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'W m^{-2}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minSeaIceHeatFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minShortWaveHeatFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum short wave heat flux in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'W m^{-2}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minShortWaveHeatFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minEvaporationFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum evaporation in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minEvaporationFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minSeaIceFreshWaterFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum sea ice melt rate in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minSeaIceFreshWaterFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minRiverRunoffFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum river run off in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minRiverRunoffFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minIceRunoffFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum ice run off in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minIceRunoffFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minRainFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum rain flux in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minRainFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minSnowFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum snow flux in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minSnowFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minSeaIceEnergy', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum sea ice energy in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'J m^{-2}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minSeaIceEnergy'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minSurfaceThicknessFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum surface thickness flux in each '&
//'region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minSurfaceThicknessFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minSurfaceTemperatureFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum surface temperature flux in each '&
//'region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'C m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minSurfaceTemperatureFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minSurfaceSalinityFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum surface salinity flux in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'PSU m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minSurfaceSalinityFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minSeaIceSalinityFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum sea ice salinity flux in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'kg m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minSeaIceSalinityFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minSurfaceWindStressMagnitude', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum wind stress magnitude in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'N m^{-2}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minSurfaceWindStressMagnitude'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minWindStressZonal', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum zonal wind stress in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'N m^{-2}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minWindStressZonal'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minWindStressMeridional', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum meridional wind stress in each '&
//'region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'N m^{-2}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minWindStressMeridional'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minSeaSurfacePressure', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum sea surface pressure in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'Pa')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minSeaSurfacePressure'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minSurfaceSSH', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum sea-surface height in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minSurfaceSSH'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minSurfaceTemperature', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum surface temperature in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'C')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minSurfaceTemperature'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minSurfaceSalinity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum surface salinity in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'PSU')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minSurfaceSalinity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minBoundaryLayerDepth', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum surface boundary layer depth in each '&
//'region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minBoundaryLayerDepth'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minSurfaceNetHeatFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum net surface heat flux in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'W m^{-2}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minSurfaceNetHeatFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minSurfaceNetSalinitFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum net surface salinity flux in each '&
//'region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'kg m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minSurfaceNetSalinitFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minSurfaceNetFreshWaterFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum net surface fresh water flux in each '&
//'region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minSurfaceNetFreshWaterFlux'
      end if
      r2Ptr(1) % block => block

      if (surfaceAreaWeightedAveragesAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'minValueWithinOceanRegion', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'minValueWithinOceanRegion', r2Ptr)

! Define var array maxValueWithinOceanRegion
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group maxs
! Define constituent var maxSurfaceMaskValue
! My Packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxSurfaceMaskValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_maxSurfaceMaskValue', -1)
           end if
      end if
! Define constituent var maxSurfaceArea
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxSurfaceArea', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxSurfaceArea', -1)
         end if
      end if
! Define constituent var maxLatentHeatFlux
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLatentHeatFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLatentHeatFlux', -1)
         end if
      end if
! Define constituent var maxSensibleHeatFlux
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxSensibleHeatFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxSensibleHeatFlux', -1)
         end if
      end if
! Define constituent var maxLongWaveHeatFluxUp
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLongWaveHeatFluxUp', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLongWaveHeatFluxUp', -1)
         end if
      end if
! Define constituent var maxLongWaveHeatFluxDown
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLongWaveHeatFluxDown', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLongWaveHeatFluxDown', -1)
         end if
      end if
! Define constituent var maxSeaIceHeatFlux
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxSeaIceHeatFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxSeaIceHeatFlux', -1)
         end if
      end if
! Define constituent var maxShortWaveHeatFlux
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxShortWaveHeatFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxShortWaveHeatFlux', -1)
         end if
      end if
! Define constituent var maxEvaporationFlux
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxEvaporationFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxEvaporationFlux', -1)
         end if
      end if
! Define constituent var maxSeaIceFreshWaterFlux
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxSeaIceFreshWaterFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxSeaIceFreshWaterFlux', -1)
         end if
      end if
! Define constituent var maxRiverRunoffFlux
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxRiverRunoffFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxRiverRunoffFlux', -1)
         end if
      end if
! Define constituent var maxIceRunoffFlux
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxIceRunoffFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxIceRunoffFlux', -1)
         end if
      end if
! Define constituent var maxRainFlux
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxRainFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxRainFlux', -1)
         end if
      end if
! Define constituent var maxSnowFlux
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxSnowFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxSnowFlux', -1)
         end if
      end if
! Define constituent var maxSeaIceEnergy
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxSeaIceEnergy', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxSeaIceEnergy', -1)
         end if
      end if
! Define constituent var maxSurfaceThicknessFlux
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxSurfaceThicknessFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxSurfaceThicknessFlux', -1)
         end if
      end if
! Define constituent var maxSurfaceTemperatureFlux
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxSurfaceTemperatureFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxSurfaceTemperatureFlux', -1)
         end if
      end if
! Define constituent var maxSurfaceSalinityFlux
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxSurfaceSalinityFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxSurfaceSalinityFlux', -1)
         end if
      end if
! Define constituent var maxSeaIceSalinityFlux
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxSeaIceSalinityFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxSeaIceSalinityFlux', -1)
         end if
      end if
! Define constituent var maxSurfaceWindStressMagnitude
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxSurfaceWindStressMagnitude', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxSurfaceWindStressMagnitude', -1)
         end if
      end if
! Define constituent var maxWindStressZonal
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxWindStressZonal', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxWindStressZonal', -1)
         end if
      end if
! Define constituent var maxWindStressMeridional
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxWindStressMeridional', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxWindStressMeridional', -1)
         end if
      end if
! Define constituent var maxSeaSurfacePressure
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxSeaSurfacePressure', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxSeaSurfacePressure', -1)
         end if
      end if
! Define constituent var maxSurfaceSSH
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxSurfaceSSH', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxSurfaceSSH', -1)
         end if
      end if
! Define constituent var maxSurfaceTemperature
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxSurfaceTemperature', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxSurfaceTemperature', -1)
         end if
      end if
! Define constituent var maxSurfaceSalinity
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxSurfaceSalinity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxSurfaceSalinity', -1)
         end if
      end if
! Define constituent var maxBoundaryLayerDepth
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxBoundaryLayerDepth', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxBoundaryLayerDepth', -1)
         end if
      end if
! Define constituent var maxSurfaceNetHeatFlux
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxSurfaceNetHeatFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxSurfaceNetHeatFlux', -1)
         end if
      end if
! Define constituent var maxSurfaceNetSalinitFlux
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxSurfaceNetSalinitFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxSurfaceNetSalinitFlux', -1)
         end if
      end if
! Define constituent var maxSurfaceNetFreshWaterFlux
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxSurfaceNetFreshWaterFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxSurfaceNetFreshWaterFlux', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxs_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'maxs_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'maxs_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_maxValueWithinOceanRegion', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'maxValueWithinOceanRegion'
      r2Ptr(1) % isDecomposed = .false.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxSurfaceMaskValue', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxSurfaceMaskValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxSurfaceArea', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxSurfaceArea'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLatentHeatFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxLatentHeatFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxSensibleHeatFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxSensibleHeatFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLongWaveHeatFluxUp', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxLongWaveHeatFluxUp'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLongWaveHeatFluxDown', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxLongWaveHeatFluxDown'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxSeaIceHeatFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxSeaIceHeatFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxShortWaveHeatFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxShortWaveHeatFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxEvaporationFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxEvaporationFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxSeaIceFreshWaterFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxSeaIceFreshWaterFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxRiverRunoffFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxRiverRunoffFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxIceRunoffFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxIceRunoffFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxRainFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxRainFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxSnowFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxSnowFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxSeaIceEnergy', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxSeaIceEnergy'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxSurfaceThicknessFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxSurfaceThicknessFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxSurfaceTemperatureFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxSurfaceTemperatureFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxSurfaceSalinityFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxSurfaceSalinityFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxSeaIceSalinityFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxSeaIceSalinityFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxSurfaceWindStressMagnitude', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxSurfaceWindStressMagnitude'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxWindStressZonal', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxWindStressZonal'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxWindStressMeridional', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxWindStressMeridional'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxSeaSurfacePressure', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxSeaSurfacePressure'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxSurfaceSSH', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxSurfaceSSH'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxSurfaceTemperature', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxSurfaceTemperature'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxSurfaceSalinity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxSurfaceSalinity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxBoundaryLayerDepth', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxBoundaryLayerDepth'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxSurfaceNetHeatFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxSurfaceNetHeatFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxSurfaceNetSalinitFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxSurfaceNetSalinitFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxSurfaceNetFreshWaterFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxSurfaceNetFreshWaterFlux'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_maxValueWithinOceanRegion'
      r2Ptr(1) % dimNames(2) = 'nOceanRegions'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxSurfaceMaskValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum value of region mask (should always '&
//'be 1 for valid regions)')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'none')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxSurfaceMaskValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxSurfaceArea', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum area of a surface cell in each '&
//'region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm^2')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxSurfaceArea'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLatentHeatFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum latent heat flux in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'W m^{-2}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxLatentHeatFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxSensibleHeatFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum sensible heat flux in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'W m^{-2}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxSensibleHeatFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLongWaveHeatFluxUp', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum upwelling long wave heat flux in each '&
//'region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'W m^{-2}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxLongWaveHeatFluxUp'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLongWaveHeatFluxDown', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum downwelling long wave heat flux in '&
//'each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'W m^{-2}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxLongWaveHeatFluxDown'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxSeaIceHeatFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum sea ice heat flux in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'W m^{-2}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxSeaIceHeatFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxShortWaveHeatFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum short wave heat flux in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'W m^{-2}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxShortWaveHeatFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxEvaporationFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum evaporation in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxEvaporationFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxSeaIceFreshWaterFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum sea ice melt rate in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxSeaIceFreshWaterFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxRiverRunoffFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum river run off in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxRiverRunoffFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxIceRunoffFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum ice run off in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxIceRunoffFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxRainFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum rain flux in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxRainFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxSnowFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum snow flux in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxSnowFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxSeaIceEnergy', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum sea ice energy in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'J m^{-2}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxSeaIceEnergy'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxSurfaceThicknessFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum surface thickness flux in each '&
//'region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxSurfaceThicknessFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxSurfaceTemperatureFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum surface temperature flux in each '&
//'region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'C m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxSurfaceTemperatureFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxSurfaceSalinityFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum surface salinity flux in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'PSU m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxSurfaceSalinityFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxSeaIceSalinityFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum sea ice salinity flux in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'kg m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxSeaIceSalinityFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxSurfaceWindStressMagnitude', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum wind stress magnitude in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'N m^{-2}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxSurfaceWindStressMagnitude'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxWindStressZonal', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum zonal wind stress in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'N m^{-2}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxWindStressZonal'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxWindStressMeridional', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum meridional wind stress in each '&
//'region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'N m^{-2}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxWindStressMeridional'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxSeaSurfacePressure', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum sea surface pressure in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'Pa')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxSeaSurfacePressure'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxSurfaceSSH', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum sea-surface height')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxSurfaceSSH'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxSurfaceTemperature', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum surface temperature in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'C')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxSurfaceTemperature'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxSurfaceSalinity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum surface salinity in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'PSU')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxSurfaceSalinity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxBoundaryLayerDepth', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum surface boundary layer depth in each '&
//'region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxBoundaryLayerDepth'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxSurfaceNetHeatFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum net surface heat flux in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'W m^{-2}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxSurfaceNetHeatFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxSurfaceNetSalinitFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum net surface salinity flux in each '&
//'region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'kg m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxSurfaceNetSalinitFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxSurfaceNetFreshWaterFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum net surface fresh water flux in each '&
//'region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxSurfaceNetFreshWaterFlux'
      end if
      r2Ptr(1) % block => block

      if (surfaceAreaWeightedAveragesAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'maxValueWithinOceanRegion', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'maxValueWithinOceanRegion', r2Ptr)

! Define var array avgValueWithinOceanRegion
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group avg
! Define constituent var sumSurfaceMaskValue
! My Packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_sumSurfaceMaskValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_sumSurfaceMaskValue', -1)
           end if
      end if
! Define constituent var avgSurfaceArea
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgSurfaceArea', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgSurfaceArea', -1)
         end if
      end if
! Define constituent var avgLatentHeatFlux
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLatentHeatFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLatentHeatFlux', -1)
         end if
      end if
! Define constituent var avgSensibleHeatFlux
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgSensibleHeatFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgSensibleHeatFlux', -1)
         end if
      end if
! Define constituent var avgLongWaveHeatFluxUp
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLongWaveHeatFluxUp', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLongWaveHeatFluxUp', -1)
         end if
      end if
! Define constituent var avgLongWaveHeatFluxDown
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLongWaveHeatFluxDown', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLongWaveHeatFluxDown', -1)
         end if
      end if
! Define constituent var avgSeaIceHeatFlux
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgSeaIceHeatFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgSeaIceHeatFlux', -1)
         end if
      end if
! Define constituent var avgShortWaveHeatFlux
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgShortWaveHeatFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgShortWaveHeatFlux', -1)
         end if
      end if
! Define constituent var avgEvaporationFlux
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgEvaporationFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgEvaporationFlux', -1)
         end if
      end if
! Define constituent var avgSeaIceFreshWaterFlux
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgSeaIceFreshWaterFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgSeaIceFreshWaterFlux', -1)
         end if
      end if
! Define constituent var avgRiverRunoffFlux
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgRiverRunoffFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgRiverRunoffFlux', -1)
         end if
      end if
! Define constituent var avgIceRunoffFlux
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgIceRunoffFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgIceRunoffFlux', -1)
         end if
      end if
! Define constituent var avgRainFlux
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgRainFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgRainFlux', -1)
         end if
      end if
! Define constituent var avgSnowFlux
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgSnowFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgSnowFlux', -1)
         end if
      end if
! Define constituent var avgSeaIceEnergy
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgSeaIceEnergy', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgSeaIceEnergy', -1)
         end if
      end if
! Define constituent var avgSurfaceThicknessFlux
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgSurfaceThicknessFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgSurfaceThicknessFlux', -1)
         end if
      end if
! Define constituent var avgSurfaceTemperatureFlux
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgSurfaceTemperatureFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgSurfaceTemperatureFlux', -1)
         end if
      end if
! Define constituent var avgSurfaceSalinityFlux
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgSurfaceSalinityFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgSurfaceSalinityFlux', -1)
         end if
      end if
! Define constituent var avgSeaIceSalinityFlux
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgSeaIceSalinityFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgSeaIceSalinityFlux', -1)
         end if
      end if
! Define constituent var avgSurfaceWindStressMagnitude
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgSurfaceWindStressMagnitude', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgSurfaceWindStressMagnitude', -1)
         end if
      end if
! Define constituent var avgWindStressZonal
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgWindStressZonal', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgWindStressZonal', -1)
         end if
      end if
! Define constituent var avgWindStressMeridional
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgWindStressMeridional', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgWindStressMeridional', -1)
         end if
      end if
! Define constituent var avgSeaSurfacePressure
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgSeaSurfacePressure', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgSeaSurfacePressure', -1)
         end if
      end if
! Define constituent var avgSurfaceSSH
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgSurfaceSSH', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgSurfaceSSH', -1)
         end if
      end if
! Define constituent var avgSurfaceTemperature
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgSurfaceTemperature', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgSurfaceTemperature', -1)
         end if
      end if
! Define constituent var avgSurfaceSalinity
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgSurfaceSalinity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgSurfaceSalinity', -1)
         end if
      end if
! Define constituent var avgBoundaryLayerDepth
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgBoundaryLayerDepth', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgBoundaryLayerDepth', -1)
         end if
      end if
! Define constituent var avgSurfaceNetHeatFlux
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgSurfaceNetHeatFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgSurfaceNetHeatFlux', -1)
         end if
      end if
! Define constituent var avgSurfaceNetSalinitFlux
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgSurfaceNetSalinitFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgSurfaceNetSalinitFlux', -1)
         end if
      end if
! Define constituent var avgSurfaceNetFreshWaterFlux
! My packages are surfaceAreaWeightedAveragesAMPKG
      if (surfaceAreaWeightedAveragesAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgSurfaceNetFreshWaterFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgSurfaceNetFreshWaterFlux', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'avg_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'avg_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_avgValueWithinOceanRegion', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'avgValueWithinOceanRegion'
      r2Ptr(1) % isDecomposed = .false.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_sumSurfaceMaskValue', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'sumSurfaceMaskValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgSurfaceArea', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgSurfaceArea'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLatentHeatFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgLatentHeatFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgSensibleHeatFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgSensibleHeatFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLongWaveHeatFluxUp', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgLongWaveHeatFluxUp'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLongWaveHeatFluxDown', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgLongWaveHeatFluxDown'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgSeaIceHeatFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgSeaIceHeatFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgShortWaveHeatFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgShortWaveHeatFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgEvaporationFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgEvaporationFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgSeaIceFreshWaterFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgSeaIceFreshWaterFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgRiverRunoffFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgRiverRunoffFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgIceRunoffFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgIceRunoffFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgRainFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgRainFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgSnowFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgSnowFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgSeaIceEnergy', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgSeaIceEnergy'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgSurfaceThicknessFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgSurfaceThicknessFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgSurfaceTemperatureFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgSurfaceTemperatureFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgSurfaceSalinityFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgSurfaceSalinityFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgSeaIceSalinityFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgSeaIceSalinityFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgSurfaceWindStressMagnitude', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgSurfaceWindStressMagnitude'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgWindStressZonal', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgWindStressZonal'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgWindStressMeridional', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgWindStressMeridional'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgSeaSurfacePressure', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgSeaSurfacePressure'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgSurfaceSSH', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgSurfaceSSH'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgSurfaceTemperature', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgSurfaceTemperature'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgSurfaceSalinity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgSurfaceSalinity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgBoundaryLayerDepth', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgBoundaryLayerDepth'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgSurfaceNetHeatFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgSurfaceNetHeatFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgSurfaceNetSalinitFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgSurfaceNetSalinitFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgSurfaceNetFreshWaterFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgSurfaceNetFreshWaterFlux'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_avgValueWithinOceanRegion'
      r2Ptr(1) % dimNames(2) = 'nOceanRegions'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_sumSurfaceMaskValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Sum of region mask, represents total number '&
//'of cells in region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'none')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'sumSurfaceMaskValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgSurfaceArea', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average area of a surface cell')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm^2')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgSurfaceArea'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLatentHeatFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Surface area-weighted average of latent heat '&
//'flux in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'W m^{-2}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgLatentHeatFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgSensibleHeatFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Surface area-weighted average of sensible '&
//'heat flux in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'W m^{-2}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgSensibleHeatFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLongWaveHeatFluxUp', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Surface area-weighted average of upwelling '&
//'long wave heat flux in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'W m^{-2}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgLongWaveHeatFluxUp'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLongWaveHeatFluxDown', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Surface area-weighted average of downwelling '&
//'long wave heat flux in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'W m^{-2}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgLongWaveHeatFluxDown'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgSeaIceHeatFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Surface area-weighted average of sea ice heat '&
//'flux in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'W m^{-2}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgSeaIceHeatFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgShortWaveHeatFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Surface area-weighted average of short wave '&
//'heat flux in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'W m^{-2}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgShortWaveHeatFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgEvaporationFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Surface area-weighted average of evaporation '&
//'in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgEvaporationFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgSeaIceFreshWaterFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Surface area-weighted average of sea ice melt '&
//'rate in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgSeaIceFreshWaterFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgRiverRunoffFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Surface area-weighted average of river run '&
//'off in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgRiverRunoffFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgIceRunoffFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Surface area-weighted average of ice run off '&
//'in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgIceRunoffFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgRainFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Surface area-weighted average of rain flux in '&
//'each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgRainFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgSnowFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Surface area-weighted average of snow flux in '&
//'each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgSnowFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgSeaIceEnergy', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Surface area-weighted average of sea ice '&
//'energy in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'J m^{-2}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgSeaIceEnergy'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgSurfaceThicknessFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Surface area-weighted average of surface '&
//'thickness flux in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgSurfaceThicknessFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgSurfaceTemperatureFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Surface area-weighted average of surface '&
//'temperature flux in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'C m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgSurfaceTemperatureFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgSurfaceSalinityFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Surface area-weighted average of surface '&
//'salinity flux in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'PSU m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgSurfaceSalinityFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgSeaIceSalinityFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Surface area-weighted average of sea ice '&
//'salinity flux in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'kg m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgSeaIceSalinityFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgSurfaceWindStressMagnitude', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Surface area-weighted average of wind stress '&
//'magnitude in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'N m^{-2}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgSurfaceWindStressMagnitude'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgWindStressZonal', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Surface area-weighted average of zonal wind '&
//'stress in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'N m^{-2}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgWindStressZonal'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgWindStressMeridional', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Surface area-weighted average of meridional '&
//'wind stress in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'N m^{-2}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgWindStressMeridional'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgSeaSurfacePressure', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Surface area-weighted average of sea surface '&
//'pressure in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'Pa')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgSeaSurfacePressure'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgSurfaceSSH', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Surface area-weighted average of sea-surface '&
//'height')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgSurfaceSSH'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgSurfaceTemperature', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Surface area-weighted average of surface '&
//'temperature in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'C')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgSurfaceTemperature'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgSurfaceSalinity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Surface area-weighted average of surface '&
//'salinity in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'PSU')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgSurfaceSalinity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgBoundaryLayerDepth', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Surface area-weighted average of surface '&
//'boundary layer depth in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgBoundaryLayerDepth'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgSurfaceNetHeatFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Surface area-weighted average of net surface '&
//'heat flux in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'W m^{-2}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgSurfaceNetHeatFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgSurfaceNetSalinitFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Surface area-weighted average of net surface '&
//'salinity flux in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'kg m s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgSurfaceNetSalinitFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgSurfaceNetFreshWaterFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Surface area-weighted average of net surface '&
//'fresh water flux in each region')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-2} s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgSurfaceNetFreshWaterFlux'
      end if
      r2Ptr(1) % block => block

      if (surfaceAreaWeightedAveragesAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'avgValueWithinOceanRegion', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'avgValueWithinOceanRegion', r2Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_pool_surfaceAreaWeightedAveragesAM


   subroutine ocn_generate_pool_surfaceAreaWeightedAveragesAMScratch(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'surfaceAreaWeightedAveragesAMScratch', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'surfaceAreaWeightedAveragesAMScratch', newSubPool)

! Define variable workMask
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'workMask'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .false.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'none')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'temporary array of 0 or 1 to mask data via multiplication')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'workMask', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'workMask', r1Ptr)

! Define variable workArray
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'workArray'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nSfcAreaWeightedAvgFields'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'various')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'temporary array to hold data to be analyzed')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'workArray', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'workArray', r2Ptr)

! Define variable workMin
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'workMin'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .false.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .false.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nSfcAreaWeightedAvgFields'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'various')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'temporary array to hold minimum values')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'workMin', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'workMin', r1Ptr)

! Define variable workMax
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'workMax'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .false.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .false.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nSfcAreaWeightedAvgFields'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'various')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'temporary array to hold maximum values')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'workMax', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'workMax', r1Ptr)

! Define variable workSum
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'workSum'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .false.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .false.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nSfcAreaWeightedAvgFields'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'various')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'temporary array to hold sum of values')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'workSum', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'workSum', r1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_pool_surfaceAreaWeightedAveragesAMScratch


   subroutine ocn_generate_pool_waterMassCensusAM(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'waterMassCensusAM', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'waterMassCensusAM', newSubPool)

! Define variable waterMassCensusTemperatureValues
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'waterMassCensusTemperatureValues'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .false.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nTemperatureBinsP1'
      r2Ptr(1) % dimNames(2) = 'nOceanRegionsTmpCensus'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'C')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'temperature values defining edges of temperature bins')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (waterMassCensusAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'waterMassCensusTemperatureValues', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'waterMassCensusTemperatureValues', r2Ptr)

! Define variable waterMassCensusSalinityValues
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'waterMassCensusSalinityValues'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .false.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nSalinityBinsP1'
      r2Ptr(1) % dimNames(2) = 'nOceanRegionsTmpCensus'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'C')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'salinity values defining edges of temperature bins')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (waterMassCensusAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'waterMassCensusSalinityValues', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'waterMassCensusSalinityValues', r2Ptr)

! Define variable waterMassFractionalDistribution
      allocate(r3Ptr(1))

! Setting up time level 1
      r3Ptr(1) % fieldName = 'waterMassFractionalDistribution'
      r3Ptr(1) % isVarArray = .false.
      r3Ptr(1) % isDecomposed = .false.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.
! Setting up dimensions
      r3Ptr(1) % dimNames(1) = 'nTemperatureBins'
      r3Ptr(1) % dimNames(2) = 'nSalinityBins'
      r3Ptr(1) % dimNames(3) = 'nOceanRegionsTmpCensus'
      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(1))
      allocate(r3Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'units', 'fractional')
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'long_name', 'fraction of water volume contained within each temperature '&
//'and salinity bin')
      r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r3Ptr(1) % block => block

      if (waterMassCensusAMPKGActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'waterMassFractionalDistribution', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'waterMassFractionalDistribution', r3Ptr)

! Define variable potentialDensityOfTSDiagram
      allocate(r3Ptr(1))

! Setting up time level 1
      r3Ptr(1) % fieldName = 'potentialDensityOfTSDiagram'
      r3Ptr(1) % isVarArray = .false.
      r3Ptr(1) % isDecomposed = .false.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.
! Setting up dimensions
      r3Ptr(1) % dimNames(1) = 'nTemperatureBins'
      r3Ptr(1) % dimNames(2) = 'nSalinityBins'
      r3Ptr(1) % dimNames(3) = 'nOceanRegionsTmpCensus'
      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(1))
      allocate(r3Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'units', 'kg m^{-3}')
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'long_name', 'volume-weighted potential density of each (T,S) bin')
      r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r3Ptr(1) % block => block

      if (waterMassCensusAMPKGActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'potentialDensityOfTSDiagram', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'potentialDensityOfTSDiagram', r3Ptr)

! Define variable zPositionOfTSDiagram
      allocate(r3Ptr(1))

! Setting up time level 1
      r3Ptr(1) % fieldName = 'zPositionOfTSDiagram'
      r3Ptr(1) % isVarArray = .false.
      r3Ptr(1) % isDecomposed = .false.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.
! Setting up dimensions
      r3Ptr(1) % dimNames(1) = 'nTemperatureBins'
      r3Ptr(1) % dimNames(2) = 'nSalinityBins'
      r3Ptr(1) % dimNames(3) = 'nOceanRegionsTmpCensus'
      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(1))
      allocate(r3Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'units', 'kg m^{-3}')
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'long_name', 'volume-weighted vertical position of each (T,S) bin')
      r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r3Ptr(1) % block => block

      if (waterMassCensusAMPKGActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'zPositionOfTSDiagram', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'zPositionOfTSDiagram', r3Ptr)

! Define variable waterMassCensusTemperatureValuesRegion
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'waterMassCensusTemperatureValuesRegion'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .false.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nTemperatureBinsP1'
      r2Ptr(1) % dimNames(2) = 'maxRegionsInGroup'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'C')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'temperature values defining edges of temperature bins')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (waterMassCensusAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'waterMassCensusTemperatureValuesRegion', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'waterMassCensusTemperatureValuesRegion', r2Ptr)

! Define variable waterMassCensusSalinityValuesRegion
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'waterMassCensusSalinityValuesRegion'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .false.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nSalinityBinsP1'
      r2Ptr(1) % dimNames(2) = 'maxRegionsInGroup'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'C')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'salinity values defining edges of temperature bins')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (waterMassCensusAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'waterMassCensusSalinityValuesRegion', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'waterMassCensusSalinityValuesRegion', r2Ptr)

! Define variable waterMassFractionalDistributionRegion
      allocate(r3Ptr(1))

! Setting up time level 1
      r3Ptr(1) % fieldName = 'waterMassFractionalDistributionRegion'
      r3Ptr(1) % isVarArray = .false.
      r3Ptr(1) % isDecomposed = .false.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.
! Setting up dimensions
      r3Ptr(1) % dimNames(1) = 'nTemperatureBins'
      r3Ptr(1) % dimNames(2) = 'nSalinityBins'
      r3Ptr(1) % dimNames(3) = 'maxRegionsInGroup'
      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(1))
      allocate(r3Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'units', 'fractional')
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'long_name', 'fraction of water volume contained within each temperature '&
//'and salinity bin')
      r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r3Ptr(1) % block => block

      if (waterMassCensusAMPKGActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'waterMassFractionalDistributionRegion', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'waterMassFractionalDistributionRegion', r3Ptr)

! Define variable potentialDensityOfTSDiagramRegion
      allocate(r3Ptr(1))

! Setting up time level 1
      r3Ptr(1) % fieldName = 'potentialDensityOfTSDiagramRegion'
      r3Ptr(1) % isVarArray = .false.
      r3Ptr(1) % isDecomposed = .false.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.
! Setting up dimensions
      r3Ptr(1) % dimNames(1) = 'nTemperatureBins'
      r3Ptr(1) % dimNames(2) = 'nSalinityBins'
      r3Ptr(1) % dimNames(3) = 'maxRegionsInGroup'
      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(1))
      allocate(r3Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'units', 'kg m^{-3}')
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'long_name', 'volume-weighted potential density of each (T,S) bin')
      r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r3Ptr(1) % block => block

      if (waterMassCensusAMPKGActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'potentialDensityOfTSDiagramRegion', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'potentialDensityOfTSDiagramRegion', r3Ptr)

! Define variable zPositionOfTSDiagramRegion
      allocate(r3Ptr(1))

! Setting up time level 1
      r3Ptr(1) % fieldName = 'zPositionOfTSDiagramRegion'
      r3Ptr(1) % isVarArray = .false.
      r3Ptr(1) % isDecomposed = .false.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.
! Setting up dimensions
      r3Ptr(1) % dimNames(1) = 'nTemperatureBins'
      r3Ptr(1) % dimNames(2) = 'nSalinityBins'
      r3Ptr(1) % dimNames(3) = 'maxRegionsInGroup'
      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(1))
      allocate(r3Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'units', 'kg m^{-3}')
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'long_name', 'volume-weighted vertical position of each (T,S) bin')
      r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r3Ptr(1) % block => block

      if (waterMassCensusAMPKGActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'zPositionOfTSDiagramRegion', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'zPositionOfTSDiagramRegion', r3Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_pool_waterMassCensusAM


   subroutine ocn_generate_pool_layerVolumeWeightedAverageAM(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'layerVolumeWeightedAverageAM', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'layerVolumeWeightedAverageAM', newSubPool)

! Define var array minValueWithinOceanLayerRegion
      allocate(r3Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group layerMins
! Define constituent var minLayerMaskValue
! My Packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLayerMaskValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMins_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_minLayerMaskValue', -1)
           end if
      end if
! Define constituent var minLayerArea
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLayerArea', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLayerArea', -1)
         end if
      end if
! Define constituent var minLayerThickness
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLayerThickness', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLayerThickness', -1)
         end if
      end if
! Define constituent var minLayerDensity
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLayerDensity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLayerDensity', -1)
         end if
      end if
! Define constituent var minLayerPotentialDensity
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLayerPotentialDensity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLayerPotentialDensity', -1)
         end if
      end if
! Define constituent var minLayerBruntVaisalaFreqTop
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLayerBruntVaisalaFreqTop', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLayerBruntVaisalaFreqTop', -1)
         end if
      end if
! Define constituent var minLayerVelocityZonal
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLayerVelocityZonal', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLayerVelocityZonal', -1)
         end if
      end if
! Define constituent var minLayerVelocityMeridional
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLayerVelocityMeridional', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLayerVelocityMeridional', -1)
         end if
      end if
! Define constituent var minLayerVertVelocityTop
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLayerVertVelocityTop', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLayerVertVelocityTop', -1)
         end if
      end if
! Define constituent var minLayerTemperature
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLayerTemperature', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLayerTemperature', -1)
         end if
      end if
! Define constituent var minLayerSalinity
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLayerSalinity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLayerSalinity', -1)
         end if
      end if
! Define constituent var minLayerKineticEnergyCell
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLayerKineticEnergyCell', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLayerKineticEnergyCell', -1)
         end if
      end if
! Define constituent var minLayerRelativeVorticityCell
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLayerRelativeVorticityCell', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLayerRelativeVorticityCell', -1)
         end if
      end if
! Define constituent var minLayerDivergence
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLayerDivergence', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLayerDivergence', -1)
         end if
      end if
! Define constituent var minLayerRelativeEnstrophyCell
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLayerRelativeEnstrophyCell', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLayerRelativeEnstrophyCell', -1)
         end if
      end if
! Define constituent var minLayerTemperatureHorAdv
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLayerTemperatureHorAdv', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLayerTemperatureHorAdv', -1)
         end if
      end if
! Define constituent var minLayerSalinityHorAdv
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLayerSalinityHorAdv', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLayerSalinityHorAdv', -1)
         end if
      end if
! Define constituent var minLayerTemperatureVertAdv
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLayerTemperatureVertAdv', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLayerTemperatureVertAdv', -1)
         end if
      end if
! Define constituent var minLayerSalinityVertAdv
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLayerSalinityVertAdv', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLayerSalinityVertAdv', -1)
         end if
      end if
! Define constituent var minLayerTemperatureSfcFlux
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLayerTemperatureSfcFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLayerTemperatureSfcFlux', -1)
         end if
      end if
! Define constituent var minLayerSalinitySfcFlux
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLayerSalinitySfcFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLayerSalinitySfcFlux', -1)
         end if
      end if
! Define constituent var minLayerTemperatureSW
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLayerTemperatureSW', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLayerTemperatureSW', -1)
         end if
      end if
! Define constituent var minLayerTemperatureNL
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLayerTemperatureNL', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLayerTemperatureNL', -1)
         end if
      end if
! Define constituent var minLayerSalinityNL
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLayerSalinityNL', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLayerSalinityNL', -1)
         end if
      end if
! Define constituent var minLayerTemperatureVertMix
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLayerTemperatureVertMix', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLayerTemperatureVertMix', -1)
         end if
      end if
! Define constituent var minLayerSalinityVertMix
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLayerSalinityVertMix', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minLayerSalinityVertMix', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMins_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'layerMins_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMins_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_minValueWithinOceanLayerRegion', numConstituents)
      end if
! Defining time level 1
      allocate( r3Ptr(1) % constituentNames(numConstituents) )
      r3Ptr(1) % fieldName = 'minValueWithinOceanLayerRegion'
      r3Ptr(1) % isDecomposed = .false.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isVarArray = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLayerMaskValue', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'minLayerMaskValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLayerArea', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'minLayerArea'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLayerThickness', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'minLayerThickness'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLayerDensity', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'minLayerDensity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLayerPotentialDensity', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'minLayerPotentialDensity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLayerBruntVaisalaFreqTop', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'minLayerBruntVaisalaFreqTop'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLayerVelocityZonal', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'minLayerVelocityZonal'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLayerVelocityMeridional', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'minLayerVelocityMeridional'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLayerVertVelocityTop', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'minLayerVertVelocityTop'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLayerTemperature', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'minLayerTemperature'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLayerSalinity', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'minLayerSalinity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLayerKineticEnergyCell', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'minLayerKineticEnergyCell'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLayerRelativeVorticityCell', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'minLayerRelativeVorticityCell'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLayerDivergence', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'minLayerDivergence'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLayerRelativeEnstrophyCell', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'minLayerRelativeEnstrophyCell'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLayerTemperatureHorAdv', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'minLayerTemperatureHorAdv'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLayerSalinityHorAdv', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'minLayerSalinityHorAdv'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLayerTemperatureVertAdv', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'minLayerTemperatureVertAdv'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLayerSalinityVertAdv', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'minLayerSalinityVertAdv'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLayerTemperatureSfcFlux', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'minLayerTemperatureSfcFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLayerSalinitySfcFlux', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'minLayerSalinitySfcFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLayerTemperatureSW', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'minLayerTemperatureSW'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLayerTemperatureNL', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'minLayerTemperatureNL'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLayerSalinityNL', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'minLayerSalinityNL'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLayerTemperatureVertMix', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'minLayerTemperatureVertMix'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLayerSalinityVertMix', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'minLayerSalinityVertMix'
      end if

! Setup dimensions for       
      r3Ptr(1) % dimNames(1) = 'num_minValueWithinOceanLayerRegion'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nOceanRegionsTmp'

      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(size(r3Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r3Ptr(1) % constituentNames, dim=1)
         allocate(r3Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLayerMaskValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum value of mask within region layer '&
//'(should always be 1 for valid layers)')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'none')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'minLayerMaskValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLayerArea', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum area of cell within region layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'm^2')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'minLayerArea'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLayerThickness', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum thickness within region layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'm')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'minLayerThickness'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLayerDensity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum in-situ density within region layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'minLayerDensity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLayerPotentialDensity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum potential density within region '&
//'layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'minLayerPotentialDensity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLayerBruntVaisalaFreqTop', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum Brunt Vaisala frequency within region '&
//'layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 's^{-2}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'minLayerBruntVaisalaFreqTop'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLayerVelocityZonal', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum zonal velocity within region layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'minLayerVelocityZonal'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLayerVelocityMeridional', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum meridional velocity within region '&
//'layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'minLayerVelocityMeridional'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLayerVertVelocityTop', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum vertical velocity within region '&
//'layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'minLayerVertVelocityTop'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLayerTemperature', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum surface temperature within region '&
//'layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'C')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'minLayerTemperature'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLayerSalinity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum surface salinity within region layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'PSU')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'minLayerSalinity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLayerKineticEnergyCell', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum kinetic energy within region layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'm^2 s^{-2}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'minLayerKineticEnergyCell'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLayerRelativeVorticityCell', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum relative vorticity within region '&
//'layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'minLayerRelativeVorticityCell'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLayerDivergence', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum divergence within region layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'minLayerDivergence'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLayerRelativeEnstrophyCell', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum relative enstrophy within region '&
//'layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 's^{-2}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'minLayerRelativeEnstrophyCell'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLayerTemperatureHorAdv', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum horizontal temperature advection '&
//'within region layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'C s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'minLayerTemperatureHorAdv'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLayerSalinityHorAdv', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum horizontal salinity advection within '&
//'region layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'PSU s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'minLayerSalinityHorAdv'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLayerTemperatureVertAdv', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum vertical temperature advection within '&
//'region layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'C s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'minLayerTemperatureVertAdv'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLayerSalinityVertAdv', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum vertical salinity advection within '&
//'region layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'PSU s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'minLayerSalinityVertAdv'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLayerTemperatureSfcFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum temperature surface flux tend within '&
//'region layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'C s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'minLayerTemperatureSfcFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLayerSalinitySfcFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum salinity surface flux tend within '&
//'region layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'PSU s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'minLayerSalinitySfcFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLayerTemperatureSW', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum temperature short wave tend within '&
//'region layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'C s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'minLayerTemperatureSW'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLayerTemperatureNL', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum temperature non local tend within '&
//'region layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'C s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'minLayerTemperatureNL'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLayerSalinityNL', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum salinity kpp non local tend within '&
//'region layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'PSU s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'minLayerSalinityNL'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLayerTemperatureVertMix', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum temperature vertical mixing within '&
//'region layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'C s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'minLayerTemperatureVertMix'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minLayerSalinityVertMix', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum salinity vertical mixing within '&
//'region layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'PSU s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'minLayerSalinityVertMix'
      end if
      r3Ptr(1) % block => block

      if (layerVolumeWeightedAverageAMPKGActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'minValueWithinOceanLayerRegion', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'minValueWithinOceanLayerRegion', r3Ptr)

! Define var array minValueWithinOceanVolumeRegion
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group volumeMins
! Define constituent var minVolumeMaskValue
! My Packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minVolumeMaskValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMins_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_minVolumeMaskValue', -1)
           end if
      end if
! Define constituent var minVolumeArea
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minVolumeArea', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minVolumeArea', -1)
         end if
      end if
! Define constituent var minVolumeThickness
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minVolumeThickness', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minVolumeThickness', -1)
         end if
      end if
! Define constituent var minVolumeDensity
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minVolumeDensity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minVolumeDensity', -1)
         end if
      end if
! Define constituent var minVolumePotentialDensity
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minVolumePotentialDensity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minVolumePotentialDensity', -1)
         end if
      end if
! Define constituent var minVolumeBruntVaisalaFreqTop
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minVolumeBruntVaisalaFreqTop', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minVolumeBruntVaisalaFreqTop', -1)
         end if
      end if
! Define constituent var minVolumeVelocityZonal
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minVolumeVelocityZonal', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minVolumeVelocityZonal', -1)
         end if
      end if
! Define constituent var minVolumeVelocityMeridional
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minVolumeVelocityMeridional', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minVolumeVelocityMeridional', -1)
         end if
      end if
! Define constituent var minVolumeVertVelocityTop
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minVolumeVertVelocityTop', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minVolumeVertVelocityTop', -1)
         end if
      end if
! Define constituent var minVolumeTemperature
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minVolumeTemperature', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minVolumeTemperature', -1)
         end if
      end if
! Define constituent var minVolumeSalinity
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minVolumeSalinity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minVolumeSalinity', -1)
         end if
      end if
! Define constituent var minVolumeKineticEnergyCell
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minVolumeKineticEnergyCell', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minVolumeKineticEnergyCell', -1)
         end if
      end if
! Define constituent var minVolumeRelativeVorticityCell
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minVolumeRelativeVorticityCell', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minVolumeRelativeVorticityCell', -1)
         end if
      end if
! Define constituent var minVolumeDivergence
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minVolumeDivergence', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minVolumeDivergence', -1)
         end if
      end if
! Define constituent var minVolumeRelativeEnstrophyCell
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minVolumeRelativeEnstrophyCell', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minVolumeRelativeEnstrophyCell', -1)
         end if
      end if
! Define constituent var minVolumeTemperatureHorAdv
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minVolumeTemperatureHorAdv', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minVolumeTemperatureHorAdv', -1)
         end if
      end if
! Define constituent var minVolumeSalinityHorAdv
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minVolumeSalinityHorAdv', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minVolumeSalinityHorAdv', -1)
         end if
      end if
! Define constituent var minVolumeTemperatureVertAdv
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minVolumeTemperatureVertAdv', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minVolumeTemperatureVertAdv', -1)
         end if
      end if
! Define constituent var minVolumeSalinityVertAdv
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minVolumeSalinityVertAdv', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minVolumeSalinityVertAdv', -1)
         end if
      end if
! Define constituent var minVolumeTemperatureSfcFlux
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minVolumeTemperatureSfcFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minVolumeTemperatureSfcFlux', -1)
         end if
      end if
! Define constituent var minVolumeSalinitySfcFlux
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minVolumeSalinitySfcFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minVolumeSalinitySfcFlux', -1)
         end if
      end if
! Define constituent var minVolumeTemperatureSW
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minVolumeTemperatureSW', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minVolumeTemperatureSW', -1)
         end if
      end if
! Define constituent var minVolumeTemperatureNL
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minVolumeTemperatureNL', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minVolumeTemperatureNL', -1)
         end if
      end if
! Define constituent var minVolumeSalinityNL
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minVolumeSalinityNL', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minVolumeSalinityNL', -1)
         end if
      end if
! Define constituent var minVolumeTemperatureVertMix
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minVolumeTemperatureVertMix', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minVolumeTemperatureVertMix', -1)
         end if
      end if
! Define constituent var minVolumeSalinityVertMix
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minVolumeSalinityVertMix', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMins_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_minVolumeSalinityVertMix', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMins_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'volumeMins_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMins_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_minValueWithinOceanVolumeRegion', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'minValueWithinOceanVolumeRegion'
      r2Ptr(1) % isDecomposed = .false.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minVolumeMaskValue', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minVolumeMaskValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minVolumeArea', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minVolumeArea'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minVolumeThickness', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minVolumeThickness'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minVolumeDensity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minVolumeDensity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minVolumePotentialDensity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minVolumePotentialDensity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minVolumeBruntVaisalaFreqTop', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minVolumeBruntVaisalaFreqTop'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minVolumeVelocityZonal', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minVolumeVelocityZonal'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minVolumeVelocityMeridional', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minVolumeVelocityMeridional'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minVolumeVertVelocityTop', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minVolumeVertVelocityTop'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minVolumeTemperature', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minVolumeTemperature'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minVolumeSalinity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minVolumeSalinity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minVolumeKineticEnergyCell', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minVolumeKineticEnergyCell'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minVolumeRelativeVorticityCell', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minVolumeRelativeVorticityCell'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minVolumeDivergence', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minVolumeDivergence'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minVolumeRelativeEnstrophyCell', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minVolumeRelativeEnstrophyCell'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minVolumeTemperatureHorAdv', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minVolumeTemperatureHorAdv'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minVolumeSalinityHorAdv', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minVolumeSalinityHorAdv'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minVolumeTemperatureVertAdv', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minVolumeTemperatureVertAdv'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minVolumeSalinityVertAdv', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minVolumeSalinityVertAdv'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minVolumeTemperatureSfcFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minVolumeTemperatureSfcFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minVolumeSalinitySfcFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minVolumeSalinitySfcFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minVolumeTemperatureSW', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minVolumeTemperatureSW'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minVolumeTemperatureNL', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minVolumeTemperatureNL'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minVolumeSalinityNL', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minVolumeSalinityNL'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minVolumeTemperatureVertMix', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minVolumeTemperatureVertMix'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minVolumeSalinityVertMix', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'minVolumeSalinityVertMix'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_minValueWithinOceanVolumeRegion'
      r2Ptr(1) % dimNames(2) = 'nOceanRegionsTmp'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minVolumeMaskValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum value of mask within region volume '&
//'(should always be 1 for valid volumes)')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'none')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minVolumeMaskValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minVolumeArea', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum area of cell within region volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm^2')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minVolumeArea'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minVolumeThickness', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum thickness within region volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minVolumeThickness'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minVolumeDensity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum in-situ density within region volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-3}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minVolumeDensity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minVolumePotentialDensity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum potential density within region '&
//'volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-3}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minVolumePotentialDensity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minVolumeBruntVaisalaFreqTop', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum Brunt Vaisala frequency within region '&
//'volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 's^{-2}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minVolumeBruntVaisalaFreqTop'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minVolumeVelocityZonal', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum zonal velocity within region volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minVolumeVelocityZonal'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minVolumeVelocityMeridional', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum meridional velocity within region '&
//'volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minVolumeVelocityMeridional'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minVolumeVertVelocityTop', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum vertical velocity within region '&
//'volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minVolumeVertVelocityTop'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minVolumeTemperature', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum surface temperature within region '&
//'volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'C')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minVolumeTemperature'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minVolumeSalinity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum surface salinity within region '&
//'volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'PSU')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minVolumeSalinity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minVolumeKineticEnergyCell', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum kinetic energy within region volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm^2 s^{-2}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minVolumeKineticEnergyCell'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minVolumeRelativeVorticityCell', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum relative vorticity within region '&
//'volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minVolumeRelativeVorticityCell'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minVolumeDivergence', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum divergence within region volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minVolumeDivergence'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minVolumeRelativeEnstrophyCell', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum relative enstrophy within region '&
//'volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 's^{-2}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minVolumeRelativeEnstrophyCell'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minVolumeTemperatureHorAdv', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum horizontal temperature advection '&
//'within region volumeMins')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'C s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minVolumeTemperatureHorAdv'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minVolumeSalinityHorAdv', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum horizontal salinity advection within '&
//'region volumeMins')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'PSU s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minVolumeSalinityHorAdv'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minVolumeTemperatureVertAdv', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum vertical temperature advection within '&
//'region volumeMins')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'C s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minVolumeTemperatureVertAdv'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minVolumeSalinityVertAdv', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum vertical salinity advection within '&
//'region volumeMins')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'PSU s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minVolumeSalinityVertAdv'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minVolumeTemperatureSfcFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum temperature surface flux tend within '&
//'region volumeMins')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'C s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minVolumeTemperatureSfcFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minVolumeSalinitySfcFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum salinity surface flux tend within '&
//'region volumeMins')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'PSU s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minVolumeSalinitySfcFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minVolumeTemperatureSW', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'C s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minVolumeTemperatureSW'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minVolumeTemperatureNL', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum temperature kpp non local tend within '&
//'region volumeMins')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'C s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minVolumeTemperatureNL'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minVolumeSalinityNL', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum salinity kpp non local tend within '&
//'region volumeMins')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'PSU s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minVolumeSalinityNL'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minVolumeTemperatureVertMix', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum temperature vertical mixing within '&
//'region volumeMins')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'C s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minVolumeTemperatureVertMix'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_minVolumeSalinityVertMix', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Minimum salinity vertical mixing within '&
//'region volumeMins')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'PSU s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'minVolumeSalinityVertMix'
      end if
      r2Ptr(1) % block => block

      if (layerVolumeWeightedAverageAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'minValueWithinOceanVolumeRegion', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'minValueWithinOceanVolumeRegion', r2Ptr)

! Define var array maxValueWithinOceanLayerRegion
      allocate(r3Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group layerMaxs
! Define constituent var maxLayerMaskValue
! My Packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLayerMaskValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMaxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_maxLayerMaskValue', -1)
           end if
      end if
! Define constituent var maxLayerArea
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLayerArea', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMaxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLayerArea', -1)
         end if
      end if
! Define constituent var maxLayerThickness
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLayerThickness', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMaxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLayerThickness', -1)
         end if
      end if
! Define constituent var maxLayerDensity
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLayerDensity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMaxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLayerDensity', -1)
         end if
      end if
! Define constituent var maxLayerPotentialDensity
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLayerPotentialDensity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMaxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLayerPotentialDensity', -1)
         end if
      end if
! Define constituent var maxLayerBruntVaisalaFreqTop
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLayerBruntVaisalaFreqTop', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMaxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLayerBruntVaisalaFreqTop', -1)
         end if
      end if
! Define constituent var maxLayerVelocityZonal
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLayerVelocityZonal', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMaxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLayerVelocityZonal', -1)
         end if
      end if
! Define constituent var maxLayerVelocityMeridional
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLayerVelocityMeridional', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMaxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLayerVelocityMeridional', -1)
         end if
      end if
! Define constituent var maxLayerVertVelocityTop
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLayerVertVelocityTop', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMaxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLayerVertVelocityTop', -1)
         end if
      end if
! Define constituent var maxLayerTemperature
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLayerTemperature', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMaxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLayerTemperature', -1)
         end if
      end if
! Define constituent var maxLayerSalinity
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLayerSalinity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMaxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLayerSalinity', -1)
         end if
      end if
! Define constituent var maxLayerKineticEnergyCell
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLayerKineticEnergyCell', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMaxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLayerKineticEnergyCell', -1)
         end if
      end if
! Define constituent var maxLayerRelativeVorticityCell
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLayerRelativeVorticityCell', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMaxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLayerRelativeVorticityCell', -1)
         end if
      end if
! Define constituent var maxLayerDivergence
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLayerDivergence', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMaxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLayerDivergence', -1)
         end if
      end if
! Define constituent var maxLayerRelativeEnstrophyCell
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLayerRelativeEnstrophyCell', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMaxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLayerRelativeEnstrophyCell', -1)
         end if
      end if
! Define constituent var maxLayerTemperatureHorAdv
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLayerTemperatureHorAdv', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMaxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLayerTemperatureHorAdv', -1)
         end if
      end if
! Define constituent var maxLayerSalinityHorAdv
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLayerSalinityHorAdv', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMaxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLayerSalinityHorAdv', -1)
         end if
      end if
! Define constituent var maxLayerTemperatureVertAdv
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLayerTemperatureVertAdv', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMaxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLayerTemperatureVertAdv', -1)
         end if
      end if
! Define constituent var maxLayerSalinityVertAdv
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLayerSalinityVertAdv', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMaxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLayerSalinityVertAdv', -1)
         end if
      end if
! Define constituent var maxLayerTemperatureSfcFlux
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLayerTemperatureSfcFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMaxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLayerTemperatureSfcFlux', -1)
         end if
      end if
! Define constituent var maxLayerSalinitySfcFlux
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLayerSalinitySfcFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMaxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLayerSalinitySfcFlux', -1)
         end if
      end if
! Define constituent var maxLayerTemperatureSW
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLayerTemperatureSW', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMaxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLayerTemperatureSW', -1)
         end if
      end if
! Define constituent var maxLayerTemperatureNL
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLayerTemperatureNL', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMaxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLayerTemperatureNL', -1)
         end if
      end if
! Define constituent var maxLayerSalinityNL
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLayerSalinityNL', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMaxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLayerSalinityNL', -1)
         end if
      end if
! Define constituent var maxLayerTemperatureVertMix
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLayerTemperatureVertMix', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMaxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLayerTemperatureVertMix', -1)
         end if
      end if
! Define constituent var maxLayerSalinityVertMix
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLayerSalinityVertMix', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMaxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxLayerSalinityVertMix', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMaxs_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'layerMaxs_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerMaxs_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_maxValueWithinOceanLayerRegion', numConstituents)
      end if
! Defining time level 1
      allocate( r3Ptr(1) % constituentNames(numConstituents) )
      r3Ptr(1) % fieldName = 'maxValueWithinOceanLayerRegion'
      r3Ptr(1) % isDecomposed = .false.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isVarArray = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLayerMaskValue', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'maxLayerMaskValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLayerArea', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'maxLayerArea'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLayerThickness', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'maxLayerThickness'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLayerDensity', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'maxLayerDensity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLayerPotentialDensity', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'maxLayerPotentialDensity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLayerBruntVaisalaFreqTop', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'maxLayerBruntVaisalaFreqTop'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLayerVelocityZonal', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'maxLayerVelocityZonal'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLayerVelocityMeridional', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'maxLayerVelocityMeridional'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLayerVertVelocityTop', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'maxLayerVertVelocityTop'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLayerTemperature', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'maxLayerTemperature'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLayerSalinity', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'maxLayerSalinity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLayerKineticEnergyCell', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'maxLayerKineticEnergyCell'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLayerRelativeVorticityCell', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'maxLayerRelativeVorticityCell'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLayerDivergence', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'maxLayerDivergence'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLayerRelativeEnstrophyCell', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'maxLayerRelativeEnstrophyCell'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLayerTemperatureHorAdv', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'maxLayerTemperatureHorAdv'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLayerSalinityHorAdv', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'maxLayerSalinityHorAdv'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLayerTemperatureVertAdv', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'maxLayerTemperatureVertAdv'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLayerSalinityVertAdv', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'maxLayerSalinityVertAdv'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLayerTemperatureSfcFlux', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'maxLayerTemperatureSfcFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLayerSalinitySfcFlux', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'maxLayerSalinitySfcFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLayerTemperatureSW', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'maxLayerTemperatureSW'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLayerTemperatureNL', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'maxLayerTemperatureNL'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLayerSalinityNL', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'maxLayerSalinityNL'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLayerTemperatureVertMix', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'maxLayerTemperatureVertMix'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLayerSalinityVertMix', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'maxLayerSalinityVertMix'
      end if

! Setup dimensions for       
      r3Ptr(1) % dimNames(1) = 'num_maxValueWithinOceanLayerRegion'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nOceanRegionsTmp'

      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(size(r3Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r3Ptr(1) % constituentNames, dim=1)
         allocate(r3Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLayerMaskValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum value of mask within region layer '&
//'(should always be 1 for valid layers)')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'none')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'maxLayerMaskValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLayerArea', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum area of cell within region layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'm^2')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'maxLayerArea'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLayerThickness', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum thickness within region layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'm')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'maxLayerThickness'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLayerDensity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum in-situ density within region layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'maxLayerDensity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLayerPotentialDensity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum potential density within region '&
//'layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'maxLayerPotentialDensity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLayerBruntVaisalaFreqTop', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum Brunt Vaisala frequency within region '&
//'layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 's^{-2}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'maxLayerBruntVaisalaFreqTop'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLayerVelocityZonal', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum zonal velocity within region layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'maxLayerVelocityZonal'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLayerVelocityMeridional', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum meridional velocity within region '&
//'layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'maxLayerVelocityMeridional'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLayerVertVelocityTop', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum vertical velocity within region '&
//'layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'maxLayerVertVelocityTop'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLayerTemperature', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum surface temperature within region '&
//'layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'C')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'maxLayerTemperature'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLayerSalinity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum surface salinity within region layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'PSU')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'maxLayerSalinity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLayerKineticEnergyCell', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum kinetic energy within region layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'm^2 s^{-2}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'maxLayerKineticEnergyCell'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLayerRelativeVorticityCell', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum relative vorticity within region '&
//'layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'maxLayerRelativeVorticityCell'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLayerDivergence', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum divergence within region layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'maxLayerDivergence'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLayerRelativeEnstrophyCell', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum relative enstrophy within region '&
//'layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 's^{-2}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'maxLayerRelativeEnstrophyCell'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLayerTemperatureHorAdv', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum horizontal temperature advection '&
//'within region layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'C s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'maxLayerTemperatureHorAdv'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLayerSalinityHorAdv', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum horizontal salinity advection within '&
//'region layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'PSU s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'maxLayerSalinityHorAdv'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLayerTemperatureVertAdv', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum vertical temperature advection within '&
//'region layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'C s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'maxLayerTemperatureVertAdv'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLayerSalinityVertAdv', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum vertical salinity advection within '&
//'region layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'PSU s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'maxLayerSalinityVertAdv'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLayerTemperatureSfcFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum temperature surface flux tend within '&
//'region layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'C s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'maxLayerTemperatureSfcFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLayerSalinitySfcFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum salinity surface flux tend within '&
//'region layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'PSU s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'maxLayerSalinitySfcFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLayerTemperatureSW', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum temperature short wave tend within '&
//'region layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'C s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'maxLayerTemperatureSW'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLayerTemperatureNL', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum temperature non local tend within '&
//'region layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'C s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'maxLayerTemperatureNL'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLayerSalinityNL', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum salinity non local tend within region '&
//'layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'PSU s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'maxLayerSalinityNL'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLayerTemperatureVertMix', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum temperature vertical mixing within '&
//'region layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'C s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'maxLayerTemperatureVertMix'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxLayerSalinityVertMix', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum salinity vertical mixing within '&
//'region layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'PSU s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'maxLayerSalinityVertMix'
      end if
      r3Ptr(1) % block => block

      if (layerVolumeWeightedAverageAMPKGActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'maxValueWithinOceanLayerRegion', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'maxValueWithinOceanLayerRegion', r3Ptr)

! Define var array maxValueWithinOceanVolumeRegion
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group volumeMaxs
! Define constituent var maxVolumeMaskValue
! My Packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxVolumeMaskValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMaxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_maxVolumeMaskValue', -1)
           end if
      end if
! Define constituent var maxVolumeArea
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxVolumeArea', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMaxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxVolumeArea', -1)
         end if
      end if
! Define constituent var maxVolumeThickness
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxVolumeThickness', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMaxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxVolumeThickness', -1)
         end if
      end if
! Define constituent var maxVolumeDensity
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxVolumeDensity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMaxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxVolumeDensity', -1)
         end if
      end if
! Define constituent var maxVolumePotentialDensity
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxVolumePotentialDensity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMaxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxVolumePotentialDensity', -1)
         end if
      end if
! Define constituent var maxVolumeBruntVaisalaFreqTop
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxVolumeBruntVaisalaFreqTop', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMaxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxVolumeBruntVaisalaFreqTop', -1)
         end if
      end if
! Define constituent var maxVolumeVelocityZonal
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxVolumeVelocityZonal', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMaxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxVolumeVelocityZonal', -1)
         end if
      end if
! Define constituent var maxVolumeVelocityMeridional
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxVolumeVelocityMeridional', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMaxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxVolumeVelocityMeridional', -1)
         end if
      end if
! Define constituent var maxVolumeVertVelocityTop
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxVolumeVertVelocityTop', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMaxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxVolumeVertVelocityTop', -1)
         end if
      end if
! Define constituent var maxVolumeTemperature
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxVolumeTemperature', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMaxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxVolumeTemperature', -1)
         end if
      end if
! Define constituent var maxVolumeSalinity
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxVolumeSalinity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMaxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxVolumeSalinity', -1)
         end if
      end if
! Define constituent var maxVolumeKineticEnergyCell
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxVolumeKineticEnergyCell', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMaxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxVolumeKineticEnergyCell', -1)
         end if
      end if
! Define constituent var maxVolumeRelativeVorticityCell
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxVolumeRelativeVorticityCell', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMaxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxVolumeRelativeVorticityCell', -1)
         end if
      end if
! Define constituent var maxVolumeDivergence
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxVolumeDivergence', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMaxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxVolumeDivergence', -1)
         end if
      end if
! Define constituent var maxVolumeRelativeEnstrophyCell
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxVolumeRelativeEnstrophyCell', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMaxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxVolumeRelativeEnstrophyCell', -1)
         end if
      end if
! Define constituent var maxVolumeTemperatureHorAdv
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxVolumeTemperatureHorAdv', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMaxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxVolumeTemperatureHorAdv', -1)
         end if
      end if
! Define constituent var maxVolumeSalinityHorAdv
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxVolumeSalinityHorAdv', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMaxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxVolumeSalinityHorAdv', -1)
         end if
      end if
! Define constituent var maxVolumeTemperatureVertAdv
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxVolumeTemperatureVertAdv', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMaxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxVolumeTemperatureVertAdv', -1)
         end if
      end if
! Define constituent var maxVolumeSalinityVertAdv
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxVolumeSalinityVertAdv', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMaxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxVolumeSalinityVertAdv', -1)
         end if
      end if
! Define constituent var maxVolumeTemperatureSfcFlux
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxVolumeTemperatureSfcFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMaxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxVolumeTemperatureSfcFlux', -1)
         end if
      end if
! Define constituent var maxVolumeSalinitySfcFlux
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxVolumeSalinitySfcFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMaxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxVolumeSalinitySfcFlux', -1)
         end if
      end if
! Define constituent var maxVolumeTemperatureSW
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxVolumeTemperatureSW', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMaxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxVolumeTemperatureSW', -1)
         end if
      end if
! Define constituent var maxVolumeTemperatureNL
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxVolumeTemperatureNL', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMaxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxVolumeTemperatureNL', -1)
         end if
      end if
! Define constituent var maxVolumeSalinityNL
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxVolumeSalinityNL', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMaxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxVolumeSalinityNL', -1)
         end if
      end if
! Define constituent var maxVolumeTemperatureVertMix
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxVolumeTemperatureVertMix', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMaxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxVolumeTemperatureVertMix', -1)
         end if
      end if
! Define constituent var maxVolumeSalinityVertMix
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxVolumeSalinityVertMix', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMaxs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_maxVolumeSalinityVertMix', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMaxs_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'volumeMaxs_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeMaxs_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_maxValueWithinOceanVolumeRegion', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'maxValueWithinOceanVolumeRegion'
      r2Ptr(1) % isDecomposed = .false.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxVolumeMaskValue', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxVolumeMaskValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxVolumeArea', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxVolumeArea'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxVolumeThickness', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxVolumeThickness'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxVolumeDensity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxVolumeDensity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxVolumePotentialDensity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxVolumePotentialDensity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxVolumeBruntVaisalaFreqTop', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxVolumeBruntVaisalaFreqTop'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxVolumeVelocityZonal', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxVolumeVelocityZonal'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxVolumeVelocityMeridional', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxVolumeVelocityMeridional'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxVolumeVertVelocityTop', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxVolumeVertVelocityTop'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxVolumeTemperature', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxVolumeTemperature'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxVolumeSalinity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxVolumeSalinity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxVolumeKineticEnergyCell', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxVolumeKineticEnergyCell'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxVolumeRelativeVorticityCell', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxVolumeRelativeVorticityCell'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxVolumeDivergence', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxVolumeDivergence'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxVolumeRelativeEnstrophyCell', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxVolumeRelativeEnstrophyCell'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxVolumeTemperatureHorAdv', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxVolumeTemperatureHorAdv'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxVolumeSalinityHorAdv', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxVolumeSalinityHorAdv'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxVolumeTemperatureVertAdv', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxVolumeTemperatureVertAdv'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxVolumeSalinityVertAdv', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxVolumeSalinityVertAdv'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxVolumeTemperatureSfcFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxVolumeTemperatureSfcFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxVolumeSalinitySfcFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxVolumeSalinitySfcFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxVolumeTemperatureSW', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxVolumeTemperatureSW'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxVolumeTemperatureNL', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxVolumeTemperatureNL'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxVolumeSalinityNL', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxVolumeSalinityNL'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxVolumeTemperatureVertMix', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxVolumeTemperatureVertMix'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxVolumeSalinityVertMix', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'maxVolumeSalinityVertMix'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_maxValueWithinOceanVolumeRegion'
      r2Ptr(1) % dimNames(2) = 'nOceanRegionsTmp'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxVolumeMaskValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum value of mask within region volume '&
//'(should always be 1 for valid volumes)')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'none')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxVolumeMaskValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxVolumeArea', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum area of cell within region volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm^2')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxVolumeArea'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxVolumeThickness', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum thickness within region volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxVolumeThickness'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxVolumeDensity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum in-situ density within region volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-3}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxVolumeDensity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxVolumePotentialDensity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum potential density within region '&
//'volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-3}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxVolumePotentialDensity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxVolumeBruntVaisalaFreqTop', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum Brunt Vaisala frequency within region '&
//'volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 's^{-2}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxVolumeBruntVaisalaFreqTop'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxVolumeVelocityZonal', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum zonal velocity within region volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxVolumeVelocityZonal'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxVolumeVelocityMeridional', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum meridional velocity within region '&
//'volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxVolumeVelocityMeridional'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxVolumeVertVelocityTop', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum vertical velocity within region '&
//'volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxVolumeVertVelocityTop'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxVolumeTemperature', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum surface temperature within region '&
//'volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'C')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxVolumeTemperature'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxVolumeSalinity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum surface salinity within region '&
//'volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'PSU')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxVolumeSalinity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxVolumeKineticEnergyCell', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum kinetic energy within region volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm^2 s^{-2}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxVolumeKineticEnergyCell'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxVolumeRelativeVorticityCell', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum relative vorticity within region '&
//'volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxVolumeRelativeVorticityCell'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxVolumeDivergence', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum divergence within region volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxVolumeDivergence'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxVolumeRelativeEnstrophyCell', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum relative enstrophy within region '&
//'volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 's^{-2}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxVolumeRelativeEnstrophyCell'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxVolumeTemperatureHorAdv', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum horizontal temperature advection '&
//'within region volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'C s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxVolumeTemperatureHorAdv'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxVolumeSalinityHorAdv', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum horizontal salinity advection within '&
//'region volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'PSU s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxVolumeSalinityHorAdv'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxVolumeTemperatureVertAdv', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum vertical temperature advection within '&
//'region volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'C s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxVolumeTemperatureVertAdv'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxVolumeSalinityVertAdv', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum vertical salinity advection within '&
//'region volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'PSU s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxVolumeSalinityVertAdv'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxVolumeTemperatureSfcFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum temperature surface flux tend within '&
//'region volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'C s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxVolumeTemperatureSfcFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxVolumeSalinitySfcFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum salinity surface flux tend within '&
//'region volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'PSU s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxVolumeSalinitySfcFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxVolumeTemperatureSW', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum temperature short wave tend within '&
//'region volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'C s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxVolumeTemperatureSW'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxVolumeTemperatureNL', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum temperature non local tend within '&
//'region volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'C s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxVolumeTemperatureNL'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxVolumeSalinityNL', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum salinity non local tend within region '&
//'volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'PSU s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxVolumeSalinityNL'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxVolumeTemperatureVertMix', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum temperature vertical mixing within '&
//'region volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'C s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxVolumeTemperatureVertMix'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_maxVolumeSalinityVertMix', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Maximum salinity vertical mixing within '&
//'region volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'PSU s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'maxVolumeSalinityVertMix'
      end if
      r2Ptr(1) % block => block

      if (layerVolumeWeightedAverageAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'maxValueWithinOceanVolumeRegion', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'maxValueWithinOceanVolumeRegion', r2Ptr)

! Define var array avgValueWithinOceanLayerRegion
      allocate(r3Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group layerAvgs
! Define constituent var sumLayerMaskValue
! My Packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_sumLayerMaskValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerAvgs_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_sumLayerMaskValue', -1)
           end if
      end if
! Define constituent var avgLayerArea
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLayerArea', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerAvgs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLayerArea', -1)
         end if
      end if
! Define constituent var avgLayerThickness
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLayerThickness', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerAvgs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLayerThickness', -1)
         end if
      end if
! Define constituent var avgLayerDensity
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLayerDensity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerAvgs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLayerDensity', -1)
         end if
      end if
! Define constituent var avgLayerPotentialDensity
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLayerPotentialDensity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerAvgs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLayerPotentialDensity', -1)
         end if
      end if
! Define constituent var avgLayerBruntVaisalaFreqTop
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLayerBruntVaisalaFreqTop', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerAvgs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLayerBruntVaisalaFreqTop', -1)
         end if
      end if
! Define constituent var avgLayerVelocityZonal
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLayerVelocityZonal', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerAvgs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLayerVelocityZonal', -1)
         end if
      end if
! Define constituent var avgLayerVelocityMeridional
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLayerVelocityMeridional', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerAvgs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLayerVelocityMeridional', -1)
         end if
      end if
! Define constituent var avgLayerVertVelocityTop
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLayerVertVelocityTop', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerAvgs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLayerVertVelocityTop', -1)
         end if
      end if
! Define constituent var avgLayerTemperature
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLayerTemperature', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerAvgs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLayerTemperature', -1)
         end if
      end if
! Define constituent var avgLayerSalinity
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLayerSalinity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerAvgs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLayerSalinity', -1)
         end if
      end if
! Define constituent var avgLayerKineticEnergyCell
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLayerKineticEnergyCell', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerAvgs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLayerKineticEnergyCell', -1)
         end if
      end if
! Define constituent var avgLayerRelativeVorticityCell
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLayerRelativeVorticityCell', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerAvgs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLayerRelativeVorticityCell', -1)
         end if
      end if
! Define constituent var avgLayerDivergence
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLayerDivergence', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerAvgs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLayerDivergence', -1)
         end if
      end if
! Define constituent var avgLayerRelativeEnstrophyCell
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLayerRelativeEnstrophyCell', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerAvgs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLayerRelativeEnstrophyCell', -1)
         end if
      end if
! Define constituent var avgLayerTemperatureHorAdv
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLayerTemperatureHorAdv', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerAvgs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLayerTemperatureHorAdv', -1)
         end if
      end if
! Define constituent var avgLayerSalinityHorAdv
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLayerSalinityHorAdv', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerAvgs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLayerSalinityHorAdv', -1)
         end if
      end if
! Define constituent var avgLayerTemperatureVertAdv
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLayerTemperatureVertAdv', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerAvgs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLayerTemperatureVertAdv', -1)
         end if
      end if
! Define constituent var avgLayerSalinityVertAdv
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLayerSalinityVertAdv', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerAvgs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLayerSalinityVertAdv', -1)
         end if
      end if
! Define constituent var avgLayerTemperatureSfcFlux
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLayerTemperatureSfcFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerAvgs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLayerTemperatureSfcFlux', -1)
         end if
      end if
! Define constituent var avgLayerSalinitySfcFlux
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLayerSalinitySfcFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerAvgs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLayerSalinitySfcFlux', -1)
         end if
      end if
! Define constituent var avgLayerTemperatureSW
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLayerTemperatureSW', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerAvgs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLayerTemperatureSW', -1)
         end if
      end if
! Define constituent var avgLayerTemperatureNL
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLayerTemperatureNL', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerAvgs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLayerTemperatureNL', -1)
         end if
      end if
! Define constituent var avgLayerSalinityNL
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLayerSalinityNL', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerAvgs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLayerSalinityNL', -1)
         end if
      end if
! Define constituent var avgLayerTemperatureVertMix
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLayerTemperatureVertMix', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerAvgs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLayerTemperatureVertMix', -1)
         end if
      end if
! Define constituent var avgLayerSalinityVertMix
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLayerSalinityVertMix', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerAvgs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgLayerSalinityVertMix', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerAvgs_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'layerAvgs_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'layerAvgs_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_avgValueWithinOceanLayerRegion', numConstituents)
      end if
! Defining time level 1
      allocate( r3Ptr(1) % constituentNames(numConstituents) )
      r3Ptr(1) % fieldName = 'avgValueWithinOceanLayerRegion'
      r3Ptr(1) % isDecomposed = .false.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isVarArray = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_sumLayerMaskValue', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'sumLayerMaskValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLayerArea', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'avgLayerArea'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLayerThickness', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'avgLayerThickness'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLayerDensity', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'avgLayerDensity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLayerPotentialDensity', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'avgLayerPotentialDensity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLayerBruntVaisalaFreqTop', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'avgLayerBruntVaisalaFreqTop'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLayerVelocityZonal', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'avgLayerVelocityZonal'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLayerVelocityMeridional', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'avgLayerVelocityMeridional'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLayerVertVelocityTop', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'avgLayerVertVelocityTop'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLayerTemperature', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'avgLayerTemperature'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLayerSalinity', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'avgLayerSalinity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLayerKineticEnergyCell', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'avgLayerKineticEnergyCell'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLayerRelativeVorticityCell', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'avgLayerRelativeVorticityCell'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLayerDivergence', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'avgLayerDivergence'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLayerRelativeEnstrophyCell', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'avgLayerRelativeEnstrophyCell'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLayerTemperatureHorAdv', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'avgLayerTemperatureHorAdv'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLayerSalinityHorAdv', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'avgLayerSalinityHorAdv'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLayerTemperatureVertAdv', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'avgLayerTemperatureVertAdv'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLayerSalinityVertAdv', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'avgLayerSalinityVertAdv'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLayerTemperatureSfcFlux', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'avgLayerTemperatureSfcFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLayerSalinitySfcFlux', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'avgLayerSalinitySfcFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLayerTemperatureSW', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'avgLayerTemperatureSW'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLayerTemperatureNL', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'avgLayerTemperatureNL'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLayerSalinityNL', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'avgLayerSalinityNL'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLayerTemperatureVertMix', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'avgLayerTemperatureVertMix'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLayerSalinityVertMix', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'avgLayerSalinityVertMix'
      end if

! Setup dimensions for       
      r3Ptr(1) % dimNames(1) = 'num_avgValueWithinOceanLayerRegion'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nOceanRegionsTmp'

      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(size(r3Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r3Ptr(1) % constituentNames, dim=1)
         allocate(r3Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_sumLayerMaskValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Sum value of mask within region volume '&
//'(should always be greater than 0 for valid layer)')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'none')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'sumLayerMaskValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLayerArea', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average area of cell within region layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'm^2')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'avgLayerArea'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLayerThickness', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average thickness within region layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'm')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'avgLayerThickness'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLayerDensity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average in-situ density within region layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'avgLayerDensity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLayerPotentialDensity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average potential density within region '&
//'layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-3}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'avgLayerPotentialDensity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLayerBruntVaisalaFreqTop', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average Brunt Vaisala frequency within region '&
//'layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 's^{-2}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'avgLayerBruntVaisalaFreqTop'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLayerVelocityZonal', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average zonal velocity within region layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'avgLayerVelocityZonal'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLayerVelocityMeridional', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average meridional velocity within region '&
//'layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'avgLayerVelocityMeridional'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLayerVertVelocityTop', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average vertical velocity within region '&
//'layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'avgLayerVertVelocityTop'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLayerTemperature', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average surface temperature within region '&
//'layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'C')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'avgLayerTemperature'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLayerSalinity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average surface salinity within region layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'PSU')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'avgLayerSalinity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLayerKineticEnergyCell', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average kinetic energy within region layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'm^2 s^{-2}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'avgLayerKineticEnergyCell'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLayerRelativeVorticityCell', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average relative vorticity within region '&
//'layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'avgLayerRelativeVorticityCell'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLayerDivergence', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average divergence within region layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'avgLayerDivergence'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLayerRelativeEnstrophyCell', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average relative enstrophy within region '&
//'layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 's^{-2}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'avgLayerRelativeEnstrophyCell'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLayerTemperatureHorAdv', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average horizontal temperature advection '&
//'within region layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'C s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'avgLayerTemperatureHorAdv'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLayerSalinityHorAdv', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average horizontal salinity advection within '&
//'region layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'PSU s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'avgLayerSalinityHorAdv'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLayerTemperatureVertAdv', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average vertical temperature advection within '&
//'region layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'C s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'avgLayerTemperatureVertAdv'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLayerSalinityVertAdv', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average vertical salinity advection within '&
//'region layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'PSU s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'avgLayerSalinityVertAdv'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLayerTemperatureSfcFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average temperature surface flux tend within '&
//'region layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'C s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'avgLayerTemperatureSfcFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLayerSalinitySfcFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average salinity surface flux tend within '&
//'region layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'PSU s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'avgLayerSalinitySfcFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLayerTemperatureSW', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average temperature shortwave tend within '&
//'region layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'C s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'avgLayerTemperatureSW'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLayerTemperatureNL', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average temperature non local tend within '&
//'region layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'C s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'avgLayerTemperatureNL'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLayerSalinityNL', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average salinity non local tend within region '&
//'layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'PSU s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'avgLayerSalinityNL'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLayerTemperatureVertMix', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average temperature vertical mixing within '&
//'region layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'C s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'avgLayerTemperatureVertMix'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgLayerSalinityVertMix', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average salinity vertical mixing within '&
//'region layer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'PSU s^{-1}')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'avgLayerSalinityVertMix'
      end if
      r3Ptr(1) % block => block

      if (layerVolumeWeightedAverageAMPKGActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'avgValueWithinOceanLayerRegion', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'avgValueWithinOceanLayerRegion', r3Ptr)

! Define var array avgValueWithinOceanVolumeRegion
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group volumeAvgs
! Define constituent var sumVolumeMaskValue
! My Packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_sumVolumeMaskValue', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeAvgs_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_sumVolumeMaskValue', -1)
           end if
      end if
! Define constituent var avgVolumeArea
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgVolumeArea', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeAvgs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgVolumeArea', -1)
         end if
      end if
! Define constituent var avgVolumeThickness
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgVolumeThickness', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeAvgs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgVolumeThickness', -1)
         end if
      end if
! Define constituent var avgVolumeDensity
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgVolumeDensity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeAvgs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgVolumeDensity', -1)
         end if
      end if
! Define constituent var avgVolumePotentialDensity
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgVolumePotentialDensity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeAvgs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgVolumePotentialDensity', -1)
         end if
      end if
! Define constituent var avgVolumeBruntVaisalaFreqTop
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgVolumeBruntVaisalaFreqTop', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeAvgs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgVolumeBruntVaisalaFreqTop', -1)
         end if
      end if
! Define constituent var avgVolumeVelocityZonal
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgVolumeVelocityZonal', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeAvgs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgVolumeVelocityZonal', -1)
         end if
      end if
! Define constituent var avgVolumeVelocityMeridional
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgVolumeVelocityMeridional', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeAvgs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgVolumeVelocityMeridional', -1)
         end if
      end if
! Define constituent var avgVolumeVertVelocityTop
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgVolumeVertVelocityTop', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeAvgs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgVolumeVertVelocityTop', -1)
         end if
      end if
! Define constituent var avgVolumeTemperature
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgVolumeTemperature', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeAvgs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgVolumeTemperature', -1)
         end if
      end if
! Define constituent var avgVolumeSalinity
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgVolumeSalinity', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeAvgs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgVolumeSalinity', -1)
         end if
      end if
! Define constituent var avgVolumeKineticEnergyCell
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgVolumeKineticEnergyCell', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeAvgs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgVolumeKineticEnergyCell', -1)
         end if
      end if
! Define constituent var avgVolumeRelativeVorticityCell
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgVolumeRelativeVorticityCell', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeAvgs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgVolumeRelativeVorticityCell', -1)
         end if
      end if
! Define constituent var avgVolumeDivergence
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgVolumeDivergence', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeAvgs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgVolumeDivergence', -1)
         end if
      end if
! Define constituent var avgVolumeRelativeEnstrophyCell
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgVolumeRelativeEnstrophyCell', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeAvgs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgVolumeRelativeEnstrophyCell', -1)
         end if
      end if
! Define constituent var avgVolumeTemperatureHorAdv
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgVolumeTemperatureHorAdv', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeAvgs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgVolumeTemperatureHorAdv', -1)
         end if
      end if
! Define constituent var avgVolumeSalinityHorAdv
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgVolumeSalinityHorAdv', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeAvgs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgVolumeSalinityHorAdv', -1)
         end if
      end if
! Define constituent var avgVolumeTemperatureVertAdv
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgVolumeTemperatureVertAdv', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeAvgs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgVolumeTemperatureVertAdv', -1)
         end if
      end if
! Define constituent var avgVolumeSalinityVertAdv
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgVolumeSalinityVertAdv', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeAvgs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgVolumeSalinityVertAdv', -1)
         end if
      end if
! Define constituent var avgVolumeTemperatureSfcFlux
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgVolumeTemperatureSfcFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeAvgs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgVolumeTemperatureSfcFlux', -1)
         end if
      end if
! Define constituent var avgVolumeSalinitySfcFlux
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgVolumeSalinitySfcFlux', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeAvgs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgVolumeSalinitySfcFlux', -1)
         end if
      end if
! Define constituent var avgVolumeTemperatureSW
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgVolumeTemperatureSW', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeAvgs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgVolumeTemperatureSW', -1)
         end if
      end if
! Define constituent var avgVolumeTemperatureNL
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgVolumeTemperatureNL', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeAvgs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgVolumeTemperatureNL', -1)
         end if
      end if
! Define constituent var avgVolumeSalinitySfcNL
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgVolumeSalinitySfcNL', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeAvgs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgVolumeSalinitySfcNL', -1)
         end if
      end if
! Define constituent var avgVolumeTemperatureVertMix
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgVolumeTemperatureVertMix', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeAvgs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgVolumeTemperatureVertMix', -1)
         end if
      end if
! Define constituent var avgVolumeSalinityVertMix
! My packages are layerVolumeWeightedAverageAMPKG
      if (layerVolumeWeightedAverageAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgVolumeSalinityVertMix', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeAvgs_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_avgVolumeSalinityVertMix', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeAvgs_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'volumeAvgs_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'volumeAvgs_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_avgValueWithinOceanVolumeRegion', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'avgValueWithinOceanVolumeRegion'
      r2Ptr(1) % isDecomposed = .false.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_sumVolumeMaskValue', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'sumVolumeMaskValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgVolumeArea', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgVolumeArea'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgVolumeThickness', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgVolumeThickness'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgVolumeDensity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgVolumeDensity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgVolumePotentialDensity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgVolumePotentialDensity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgVolumeBruntVaisalaFreqTop', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgVolumeBruntVaisalaFreqTop'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgVolumeVelocityZonal', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgVolumeVelocityZonal'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgVolumeVelocityMeridional', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgVolumeVelocityMeridional'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgVolumeVertVelocityTop', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgVolumeVertVelocityTop'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgVolumeTemperature', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgVolumeTemperature'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgVolumeSalinity', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgVolumeSalinity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgVolumeKineticEnergyCell', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgVolumeKineticEnergyCell'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgVolumeRelativeVorticityCell', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgVolumeRelativeVorticityCell'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgVolumeDivergence', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgVolumeDivergence'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgVolumeRelativeEnstrophyCell', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgVolumeRelativeEnstrophyCell'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgVolumeTemperatureHorAdv', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgVolumeTemperatureHorAdv'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgVolumeSalinityHorAdv', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgVolumeSalinityHorAdv'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgVolumeTemperatureVertAdv', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgVolumeTemperatureVertAdv'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgVolumeSalinityVertAdv', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgVolumeSalinityVertAdv'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgVolumeTemperatureSfcFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgVolumeTemperatureSfcFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgVolumeSalinitySfcFlux', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgVolumeSalinitySfcFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgVolumeTemperatureSW', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgVolumeTemperatureSW'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgVolumeTemperatureNL', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgVolumeTemperatureNL'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgVolumeSalinitySfcNL', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgVolumeSalinitySfcNL'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgVolumeTemperatureVertMix', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgVolumeTemperatureVertMix'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgVolumeSalinityVertMix', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'avgVolumeSalinityVertMix'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_avgValueWithinOceanVolumeRegion'
      r2Ptr(1) % dimNames(2) = 'nOceanRegionsTmp'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_sumVolumeMaskValue', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Sum value of mask within region volume '&
//'(should always be greater than 0 for valid volumes)')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'none')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'sumVolumeMaskValue'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgVolumeArea', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average area of cell within region volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm^2')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgVolumeArea'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgVolumeThickness', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average thickness within region volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgVolumeThickness'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgVolumeDensity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average in-situ density within region volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-3}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgVolumeDensity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgVolumePotentialDensity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average potential density within region '&
//'volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'kg m^{-3}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgVolumePotentialDensity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgVolumeBruntVaisalaFreqTop', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average Brunt Vaisala frequency within region '&
//'volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 's^{-2}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgVolumeBruntVaisalaFreqTop'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgVolumeVelocityZonal', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average zonal velocity within region volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgVolumeVelocityZonal'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgVolumeVelocityMeridional', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average meridional velocity within region '&
//'volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgVolumeVelocityMeridional'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgVolumeVertVelocityTop', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average vertical velocity within region '&
//'volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgVolumeVertVelocityTop'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgVolumeTemperature', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average surface temperature within region '&
//'volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'C')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgVolumeTemperature'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgVolumeSalinity', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average surface salinity within region '&
//'volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'PSU')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgVolumeSalinity'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgVolumeKineticEnergyCell', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average kinetic energy within region volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'm^2 s^{-2}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgVolumeKineticEnergyCell'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgVolumeRelativeVorticityCell', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average relative vorticity within region '&
//'volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgVolumeRelativeVorticityCell'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgVolumeDivergence', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average divergence within region volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 's^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgVolumeDivergence'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgVolumeRelativeEnstrophyCell', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average relative enstrophy within region '&
//'volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 's^{-2}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgVolumeRelativeEnstrophyCell'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgVolumeTemperatureHorAdv', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average horizontal temperature advection '&
//'within region volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'C s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgVolumeTemperatureHorAdv'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgVolumeSalinityHorAdv', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average horizontal salinity advection within '&
//'region volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'PSU s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgVolumeSalinityHorAdv'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgVolumeTemperatureVertAdv', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average vertical temperature advection within '&
//'region volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'C s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgVolumeTemperatureVertAdv'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgVolumeSalinityVertAdv', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average vertical salinity advection within '&
//'region volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'PSU s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgVolumeSalinityVertAdv'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgVolumeTemperatureSfcFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average temperature surface flux tend within '&
//'region volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'C s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgVolumeTemperatureSfcFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgVolumeSalinitySfcFlux', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average salinity surface flux tend within '&
//'region volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'PSU s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgVolumeSalinitySfcFlux'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgVolumeTemperatureSW', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average temperature shortwave tend within '&
//'region volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'C s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgVolumeTemperatureSW'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgVolumeTemperatureNL', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average temperature non local tend within '&
//'region volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'C s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgVolumeTemperatureNL'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgVolumeSalinitySfcNL', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average salinity non local tend within region '&
//'volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'PSU s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgVolumeSalinitySfcNL'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgVolumeTemperatureVertMix', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average temperature vertical mixing within '&
//'region volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'C s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgVolumeTemperatureVertMix'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_avgVolumeSalinityVertMix', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'Average salinity vertical mixing within '&
//'region volume')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'PSU s^{-1}')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'avgVolumeSalinityVertMix'
      end if
      r2Ptr(1) % block => block

      if (layerVolumeWeightedAverageAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'avgValueWithinOceanVolumeRegion', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'avgValueWithinOceanVolumeRegion', r2Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_pool_layerVolumeWeightedAverageAM


   subroutine ocn_generate_pool_layerVolumeWeightedAverageAMScratch(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'layerVolumeWeightedAverageAMScratch', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'layerVolumeWeightedAverageAMScratch', newSubPool)

! Define variable workMaskLayerVolume
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'workMaskLayerVolume'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .false.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'none')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'temporary array of 0 or 1 to mask data via multiplication')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'workMaskLayerVolume', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'workMaskLayerVolume', r1Ptr)

! Define variable workArrayLayerVolume
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'workArrayLayerVolume'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nLayerVolWeightedAvgFields'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'various')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'temporary array to hold data to be analyzed')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'workArrayLayerVolume', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'workArrayLayerVolume', r2Ptr)

! Define variable workMinLayerVolume
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'workMinLayerVolume'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .false.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .false.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nLayerVolWeightedAvgFields'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'various')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'temporary array to hold minimum values')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'workMinLayerVolume', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'workMinLayerVolume', r1Ptr)

! Define variable workMaxLayerVolume
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'workMaxLayerVolume'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .false.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .false.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nLayerVolWeightedAvgFields'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'various')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'temporary array to hold maximum values')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'workMaxLayerVolume', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'workMaxLayerVolume', r1Ptr)

! Define variable workSumLayerVolume
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'workSumLayerVolume'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .false.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .false.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nLayerVolWeightedAvgFields'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'various')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'temporary array to hold sum of values')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      r1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'workSumLayerVolume', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'workSumLayerVolume', r1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_pool_layerVolumeWeightedAverageAMScratch


   subroutine ocn_generate_pool_zonalMeanAM(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'zonalMeanAM', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'zonalMeanAM', newSubPool)

! Define var array tracersZonalMean
      allocate(r3Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group dynamics
! Define constituent var temperatureZonalMean
! My Packages are zonalMeanAMPKG
      if (zonalMeanAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureZonalMean', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'dynamics_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_temperatureZonalMean', -1)
           end if
      end if
! Define constituent var salinityZonalMean
! My packages are zonalMeanAMPKG
      if (zonalMeanAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityZonalMean', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'dynamics_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityZonalMean', -1)
         end if
      end if
! Define constituent var tracer1ZonalMean
! My packages are zonalMeanAMPKG
      if (zonalMeanAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_tracer1ZonalMean', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'dynamics_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_tracer1ZonalMean', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'dynamics_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'dynamics_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'dynamics_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_tracersZonalMean', numConstituents)
      end if
! Defining time level 1
      allocate( r3Ptr(1) % constituentNames(numConstituents) )
      r3Ptr(1) % fieldName = 'tracersZonalMean'
      r3Ptr(1) % isDecomposed = .false.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isVarArray = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureZonalMean', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'temperatureZonalMean'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityZonalMean', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'salinityZonalMean'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_tracer1ZonalMean', const_index)
      end if
      if (const_index > 0) then
         r3Ptr(1) % constituentNames(const_index) = 'tracer1ZonalMean'
      end if

! Setup dimensions for       
      r3Ptr(1) % dimNames(1) = 'num_tracersZonalMean'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'nZonalMeanBins'

      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(size(r3Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r3Ptr(1) % constituentNames, dim=1)
         allocate(r3Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureZonalMean', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Zonal mean of potential temperature')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'degrees Celsius')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'temperatureZonalMean'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityZonalMean', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Zonal mean of salinity')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'grams salt per kilogram seawater')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'salinityZonalMean'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_tracer1ZonalMean', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'long_name', 'Zonal mean of tracer')
         call mpas_add_att(r3Ptr(1) % attLists(const_index) % attList, 'units', 'na')
         r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r3Ptr(1) % constituentNames(const_index) = 'tracer1ZonalMean'
      end if
      r3Ptr(1) % block => block

      if (zonalMeanAMPKGActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'tracersZonalMean', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'tracersZonalMean', r3Ptr)

! Define variable binCenterZonalMean
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'binCenterZonalMean'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .false.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nZonalMeanBins'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'varies')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Central coordinate of zonal mean bin, either in latitude '&
//'or y, for plotting.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (zonalMeanAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'binCenterZonalMean', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'binCenterZonalMean', r1Ptr)

! Define variable binBoundaryZonalMean
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'binBoundaryZonalMean'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .false.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nZonalMeanBinsP1'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'varies')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Coordinate of lower edge of zonal mean bin, either in '&
//'latitude or y, for plotting.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (zonalMeanAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'binBoundaryZonalMean', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'binBoundaryZonalMean', r1Ptr)

! Define variable velocityZonalZonalMean
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'velocityZonalZonalMean'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .false.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nZonalMeanBins'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Zonal mean of component of horizontal velocity in the '&
//'eastward direction')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (zonalMeanAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'velocityZonalZonalMean', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'velocityZonalZonalMean', r2Ptr)

! Define variable velocityMeridionalZonalMean
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'velocityMeridionalZonalMean'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .false.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nZonalMeanBins'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Zonal mean of component of horizontal velocity in the '&
//'northward direction')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (zonalMeanAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'velocityMeridionalZonalMean', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'velocityMeridionalZonalMean', r2Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_pool_zonalMeanAM


   subroutine ocn_generate_pool_okuboWeissScratch(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'okuboWeissScratch', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'okuboWeissScratch', newSubPool)

! Define variable thresholdedOkuboWeiss
      allocate(i2Ptr(1))

! Setting up time level 1
      i2Ptr(1) % fieldName = 'thresholdedOkuboWeiss'
      i2Ptr(1) % isVarArray = .false.
      i2Ptr(1) % isDecomposed = .true.
      i2Ptr(1) % hasTimeDimension = .true.
      i2Ptr(1) % isPersistent = .false.
      i2Ptr(1) % isActive = .false.
! Setting up dimensions
      i2Ptr(1) % dimNames(1) = 'nVertLevels'
      i2Ptr(1) % dimNames(2) = 'nCells'
      i2Ptr(1) % defaultValue = 0
      allocate(i2Ptr(1) % attLists(1))
      allocate(i2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'units', 'none')
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'long_name', 'Thresholded Okubo-Weiss value')
      i2Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i2Ptr(1) % block => block

      i2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'thresholdedOkuboWeiss', i2Ptr)
      call mpas_pool_add_field(block % allFields, 'thresholdedOkuboWeiss', i2Ptr)

! Define variable velocityGradient
      allocate(r4Ptr(1))

! Setting up time level 1
      r4Ptr(1) % fieldName = 'velocityGradient'
      r4Ptr(1) % isVarArray = .false.
      r4Ptr(1) % isDecomposed = .true.
      r4Ptr(1) % hasTimeDimension = .true.
      r4Ptr(1) % isPersistent = .false.
      r4Ptr(1) % isActive = .false.
! Setting up dimensions
      r4Ptr(1) % dimNames(1) = 'R3'
      r4Ptr(1) % dimNames(2) = 'R3'
      r4Ptr(1) % dimNames(3) = 'nVertLevels'
      r4Ptr(1) % dimNames(4) = 'nCells'
      r4Ptr(1) % defaultValue = 0.0
      allocate(r4Ptr(1) % attLists(1))
      allocate(r4Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r4Ptr(1) % attLists(1) % attList, 'units', 's^{-1}')
      call mpas_add_att(r4Ptr(1) % attLists(1) % attList, 'long_name', 'Gradient of velocity field')
      r4Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r4Ptr(1) % block => block

      r4Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'velocityGradient', r4Ptr)
      call mpas_pool_add_field(block % allFields, 'velocityGradient', r4Ptr)

! Define variable shearAndStrain
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'shearAndStrain'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 's^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Shear and strain')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'shearAndStrain', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'shearAndStrain', r2Ptr)

! Define variable lambda1
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'lambda1'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 's^{-2}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Lambda 1, first eigenvalue of 2d strain rate tensor')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'lambda1', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'lambda1', r2Ptr)

! Define variable lambda2
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'lambda2'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 's^{-2}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Lambda 2, second eigenvalue of 2d strain rate tensor')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'lambda2', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'lambda2', r2Ptr)

! Define variable lambda2R3
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'lambda2R3'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .false.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 's^{-2}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Lambda 2, second eigenvalue of full 3d strain rate tensor')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'lambda2R3', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'lambda2R3', r2Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_pool_okuboWeissScratch


   subroutine ocn_generate_pool_okuboWeissAM(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'okuboWeissAM', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'okuboWeissAM', newSubPool)

! Define variable okuboWeiss
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'okuboWeiss'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 's^{-2}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'The Okubo-Weiss value')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (okuboWeissAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'okuboWeiss', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'okuboWeiss', r2Ptr)

! Define variable eddyID
      allocate(i2Ptr(1))

! Setting up time level 1
      i2Ptr(1) % fieldName = 'eddyID'
      i2Ptr(1) % isVarArray = .false.
      i2Ptr(1) % isDecomposed = .true.
      i2Ptr(1) % hasTimeDimension = .true.
      i2Ptr(1) % isPersistent = .true.
      i2Ptr(1) % isActive = .false.
! Setting up dimensions
      i2Ptr(1) % dimNames(1) = 'nVertLevels'
      i2Ptr(1) % dimNames(2) = 'nCells'
      i2Ptr(1) % defaultValue = 0
      allocate(i2Ptr(1) % attLists(1))
      allocate(i2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'units', 'none')
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'long_name', 'ID of eddy connected component')
      i2Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i2Ptr(1) % block => block

      if (okuboWeissAMPKGActive) then
         i2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'eddyID', i2Ptr)
      call mpas_pool_add_field(block % allFields, 'eddyID', i2Ptr)

! Define variable vorticity
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'vorticity'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 's^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Vorticity')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (okuboWeissAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'vorticity', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'vorticity', r2Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_pool_okuboWeissAM


   subroutine ocn_generate_pool_meridionalHeatTransportAM(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'meridionalHeatTransportAM', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'meridionalHeatTransportAM', newSubPool)

! Define variable binBoundaryMerHeatTrans
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'binBoundaryMerHeatTrans'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .false.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nMerHeatTransBinsP1'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'varies')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Coordinate of southern edge of meridional heat transport '&
//'bin, either in latitude or y, for plotting.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (meridionalHeatTransportAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'binBoundaryMerHeatTrans', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'binBoundaryMerHeatTrans', r1Ptr)

! Define variable meridionalHeatTransportLatZ
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'meridionalHeatTransportLatZ'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .false.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nMerHeatTransBinsP1'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'petawatts')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Northward heat transport at locations defined at the '&
//'binBoundaryMerHeatTrans coordinates by vertical level.')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (meridionalHeatTransportAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'meridionalHeatTransportLatZ', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'meridionalHeatTransportLatZ', r2Ptr)

! Define variable merHeatTransLatZRegion
      allocate(r3Ptr(1))

! Setting up time level 1
      r3Ptr(1) % fieldName = 'merHeatTransLatZRegion'
      r3Ptr(1) % isVarArray = .false.
      r3Ptr(1) % isDecomposed = .false.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.
! Setting up dimensions
      r3Ptr(1) % dimNames(1) = 'nVertLevels'
      r3Ptr(1) % dimNames(2) = 'nMerHeatTransBinsP1'
      r3Ptr(1) % dimNames(3) = 'maxRegionsInGroup'
      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(1))
      allocate(r3Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'units', 'petawatts')
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'long_name', 'Northward heat transport by vertical level and region.')
      r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r3Ptr(1) % block => block

      if (meridionalHeatTransportAMPKGActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'merHeatTransLatZRegion', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'merHeatTransLatZRegion', r3Ptr)

! Define variable meridionalHeatTransportLat
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'meridionalHeatTransportLat'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .false.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nMerHeatTransBinsP1'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'petawatts')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Northward heat transport at locations defined at the '&
//'binBoundaryMerHeatTrans coordinates.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (meridionalHeatTransportAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'meridionalHeatTransportLat', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'meridionalHeatTransportLat', r1Ptr)

! Define variable merHeatTransLatRegion
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'merHeatTransLatRegion'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .false.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nMerHeatTransBinsP1'
      r2Ptr(1) % dimNames(2) = 'maxRegionsInGroup'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'petawatts')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Northward heat transport at locations defined at the '&
//'binBoundaryMerHeatTrans coordinates, by region.')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (meridionalHeatTransportAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'merHeatTransLatRegion', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'merHeatTransLatRegion', r2Ptr)

! Define variable minMaxLatRegionMHT
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'minMaxLatRegionMHT'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .false.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'TWO'
      r2Ptr(1) % dimNames(2) = 'maxRegionsInGroup'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'varies')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Coordinates of the southern and northern edge of each '&
//'region (for drawing).')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (meridionalHeatTransportAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'minMaxLatRegionMHT', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'minMaxLatRegionMHT', r2Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_pool_meridionalHeatTransportAM


   subroutine ocn_generate_pool_testComputeIntervalAM(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'testComputeIntervalAM', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'testComputeIntervalAM', newSubPool)

! Define variable testComputeIntervalCounter
      allocate(r0Ptr(1))

! Setting up time level 1
      r0Ptr(1) % fieldName = 'testComputeIntervalCounter'
      r0Ptr(1) % isVarArray = .false.
      r0Ptr(1) % isDecomposed = .false.
      r0Ptr(1) % hasTimeDimension = .true.
      r0Ptr(1) % defaultValue = 0.0
      r0Ptr(1) % scalar = 0.0
      allocate(r0Ptr(1) % attLists(1))
      allocate(r0Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r0Ptr(1) % attLists(1) % attList, 'units', 'none')
      call mpas_add_att(r0Ptr(1) % attLists(1) % attList, 'long_name', 'number of times test_compute_interval has been called')
      r0Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r0Ptr(1) % block => block

      if (testComputeIntervalAMPKGActive) then
         r0Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'testComputeIntervalCounter', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'testComputeIntervalCounter', r0Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_pool_testComputeIntervalAM


   subroutine ocn_generate_pool_highFrequencyOutputAM(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'highFrequencyOutputAM', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'highFrequencyOutputAM', newSubPool)

! Define var array activeTracersAtSurface
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group activeTracersAtSurface
! Define constituent var temperatureAtSurface
! My Packages are highFrequencyOutputAMPKG
      if (highFrequencyOutputAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureAtSurface', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracersAtSurface_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_temperatureAtSurface', -1)
           end if
      end if
! Define constituent var salinityAtSurface
! My packages are highFrequencyOutputAMPKG
      if (highFrequencyOutputAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityAtSurface', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracersAtSurface_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityAtSurface', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracersAtSurface_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'activeTracersAtSurface_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracersAtSurface_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_activeTracersAtSurface', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'activeTracersAtSurface'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureAtSurface', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'temperatureAtSurface'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityAtSurface', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'salinityAtSurface'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_activeTracersAtSurface'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureAtSurface', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'ocean temperature at top layer')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', '^\circ C')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'temperatureAtSurface'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityAtSurface', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'salinity at top layer')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'PSU')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'salinityAtSurface'
      end if
      r2Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'activeTracersAtSurface', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'activeTracersAtSurface', r2Ptr)

! Define var array activeTracersAt250m
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group activeTracersAt250m
! Define constituent var temperatureAt250m
! My Packages are highFrequencyOutputAMPKG
      if (highFrequencyOutputAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureAt250m', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracersAt250m_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_temperatureAt250m', -1)
           end if
      end if
! Define constituent var salinityAt250m
! My packages are highFrequencyOutputAMPKG
      if (highFrequencyOutputAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityAt250m', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracersAt250m_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityAt250m', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracersAt250m_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'activeTracersAt250m_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracersAt250m_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_activeTracersAt250m', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'activeTracersAt250m'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureAt250m', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'temperatureAt250m'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityAt250m', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'salinityAt250m'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_activeTracersAt250m'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureAt250m', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'ocean temperature at 250 m')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', '^\circ C')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'temperatureAt250m'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityAt250m', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'salinity at 250 m')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'PSU')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'salinityAt250m'
      end if
      r2Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'activeTracersAt250m', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'activeTracersAt250m', r2Ptr)

! Define var array activeTracersAtBottom
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group activeTracersAtBottom
! Define constituent var temperatureAtBottom
! My Packages are highFrequencyOutputAMPKG
      if (highFrequencyOutputAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureAtBottom', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracersAtBottom_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_temperatureAtBottom', -1)
           end if
      end if
! Define constituent var salinityAtBottom
! My packages are highFrequencyOutputAMPKG
      if (highFrequencyOutputAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityAtBottom', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracersAtBottom_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityAtBottom', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracersAtBottom_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'activeTracersAtBottom_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracersAtBottom_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_activeTracersAtBottom', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'activeTracersAtBottom'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureAtBottom', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'temperatureAtBottom'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityAtBottom', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'salinityAtBottom'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_activeTracersAtBottom'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureAtBottom', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'ocean temperature at bottom')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', '^\circ C')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'temperatureAtBottom'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityAtBottom', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'salinity at bottom')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'PSU')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'salinityAtBottom'
      end if
      r2Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'activeTracersAtBottom', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'activeTracersAtBottom', r2Ptr)

! Define var array activeTracersAvgTopto0100
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group activeTracersAvgTopto0100
! Define constituent var temperatureAvgTopto0100
! My Packages are highFrequencyOutputAMPKG
      if (highFrequencyOutputAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureAvgTopto0100', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracersAvgTopto0100_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_temperatureAvgTopto0100', -1)
           end if
      end if
! Define constituent var salinityAvgTopto0100
! My packages are highFrequencyOutputAMPKG
      if (highFrequencyOutputAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityAvgTopto0100', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracersAvgTopto0100_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityAvgTopto0100', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracersAvgTopto0100_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'activeTracersAvgTopto0100_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracersAvgTopto0100_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_activeTracersAvgTopto0100', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'activeTracersAvgTopto0100'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureAvgTopto0100', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'temperatureAvgTopto0100'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityAvgTopto0100', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'salinityAvgTopto0100'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_activeTracersAvgTopto0100'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureAvgTopto0100', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'ocean temperature averaged between surface '&
//'and 100 m')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', '^\circ C')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'temperatureAvgTopto0100'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityAvgTopto0100', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'salinity averaged between surface and 100 m')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'PSU')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'salinityAvgTopto0100'
      end if
      r2Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'activeTracersAvgTopto0100', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'activeTracersAvgTopto0100', r2Ptr)

! Define var array activeTracersAvg0100to0250
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group activeTracersAvg0100to0250
! Define constituent var temperatureAvg0100to0250
! My Packages are highFrequencyOutputAMPKG
      if (highFrequencyOutputAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureAvg0100to0250', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracersAvg0100to0250_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_temperatureAvg0100to0250', -1)
           end if
      end if
! Define constituent var salinityAvg0100to0250
! My packages are highFrequencyOutputAMPKG
      if (highFrequencyOutputAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityAvg0100to0250', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracersAvg0100to0250_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityAvg0100to0250', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracersAvg0100to0250_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'activeTracersAvg0100to0250_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracersAvg0100to0250_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_activeTracersAvg0100to0250', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'activeTracersAvg0100to0250'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureAvg0100to0250', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'temperatureAvg0100to0250'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityAvg0100to0250', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'salinityAvg0100to0250'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_activeTracersAvg0100to0250'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureAvg0100to0250', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'ocean temperature averaged between surface '&
//'and 100 m')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', '^\circ C')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'temperatureAvg0100to0250'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityAvg0100to0250', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'salinity averaged between surface and 100 m')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'PSU')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'salinityAvg0100to0250'
      end if
      r2Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'activeTracersAvg0100to0250', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'activeTracersAvg0100to0250', r2Ptr)

! Define var array activeTracersAvg0250to0700
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group activeTracersAvg0250to0700
! Define constituent var temperatureAvg0250to0700
! My Packages are highFrequencyOutputAMPKG
      if (highFrequencyOutputAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureAvg0250to0700', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracersAvg0250to0700_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_temperatureAvg0250to0700', -1)
           end if
      end if
! Define constituent var salinityAvg0250to0700
! My packages are highFrequencyOutputAMPKG
      if (highFrequencyOutputAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityAvg0250to0700', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracersAvg0250to0700_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityAvg0250to0700', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracersAvg0250to0700_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'activeTracersAvg0250to0700_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracersAvg0250to0700_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_activeTracersAvg0250to0700', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'activeTracersAvg0250to0700'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureAvg0250to0700', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'temperatureAvg0250to0700'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityAvg0250to0700', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'salinityAvg0250to0700'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_activeTracersAvg0250to0700'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureAvg0250to0700', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'ocean temperature averaged between surface '&
//'and 100 m')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', '^\circ C')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'temperatureAvg0250to0700'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityAvg0250to0700', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'salinity averaged between surface and 100 m')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'PSU')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'salinityAvg0250to0700'
      end if
      r2Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'activeTracersAvg0250to0700', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'activeTracersAvg0250to0700', r2Ptr)

! Define var array activeTracersAvg0700to2000
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group activeTracersAvg0700to2000
! Define constituent var temperatureAvg0700to2000
! My Packages are highFrequencyOutputAMPKG
      if (highFrequencyOutputAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureAvg0700to2000', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracersAvg0700to2000_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_temperatureAvg0700to2000', -1)
           end if
      end if
! Define constituent var salinityAvg0700to2000
! My packages are highFrequencyOutputAMPKG
      if (highFrequencyOutputAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityAvg0700to2000', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracersAvg0700to2000_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityAvg0700to2000', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracersAvg0700to2000_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'activeTracersAvg0700to2000_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracersAvg0700to2000_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_activeTracersAvg0700to2000', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'activeTracersAvg0700to2000'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureAvg0700to2000', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'temperatureAvg0700to2000'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityAvg0700to2000', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'salinityAvg0700to2000'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_activeTracersAvg0700to2000'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureAvg0700to2000', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'ocean temperature averaged between surface '&
//'and 100 m')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', '^\circ C')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'temperatureAvg0700to2000'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityAvg0700to2000', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'salinity averaged between surface and 100 m')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'PSU')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'salinityAvg0700to2000'
      end if
      r2Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'activeTracersAvg0700to2000', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'activeTracersAvg0700to2000', r2Ptr)

! Define var array activeTracersAvg2000toBottom
      allocate(r2Ptr(1))
      index_counter = 0
      group_counter = -1
      group_start = -1
      group_started = .false.

! Starting group activeTracersAvg2000toBottom
! Define constituent var temperatureAvg2000toBottom
! My Packages are highFrequencyOutputAMPKG
      if (highFrequencyOutputAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_temperatureAvg2000toBottom', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracersAvg2000toBottom_start', group_start)
            end if
            group_started = .true.
         end if
      else
           if (associated(newSubPool)) then
              call mpas_pool_add_dimension(newSubPool, 'index_temperatureAvg2000toBottom', -1)
           end if
      end if
! Define constituent var salinityAvg2000toBottom
! My packages are highFrequencyOutputAMPKG
      if (highFrequencyOutputAMPKGActive) then
         index_counter = index_counter + 1
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityAvg2000toBottom', index_counter)
         end if
         group_counter = group_counter + 1
         if (.not. group_started) then
            group_start = index_counter
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracersAvg2000toBottom_start', group_start)
            end if
            group_started = .true.
         end if
      else
         if (associated(newSubPool)) then
            call mpas_pool_add_dimension(newSubPool, 'index_salinityAvg2000toBottom', -1)
         end if
      end if
         if (.not. group_started) then
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracersAvg2000toBottom_start', -1)
               call mpas_pool_add_dimension(newSubPool, 'activeTracersAvg2000toBottom_end', -1)
            end if
         else
            group_started = .false.
            if (associated(newSubPool)) then
               call mpas_pool_add_dimension(newSubPool, 'activeTracersAvg2000toBottom_end', index_counter)
            end if
         end if
! End of group       

      numConstituents = index_counter
      if (associated(newSubPool)) then
         call mpas_pool_add_dimension(newSubPool, 'num_activeTracersAvg2000toBottom', numConstituents)
      end if
! Defining time level 1
      allocate( r2Ptr(1) % constituentNames(numConstituents) )
      r2Ptr(1) % fieldName = 'activeTracersAvg2000toBottom'
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isVarArray = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.

      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureAvg2000toBottom', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'temperatureAvg2000toBottom'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityAvg2000toBottom', const_index)
      end if
      if (const_index > 0) then
         r2Ptr(1) % constituentNames(const_index) = 'salinityAvg2000toBottom'
      end if

! Setup dimensions for       
      r2Ptr(1) % dimNames(1) = 'num_activeTracersAvg2000toBottom'
      r2Ptr(1) % dimNames(2) = 'nCells'

      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(size(r2Ptr(1) % constituentNames, dim=1)))
      do index_counter = 1, size(r2Ptr(1) % constituentNames, dim=1)
         allocate(r2Ptr(1) % attLists(index_counter) % attList)
      end do
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_temperatureAvg2000toBottom', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'ocean temperature averaged between surface '&
//'and 100 m')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', '^\circ C')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'temperatureAvg2000toBottom'
      end if
      if (associated(newSubPool)) then
         call mpas_pool_get_dimension(newSubPool, 'index_salinityAvg2000toBottom', const_index)
      end if
      if (const_index > 0) then
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'long_name', 'salinity averaged between surface and 100 m')
         call mpas_add_att(r2Ptr(1) % attLists(const_index) % attList, 'units', 'PSU')
         r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
         r2Ptr(1) % constituentNames(const_index) = 'salinityAvg2000toBottom'
      end if
      r2Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'activeTracersAvg2000toBottom', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'activeTracersAvg2000toBottom', r2Ptr)

! Define variable kineticEnergyAtSurface
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'kineticEnergyAtSurface'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm^2 s^{-2}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'kinetic energy at surface')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'kineticEnergyAtSurface', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'kineticEnergyAtSurface', r1Ptr)

! Define variable vertGMvelocitySFC
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'vertGMvelocitySFC'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'vertical velocity due to GM parameterization')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'vertGMvelocitySFC', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'vertGMvelocitySFC', r1Ptr)

! Define variable vertTransportVelocitySFC
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'vertTransportVelocitySFC'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'vertical velocity due to normal transport velocity '&
//'divergence')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'vertTransportVelocitySFC', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'vertTransportVelocitySFC', r1Ptr)

! Define variable vertVelSFC
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'vertVelSFC'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'vertical velocity due to normal velocity divergence')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'vertVelSFC', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'vertVelSFC', r1Ptr)

! Define variable vertGMvelocityAt250m
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'vertGMvelocityAt250m'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'vertical velocity due to GM parameterization at '&
//'approximately 250m')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'vertGMvelocityAt250m', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'vertGMvelocityAt250m', r1Ptr)

! Define variable vertTransportVelocityAt250m
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'vertTransportVelocityAt250m'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'vertical velocity due to normal transport velocity '&
//'divergence at approximately 250m')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'vertTransportVelocityAt250m', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'vertTransportVelocityAt250m', r1Ptr)

! Define variable vertVelAt250m
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'vertVelAt250m'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'vertical velocity due to normal velocity divergence at '&
//'approximately 250m')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'vertVelAt250m', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'vertVelAt250m', r1Ptr)

! Define variable normalVelAtSFC
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'normalVelAtSFC'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'normal velocity at surface')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'normalVelAtSFC', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'normalVelAtSFC', r1Ptr)

! Define variable normalVelAt250m
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'normalVelAt250m'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'normal velocity at approximately 250m')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'normalVelAt250m', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'normalVelAt250m', r1Ptr)

! Define variable normalVelAtBottom
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'normalVelAtBottom'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'normal velocity at approximately Bottom')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'normalVelAtBottom', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'normalVelAtBottom', r1Ptr)

! Define variable tangentialVelAtSFC
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'tangentialVelAtSFC'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'tangential velocity at surface')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'tangentialVelAtSFC', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'tangentialVelAtSFC', r1Ptr)

! Define variable tangentialVelAt250m
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'tangentialVelAt250m'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'tangential velocity at approximately 250m')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'tangentialVelAt250m', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'tangentialVelAt250m', r1Ptr)

! Define variable tangentialVelAtBottom
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'tangentialVelAtBottom'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'tangential velocity at approximately Bottom')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'tangentialVelAtBottom', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'tangentialVelAtBottom', r1Ptr)

! Define variable zonalVelAtSFC
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'zonalVelAtSFC'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'zonal velocity at surface')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'zonalVelAtSFC', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'zonalVelAtSFC', r1Ptr)

! Define variable zonalVelAt250m
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'zonalVelAt250m'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'zonal velocity at approximately 250m')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'zonalVelAt250m', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'zonalVelAt250m', r1Ptr)

! Define variable zonalVelAtBottom
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'zonalVelAtBottom'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'zonal velocity at approximately Bottom')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'zonalVelAtBottom', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'zonalVelAtBottom', r1Ptr)

! Define variable zonalAreaWeightedCellVelAtSFC
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'zonalAreaWeightedCellVelAtSFC'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'area-weighted cell zonal velocity at surface')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'zonalAreaWeightedCellVelAtSFC', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'zonalAreaWeightedCellVelAtSFC', r1Ptr)

! Define variable zonalAreaWeightedCellVelAt250m
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'zonalAreaWeightedCellVelAt250m'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'area-weighted cell zonal velocity at approximately 250m')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'zonalAreaWeightedCellVelAt250m', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'zonalAreaWeightedCellVelAt250m', r1Ptr)

! Define variable zonalAreaWeightedCellVelAtBottom
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'zonalAreaWeightedCellVelAtBottom'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'area-weighted cell zonal velocity at approximately Bottom')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'zonalAreaWeightedCellVelAtBottom', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'zonalAreaWeightedCellVelAtBottom', r1Ptr)

! Define variable meridionalVelAtSFC
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'meridionalVelAtSFC'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'meridional velocity at surface')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'meridionalVelAtSFC', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'meridionalVelAtSFC', r1Ptr)

! Define variable meridionalVelAt250m
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'meridionalVelAt250m'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'meridional velocity at approximately 250m')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'meridionalVelAt250m', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'meridionalVelAt250m', r1Ptr)

! Define variable meridionalVelAtBottom
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'meridionalVelAtBottom'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'meridional velocity at approximately Bottom')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'meridionalVelAtBottom', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'meridionalVelAtBottom', r1Ptr)

! Define variable meridionalAreaWeightedCellVelAtSFC
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'meridionalAreaWeightedCellVelAtSFC'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'area-weighted cell meridional velocity at surface')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'meridionalAreaWeightedCellVelAtSFC', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'meridionalAreaWeightedCellVelAtSFC', r1Ptr)

! Define variable meridionalAreaWeightedCellVelAt250m
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'meridionalAreaWeightedCellVelAt250m'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'area-weighted cell meridional velocity at approximately '&
//'250m')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'meridionalAreaWeightedCellVelAt250m', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'meridionalAreaWeightedCellVelAt250m', r1Ptr)

! Define variable meridionalAreaWeightedCellVelAtBottom
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'meridionalAreaWeightedCellVelAtBottom'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'area-weighted cell meridional velocity at approximately '&
//'Bottom')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'meridionalAreaWeightedCellVelAtBottom', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'meridionalAreaWeightedCellVelAtBottom', r1Ptr)

! Define variable normalBarotropicVel
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'normalBarotropicVel'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'normal barotropic velocity')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'normalBarotropicVel', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'normalBarotropicVel', r1Ptr)

! Define variable tangentialBarotropicVel
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'tangentialBarotropicVel'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'tangential barotropic velocity')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'tangentialBarotropicVel', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'tangentialBarotropicVel', r1Ptr)

! Define variable zonalBarotropicVel
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'zonalBarotropicVel'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'zonal barotropic velocity')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'zonalBarotropicVel', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'zonalBarotropicVel', r1Ptr)

! Define variable meridionalBarotropicVel
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'meridionalBarotropicVel'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'meridional barotropic velocity')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'meridionalBarotropicVel', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'meridionalBarotropicVel', r1Ptr)

! Define variable normalBaroclinicVelAtSFC
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'normalBaroclinicVelAtSFC'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'normal baroclinic velocity at surface')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'normalBaroclinicVelAtSFC', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'normalBaroclinicVelAtSFC', r1Ptr)

! Define variable normalBaroclinicVelAt250m
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'normalBaroclinicVelAt250m'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'normal baroclinic velocity at 250m')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'normalBaroclinicVelAt250m', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'normalBaroclinicVelAt250m', r1Ptr)

! Define variable normalBaroclinicVelAtBottom
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'normalBaroclinicVelAtBottom'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'normal baroclinic velocity at bottom')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'normalBaroclinicVelAtBottom', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'normalBaroclinicVelAtBottom', r1Ptr)

! Define variable tangentialBaroclinicVelAtSFC
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'tangentialBaroclinicVelAtSFC'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'tangential baroclinic velocity at surface')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'tangentialBaroclinicVelAtSFC', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'tangentialBaroclinicVelAtSFC', r1Ptr)

! Define variable tangentialBaroclinicVelAt250m
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'tangentialBaroclinicVelAt250m'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'tangential baroclinic velocity at 250m')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'tangentialBaroclinicVelAt250m', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'tangentialBaroclinicVelAt250m', r1Ptr)

! Define variable tangentialBaroclinicVelAtBottom
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'tangentialBaroclinicVelAtBottom'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'tangential baroclinic velocity at bottom')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'tangentialBaroclinicVelAtBottom', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'tangentialBaroclinicVelAtBottom', r1Ptr)

! Define variable zonalBaroclinicVelAtSFC
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'zonalBaroclinicVelAtSFC'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'zonal baroclinic velocity at surface')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'zonalBaroclinicVelAtSFC', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'zonalBaroclinicVelAtSFC', r1Ptr)

! Define variable zonalBaroclinicVelAt250m
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'zonalBaroclinicVelAt250m'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'zonal baroclinic velocity at 250m')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'zonalBaroclinicVelAt250m', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'zonalBaroclinicVelAt250m', r1Ptr)

! Define variable zonalBaroclinicVelAtBottom
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'zonalBaroclinicVelAtBottom'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'zonal baroclinic velocity at bottom')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'zonalBaroclinicVelAtBottom', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'zonalBaroclinicVelAtBottom', r1Ptr)

! Define variable meridionalBaroclinicVelAtSFC
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'meridionalBaroclinicVelAtSFC'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'meridional baroclinic velocity at surface')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'meridionalBaroclinicVelAtSFC', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'meridionalBaroclinicVelAtSFC', r1Ptr)

! Define variable meridionalBaroclinicVelAt250m
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'meridionalBaroclinicVelAt250m'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'meridional baroclinic velocity at 250m')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'meridionalBaroclinicVelAt250m', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'meridionalBaroclinicVelAt250m', r1Ptr)

! Define variable meridionalBaroclinicVelAtBottom
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'meridionalBaroclinicVelAtBottom'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'meridional baroclinic velocity at bottom')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'meridionalBaroclinicVelAtBottom', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'meridionalBaroclinicVelAtBottom', r1Ptr)

! Define variable normalGMBolusVelAtSFC
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'normalGMBolusVelAtSFC'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'normal Bolus velocity in Gent-McWilliams eddy '&
//'parameterization at the surface')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'normalGMBolusVelAtSFC', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'normalGMBolusVelAtSFC', r1Ptr)

! Define variable normalGMBolusVelAt250m
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'normalGMBolusVelAt250m'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'normal Bolus velocity in Gent-McWilliams eddy '&
//'parameterization at 250m')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'normalGMBolusVelAt250m', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'normalGMBolusVelAt250m', r1Ptr)

! Define variable normalGMBolusVelAtBottom
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'normalGMBolusVelAtBottom'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'normal Bolus velocity in Gent-McWilliams eddy '&
//'parameterization at the bottom')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'normalGMBolusVelAtBottom', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'normalGMBolusVelAtBottom', r1Ptr)

! Define variable tangentialGMBolusVelAtSFC
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'tangentialGMBolusVelAtSFC'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'tangential Bolus velocity in Gent-McWilliams eddy '&
//'parameterization at the surface')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'tangentialGMBolusVelAtSFC', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'tangentialGMBolusVelAtSFC', r1Ptr)

! Define variable tangentialGMBolusVelAt250m
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'tangentialGMBolusVelAt250m'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'tangential Bolus velocity in Gent-McWilliams eddy '&
//'parameterization at 250m')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'tangentialGMBolusVelAt250m', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'tangentialGMBolusVelAt250m', r1Ptr)

! Define variable tangentialGMBolusVelAtBottom
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'tangentialGMBolusVelAtBottom'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'tangential Bolus velocity in Gent-McWilliams eddy '&
//'parameterization at the bottom')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'tangentialGMBolusVelAtBottom', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'tangentialGMBolusVelAtBottom', r1Ptr)

! Define variable zonalGMBolusVelAtSFC
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'zonalGMBolusVelAtSFC'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'zonal Bolus velocity in Gent-McWilliams eddy '&
//'parameterization at the surface')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'zonalGMBolusVelAtSFC', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'zonalGMBolusVelAtSFC', r1Ptr)

! Define variable zonalGMBolusVelAt250m
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'zonalGMBolusVelAt250m'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'zonal Bolus velocity in Gent-McWilliams eddy '&
//'parameterization at 250m')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'zonalGMBolusVelAt250m', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'zonalGMBolusVelAt250m', r1Ptr)

! Define variable zonalGMBolusVelAtBottom
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'zonalGMBolusVelAtBottom'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'zonal Bolus velocity in Gent-McWilliams eddy '&
//'parameterization at the bottom')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'zonalGMBolusVelAtBottom', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'zonalGMBolusVelAtBottom', r1Ptr)

! Define variable meridionalGMBolusVelAtSFC
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'meridionalGMBolusVelAtSFC'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'meridional Bolus velocity in Gent-McWilliams eddy '&
//'parameterization at the surface')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'meridionalGMBolusVelAtSFC', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'meridionalGMBolusVelAtSFC', r1Ptr)

! Define variable meridionalGMBolusVelAt250m
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'meridionalGMBolusVelAt250m'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'meridional Bolus velocity in Gent-McWilliams eddy '&
//'parameterization at 250m')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'meridionalGMBolusVelAt250m', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'meridionalGMBolusVelAt250m', r1Ptr)

! Define variable meridionalGMBolusVelAtBottom
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'meridionalGMBolusVelAtBottom'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nEdges'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'meridional Bolus velocity in Gent-McWilliams eddy '&
//'parameterization at the bottom')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'meridionalGMBolusVelAtBottom', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'meridionalGMBolusVelAtBottom', r1Ptr)

! Define variable BruntVaisalaFreqTopAtSFC
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'BruntVaisalaFreqTopAtSFC'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Brunt Vaisala Frequency at surface')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'BruntVaisalaFreqTopAtSFC', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'BruntVaisalaFreqTopAtSFC', r1Ptr)

! Define variable BruntVaisalaFreqTopAt250m
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'BruntVaisalaFreqTopAt250m'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Brunt Vaisala Frequency at approximately 250m')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'BruntVaisalaFreqTopAt250m', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'BruntVaisalaFreqTopAt250m', r1Ptr)

! Define variable BruntVaisalaFreqTopAtBottom
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'BruntVaisalaFreqTopAtBottom'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Brunt Vaisala Frequency at approximately Bottom')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'BruntVaisalaFreqTopAtBottom', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'BruntVaisalaFreqTopAtBottom', r1Ptr)

! Define variable kineticEnergyAt250m
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'kineticEnergyAt250m'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm^2 s^{-2}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'kinetic energy at a depth of approximately 250 m')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'kineticEnergyAt250m', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'kineticEnergyAt250m', r1Ptr)

! Define variable barotropicSpeed
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'barotropicSpeed'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'speed = sqrt(2*ke), where kinetic energy is computed from '&
//'barotropic velocity = sum(h*u)/sum(h) over the full depth of an edge')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'barotropicSpeed', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'barotropicSpeed', r1Ptr)

! Define variable columnIntegratedSpeed
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'columnIntegratedSpeed'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm^2 s^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'speed = sum(h*sqrt(2*ke)), where ke is kineticEnergyCell '&
//'and the sum is over the full column at cell centers.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'columnIntegratedSpeed', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'columnIntegratedSpeed', r1Ptr)

! Define variable relativeVorticityAt250m
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'relativeVorticityAt250m'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 's^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'relative vorticity at cell centers at a depth of '&
//'approximately 250 m')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'relativeVorticityAt250m', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'relativeVorticityAt250m', r1Ptr)

! Define variable divergenceAt250m
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'divergenceAt250m'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 's^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'divergence at cell centers at a depth of approximately 250 '&
//'m')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'divergenceAt250m', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'divergenceAt250m', r1Ptr)

! Define variable divergenceTransportVelAt250m
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'divergenceTransportVelAt250m'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 's^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'divergence of transport velocity at cell centers at a '&
//'depth of approximately 250 m')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'divergenceTransportVelAt250m', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'divergenceTransportVelAt250m', r1Ptr)

! Define variable relativeVorticityVertexAt250m
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'relativeVorticityVertexAt250m'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nVertices'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 's^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'relative vorticity at cell vertices at a depth of '&
//'approximately 250 m')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'relativeVorticityVertexAt250m', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'relativeVorticityVertexAt250m', r1Ptr)

! Define variable kineticEnergyAtBottom
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'kineticEnergyAtBottom'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm^2 s^{-2}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'kinetic energy at cell centers at bottom')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'kineticEnergyAtBottom', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'kineticEnergyAtBottom', r1Ptr)

! Define variable relativeVorticityAtBottom
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'relativeVorticityAtBottom'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 's^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'relative vorticity at cell centers at bottom')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'relativeVorticityAtBottom', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'relativeVorticityAtBottom', r1Ptr)

! Define variable divergenceAtBottom
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'divergenceAtBottom'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 's^{-1}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'divergence at cell centers at bottom')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (highFrequencyOutputAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'divergenceAtBottom', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'divergenceAtBottom', r1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_pool_highFrequencyOutputAM


   subroutine ocn_generate_pool_timeFiltersAM(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'timeFiltersAM', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'timeFiltersAM', newSubPool)

! Define variable normalVelocityLowPass
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'normalVelocityLowPass'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nEdges'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Low-pass filtered normal velocity.')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (timeFiltersAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'normalVelocityLowPass', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'normalVelocityLowPass', r2Ptr)

! Define variable normalVelocityHighPass
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'normalVelocityHighPass'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nEdges'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'High-pass filtered normal velocity.')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (timeFiltersAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'normalVelocityHighPass', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'normalVelocityHighPass', r2Ptr)

! Define variable normalVelocityFilterTest
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'normalVelocityFilterTest'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nEdges'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'normalVelocityTest (for testing purposes).')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (timeFiltersAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'normalVelocityFilterTest', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'normalVelocityFilterTest', r2Ptr)

! Define variable velocityZonalLowPass
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'velocityZonalLowPass'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Low-pass time filtered component of horizontal velocity in '&
//'the eastward direction')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (timeFiltersAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'velocityZonalLowPass', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'velocityZonalLowPass', r2Ptr)

! Define variable velocityMeridionalLowPass
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'velocityMeridionalLowPass'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Low-pass time filtered component of horizontal velocity in '&
//'the northward direction')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (timeFiltersAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'velocityMeridionalLowPass', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'velocityMeridionalLowPass', r2Ptr)

! Define variable velocityZonalHighPass
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'velocityZonalHighPass'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'High-pass time filtered component of horizontal velocity '&
//'in the eastward direction')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (timeFiltersAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'velocityZonalHighPass', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'velocityZonalHighPass', r2Ptr)

! Define variable velocityMeridionalHighPass
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'velocityMeridionalHighPass'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'High-pass time filtered component of horizontal velocity '&
//'in the northward direction')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (timeFiltersAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'velocityMeridionalHighPass', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'velocityMeridionalHighPass', r2Ptr)

! Define variable velocityXLowPass
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'velocityXLowPass'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Low-pass time filtered component of horizontal velocity in '&
//'the x-direction (cartesian)')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'velocityXLowPass', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'velocityXLowPass', r2Ptr)

! Define variable velocityYLowPass
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'velocityYLowPass'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Low-pass time filtered component of horizontal velocity in '&
//'the x-direction (cartesian)')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'velocityYLowPass', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'velocityYLowPass', r2Ptr)

! Define variable velocityZLowPass
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'velocityZLowPass'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Low-pass time filtered component of horizontal velocity in '&
//'the x-direction (cartesian)')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'velocityZLowPass', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'velocityZLowPass', r2Ptr)

! Define variable velocityXHighPass
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'velocityXHighPass'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'High-pass time filtered component of horizontal velocity '&
//'in the x-direction (cartesian)')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'velocityXHighPass', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'velocityXHighPass', r2Ptr)

! Define variable velocityYHighPass
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'velocityYHighPass'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'High-pass time filtered component of horizontal velocity '&
//'in the x-direction (cartesian)')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'velocityYHighPass', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'velocityYHighPass', r2Ptr)

! Define variable velocityZHighPass
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'velocityZHighPass'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'High-pass time filtered component of horizontal velocity '&
//'in the x-direction (cartesian)')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'velocityZHighPass', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'velocityZHighPass', r2Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_pool_timeFiltersAM


   subroutine ocn_generate_pool_lagrPartTrackRegions(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'lagrPartTrackRegions', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'lagrPartTrackRegions', newSubPool)

! Define variable resetOutsideRegionMaskValue1
      allocate(i1Ptr(1))

! Setting up time level 1
      i1Ptr(1) % fieldName = 'resetOutsideRegionMaskValue1'
      i1Ptr(1) % isVarArray = .false.
      i1Ptr(1) % isDecomposed = .true.
      i1Ptr(1) % hasTimeDimension = .false.
      i1Ptr(1) % isPersistent = .true.
      i1Ptr(1) % isActive = .false.
! Setting up dimensions
      i1Ptr(1) % dimNames(1) = 'nCells'
      i1Ptr(1) % defaultValue = 0
      allocate(i1Ptr(1) % attLists(1))
      allocate(i1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'units', 'Unitless')
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'long_name', 'Mask for particle resets that leave this particular region '&
//'(specified by 1)')
      i1Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i1Ptr(1) % block => block

      if (lagrPartTrackAMPKGActive) then
         i1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'resetOutsideRegionMaskValue1', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'resetOutsideRegionMaskValue1', i1Ptr)

! Define variable resetInsideRegionMaskValue1
      allocate(i1Ptr(1))

! Setting up time level 1
      i1Ptr(1) % fieldName = 'resetInsideRegionMaskValue1'
      i1Ptr(1) % isVarArray = .false.
      i1Ptr(1) % isDecomposed = .true.
      i1Ptr(1) % hasTimeDimension = .false.
      i1Ptr(1) % isPersistent = .true.
      i1Ptr(1) % isActive = .false.
! Setting up dimensions
      i1Ptr(1) % dimNames(1) = 'nCells'
      i1Ptr(1) % defaultValue = 0
      allocate(i1Ptr(1) % attLists(1))
      allocate(i1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'units', 'Unitless')
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'long_name', 'Mask for particle resets that enter this particular region '&
//'(specified by 1)')
      i1Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i1Ptr(1) % block => block

      if (lagrPartTrackAMPKGActive) then
         i1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'resetInsideRegionMaskValue1', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'resetInsideRegionMaskValue1', i1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_pool_lagrPartTrackRegions


   subroutine ocn_generate_pool_lagrPartTrackScalars(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'lagrPartTrackScalars', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'lagrPartTrackScalars', newSubPool)

! Define variable globalResetTimeValue
      allocate(r0Ptr(1))

! Setting up time level 1
      r0Ptr(1) % fieldName = 'globalResetTimeValue'
      r0Ptr(1) % isVarArray = .false.
      r0Ptr(1) % isDecomposed = .false.
      r0Ptr(1) % hasTimeDimension = .true.
      r0Ptr(1) % defaultValue = 0.0
      r0Ptr(1) % scalar = 0.0
      allocate(r0Ptr(1) % attLists(1))
      allocate(r0Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r0Ptr(1) % attLists(1) % attList, 'units', 's')
      call mpas_add_att(r0Ptr(1) % attLists(1) % attList, 'long_name', 'Time in s for a global reset.')
      r0Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r0Ptr(1) % block => block

      if (lagrPartTrackAMPKGActive) then
         r0Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'globalResetTimeValue', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'globalResetTimeValue', r0Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_pool_lagrPartTrackScalars


   subroutine ocn_generate_pool_lagrPartTrackFields(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'lagrPartTrackFields', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'lagrPartTrackFields', newSubPool)

! Define variable uVertexVelocity
      allocate(r2Ptr(2))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'uVertexVelocity'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nVertices'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'recostructed u horizontal velocity at vertices')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

! Setting up time level 2
      r2Ptr(2) % fieldName = 'uVertexVelocity'
      r2Ptr(2) % isVarArray = .false.
      r2Ptr(2) % isDecomposed = .true.
      r2Ptr(2) % hasTimeDimension = .true.
      r2Ptr(2) % isPersistent = .true.
      r2Ptr(2) % isActive = .false.
! Setting up dimensions
      r2Ptr(2) % dimNames(1) = 'nVertLevels'
      r2Ptr(2) % dimNames(2) = 'nVertices'
      r2Ptr(2) % defaultValue = 0.0
      allocate(r2Ptr(2) % attLists(1))
      allocate(r2Ptr(2) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(2) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(2) % attLists(1) % attList, 'long_name', 'recostructed u horizontal velocity at vertices')
      r2Ptr(2) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(2) % block => block

      if (lagrPartTrackAMPKGActive) then
         r2Ptr(1) % isActive = .true.
         r2Ptr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'uVertexVelocity', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'uVertexVelocity', r2Ptr)

! Define variable vVertexVelocity
      allocate(r2Ptr(2))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'vVertexVelocity'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nVertices'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'recostructed v horizontal velocity at vertices')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

! Setting up time level 2
      r2Ptr(2) % fieldName = 'vVertexVelocity'
      r2Ptr(2) % isVarArray = .false.
      r2Ptr(2) % isDecomposed = .true.
      r2Ptr(2) % hasTimeDimension = .true.
      r2Ptr(2) % isPersistent = .true.
      r2Ptr(2) % isActive = .false.
! Setting up dimensions
      r2Ptr(2) % dimNames(1) = 'nVertLevels'
      r2Ptr(2) % dimNames(2) = 'nVertices'
      r2Ptr(2) % defaultValue = 0.0
      allocate(r2Ptr(2) % attLists(1))
      allocate(r2Ptr(2) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(2) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(2) % attLists(1) % attList, 'long_name', 'recostructed v horizontal velocity at vertices')
      r2Ptr(2) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(2) % block => block

      if (lagrPartTrackAMPKGActive) then
         r2Ptr(1) % isActive = .true.
         r2Ptr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'vVertexVelocity', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'vVertexVelocity', r2Ptr)

! Define variable wVertexVelocity
      allocate(r2Ptr(2))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'wVertexVelocity'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nVertices'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'recostructed w horizontal velocity at vertices')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

! Setting up time level 2
      r2Ptr(2) % fieldName = 'wVertexVelocity'
      r2Ptr(2) % isVarArray = .false.
      r2Ptr(2) % isDecomposed = .true.
      r2Ptr(2) % hasTimeDimension = .true.
      r2Ptr(2) % isPersistent = .true.
      r2Ptr(2) % isActive = .false.
! Setting up dimensions
      r2Ptr(2) % dimNames(1) = 'nVertLevels'
      r2Ptr(2) % dimNames(2) = 'nVertices'
      r2Ptr(2) % defaultValue = 0.0
      allocate(r2Ptr(2) % attLists(1))
      allocate(r2Ptr(2) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(2) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(2) % attLists(1) % attList, 'long_name', 'recostructed w horizontal velocity at vertices')
      r2Ptr(2) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(2) % block => block

      if (lagrPartTrackAMPKGActive) then
         r2Ptr(1) % isActive = .true.
         r2Ptr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'wVertexVelocity', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'wVertexVelocity', r2Ptr)

! Define variable buoyancy
      allocate(r2Ptr(2))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'buoyancy'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'kg m^{-3}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'buoyancy values at cell mid points, currently proxy for '&
//'density')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

! Setting up time level 2
      r2Ptr(2) % fieldName = 'buoyancy'
      r2Ptr(2) % isVarArray = .false.
      r2Ptr(2) % isDecomposed = .true.
      r2Ptr(2) % hasTimeDimension = .true.
      r2Ptr(2) % isPersistent = .true.
      r2Ptr(2) % isActive = .false.
! Setting up dimensions
      r2Ptr(2) % dimNames(1) = 'nVertLevels'
      r2Ptr(2) % dimNames(2) = 'nCells'
      r2Ptr(2) % defaultValue = 0.0
      allocate(r2Ptr(2) % attLists(1))
      allocate(r2Ptr(2) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(2) % attLists(1) % attList, 'units', 'kg m^{-3}')
      call mpas_add_att(r2Ptr(2) % attLists(1) % attList, 'long_name', 'buoyancy values at cell mid points, currently proxy for '&
//'density')
      r2Ptr(2) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(2) % block => block

      if (lagrPartTrackAMPKGActive) then
         r2Ptr(1) % isActive = .true.
         r2Ptr(2) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'buoyancy', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'buoyancy', r2Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_pool_lagrPartTrackFields


   subroutine ocn_generate_pool_lagrPartTrackCells(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'lagrPartTrackCells', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'lagrPartTrackCells', newSubPool)

! Define variable cellOwnerBlock
      allocate(i1Ptr(1))

! Setting up time level 1
      i1Ptr(1) % fieldName = 'cellOwnerBlock'
      i1Ptr(1) % isVarArray = .false.
      i1Ptr(1) % isDecomposed = .true.
      i1Ptr(1) % hasTimeDimension = .false.
      i1Ptr(1) % isPersistent = .true.
      i1Ptr(1) % isActive = .false.
! Setting up dimensions
      i1Ptr(1) % dimNames(1) = 'nCells'
      i1Ptr(1) % defaultValue = 0
      allocate(i1Ptr(1) % attLists(1))
      allocate(i1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'long_name', 'designates ownership of cell in terms of computational '&
//'block')
      i1Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i1Ptr(1) % block => block

      if (lagrPartTrackAMPKGActive) then
         i1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'cellOwnerBlock', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'cellOwnerBlock', i1Ptr)

! Define variable filteredVelocityW
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'filteredVelocityW'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'filtered u horizontal velocity at cells')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (lagrPartTrackAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'filteredVelocityW', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'filteredVelocityW', r2Ptr)

! Define variable filteredVelocityV
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'filteredVelocityV'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'filtered v horizontal velocity at cells')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (lagrPartTrackAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'filteredVelocityV', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'filteredVelocityV', r2Ptr)

! Define variable filteredVelocityU
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'filteredVelocityU'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'filtered w horizontal velocity at cells')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (lagrPartTrackAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'filteredVelocityU', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'filteredVelocityU', r2Ptr)

! Define variable buoyancySurfaceVelocityZonal
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'buoyancySurfaceVelocityZonal'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancySurfaces'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'horizontal zonal velocity on buoyancy surface')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (lagrPartTrackAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'buoyancySurfaceVelocityZonal', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'buoyancySurfaceVelocityZonal', r2Ptr)

! Define variable buoyancySurfaceVelocityMeridional
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'buoyancySurfaceVelocityMeridional'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancySurfaces'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'horizontal meridional velocity on buoyancy surface')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (lagrPartTrackAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'buoyancySurfaceVelocityMeridional', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'buoyancySurfaceVelocityMeridional', r2Ptr)

! Define variable buoyancySurfaceDepth
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'buoyancySurfaceDepth'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancySurfaces'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'depth of buoyancy surface')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (lagrPartTrackAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'buoyancySurfaceDepth', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'buoyancySurfaceDepth', r2Ptr)

! Define variable buoyancySurfaceValues
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'buoyancySurfaceValues'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .false.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nBuoyancySurfaces'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'kg m^{-3}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'definition of buoyancy surfaces in terms of potential '&
//'density')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (lagrPartTrackAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'buoyancySurfaceValues', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'buoyancySurfaceValues', r1Ptr)

! Define variable wachspressAreaB
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'wachspressAreaB'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nCells'
      r2Ptr(1) % dimNames(2) = 'maxEdges'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm^2')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'cached polygon subarea B_i used in Wachspess calculation')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (lagrPartTrackAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'wachspressAreaB', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'wachspressAreaB', r2Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_pool_lagrPartTrackCells


   subroutine ocn_generate_pool_lagrPartTrackHalo(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'lagrPartTrackHalo', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'lagrPartTrackHalo', newSubPool)

! Define variable ioBlock
      allocate(i1Ptr(1))

! Setting up time level 1
      i1Ptr(1) % fieldName = 'ioBlock'
      i1Ptr(1) % isVarArray = .false.
      i1Ptr(1) % isDecomposed = .true.
      i1Ptr(1) % hasTimeDimension = .false.
      i1Ptr(1) % isPersistent = .true.
      i1Ptr(1) % isActive = .false.
! Setting up dimensions
      i1Ptr(1) % dimNames(1) = 'nParticles'
      i1Ptr(1) % defaultValue = 0
      allocate(i1Ptr(1) % attLists(1))
      allocate(i1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'long_name', 'input / output Proc for particle')
      i1Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i1Ptr(1) % block => block

      if (lagrPartTrackAMPKGActive) then
         i1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ioBlock', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'ioBlock', i1Ptr)

! Define variable currentBlock
      allocate(i1Ptr(1))

! Setting up time level 1
      i1Ptr(1) % fieldName = 'currentBlock'
      i1Ptr(1) % isVarArray = .false.
      i1Ptr(1) % isDecomposed = .true.
      i1Ptr(1) % hasTimeDimension = .true.
      i1Ptr(1) % isPersistent = .true.
      i1Ptr(1) % isActive = .false.
! Setting up dimensions
      i1Ptr(1) % dimNames(1) = 'nParticles'
      i1Ptr(1) % defaultValue = 0
      allocate(i1Ptr(1) % attLists(1))
      allocate(i1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'long_name', 'current block a particle is on')
      i1Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i1Ptr(1) % block => block

      if (lagrPartTrackAMPKGActive) then
         i1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'currentBlock', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'currentBlock', i1Ptr)

! Define variable currentCell
      allocate(i1Ptr(1))

! Setting up time level 1
      i1Ptr(1) % fieldName = 'currentCell'
      i1Ptr(1) % isVarArray = .false.
      i1Ptr(1) % isDecomposed = .true.
      i1Ptr(1) % hasTimeDimension = .true.
      i1Ptr(1) % isPersistent = .true.
      i1Ptr(1) % isActive = .false.
! Setting up dimensions
      i1Ptr(1) % dimNames(1) = 'nParticles'
      i1Ptr(1) % defaultValue = 0
      allocate(i1Ptr(1) % attLists(1))
      allocate(i1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'long_name', 'current cell a particle is on')
      i1Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i1Ptr(1) % block => block

      if (lagrPartTrackAMPKGActive) then
         i1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'currentCell', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'currentCell', i1Ptr)

! Define variable indexToParticleID
      allocate(i1Ptr(1))

! Setting up time level 1
      i1Ptr(1) % fieldName = 'indexToParticleID'
      i1Ptr(1) % isVarArray = .false.
      i1Ptr(1) % isDecomposed = .true.
      i1Ptr(1) % hasTimeDimension = .false.
      i1Ptr(1) % isPersistent = .true.
      i1Ptr(1) % isActive = .false.
! Setting up dimensions
      i1Ptr(1) % dimNames(1) = 'nParticles'
      i1Ptr(1) % defaultValue = 0
      allocate(i1Ptr(1) % attLists(1))
      allocate(i1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'long_name', 'designates global ID for a particle')
      i1Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i1Ptr(1) % block => block

      if (lagrPartTrackAMPKGActive) then
         i1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'indexToParticleID', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'indexToParticleID', i1Ptr)

! Define variable xParticle
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'xParticle'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nParticles'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'x location of horizontal particle position')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (lagrPartTrackAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'xParticle', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'xParticle', r1Ptr)

! Define variable yParticle
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'yParticle'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nParticles'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'y location of horizontal particle position')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (lagrPartTrackAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'yParticle', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'yParticle', r1Ptr)

! Define variable zParticle
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'zParticle'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nParticles'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'z location of horizontal particle position')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (lagrPartTrackAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'zParticle', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'zParticle', r1Ptr)

! Define variable zLevelParticle
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'zLevelParticle'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nParticles'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'z-level for vertical elevation of particle position')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (lagrPartTrackAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'zLevelParticle', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'zLevelParticle', r1Ptr)

! Define variable xParticleReset
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'xParticleReset'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nParticles'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'reset x location of horizontal particle position')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (lagrPartTrackAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'xParticleReset', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'xParticleReset', r1Ptr)

! Define variable yParticleReset
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'yParticleReset'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nParticles'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'reset y location of horizontal particle position')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (lagrPartTrackAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'yParticleReset', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'yParticleReset', r1Ptr)

! Define variable zParticleReset
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'zParticleReset'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nParticles'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'reset z location of horizontal particle position')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (lagrPartTrackAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'zParticleReset', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'zParticleReset', r1Ptr)

! Define variable zLevelParticleReset
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'zLevelParticleReset'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nParticles'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'reset z-level for vertical elevation of particle position')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (lagrPartTrackAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'zLevelParticleReset', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'zLevelParticleReset', r1Ptr)

! Define variable currentBlockReset
      allocate(i1Ptr(1))

! Setting up time level 1
      i1Ptr(1) % fieldName = 'currentBlockReset'
      i1Ptr(1) % isVarArray = .false.
      i1Ptr(1) % isDecomposed = .true.
      i1Ptr(1) % hasTimeDimension = .false.
      i1Ptr(1) % isPersistent = .true.
      i1Ptr(1) % isActive = .false.
! Setting up dimensions
      i1Ptr(1) % dimNames(1) = 'nParticles'
      i1Ptr(1) % defaultValue = 0
      allocate(i1Ptr(1) % attLists(1))
      allocate(i1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'long_name', 'reset block for a particle')
      i1Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i1Ptr(1) % block => block

      if (lagrPartTrackAMPKGActive) then
         i1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'currentBlockReset', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'currentBlockReset', i1Ptr)

! Define variable currentCellReset
      allocate(i1Ptr(1))

! Setting up time level 1
      i1Ptr(1) % fieldName = 'currentCellReset'
      i1Ptr(1) % isVarArray = .false.
      i1Ptr(1) % isDecomposed = .true.
      i1Ptr(1) % hasTimeDimension = .false.
      i1Ptr(1) % isPersistent = .true.
      i1Ptr(1) % isActive = .false.
! Setting up dimensions
      i1Ptr(1) % dimNames(1) = 'nParticles'
      i1Ptr(1) % defaultValue = 0
      allocate(i1Ptr(1) % attLists(1))
      allocate(i1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'long_name', 'reset cell for a particle')
      i1Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i1Ptr(1) % block => block

      if (lagrPartTrackAMPKGActive) then
         i1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'currentCellReset', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'currentCellReset', i1Ptr)

! Define variable timeSinceReset
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'timeSinceReset'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nParticles'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'time (in seconds) since last particle reset')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (lagrPartTrackAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'timeSinceReset', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'timeSinceReset', r1Ptr)

! Define variable resetTime
      allocate(i1Ptr(1))

! Setting up time level 1
      i1Ptr(1) % fieldName = 'resetTime'
      i1Ptr(1) % isVarArray = .false.
      i1Ptr(1) % isDecomposed = .true.
      i1Ptr(1) % hasTimeDimension = .false.
      i1Ptr(1) % isPersistent = .true.
      i1Ptr(1) % isActive = .false.
! Setting up dimensions
      i1Ptr(1) % dimNames(1) = 'nParticles'
      i1Ptr(1) % defaultValue = 0
      allocate(i1Ptr(1) % attLists(1))
      allocate(i1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'long_name', 'reset timer (in seconds) for particles')
      i1Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i1Ptr(1) % block => block

      if (lagrPartTrackAMPKGActive) then
         i1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'resetTime', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'resetTime', i1Ptr)

! Define variable numTimesReset
      allocate(i1Ptr(1))

! Setting up time level 1
      i1Ptr(1) % fieldName = 'numTimesReset'
      i1Ptr(1) % isVarArray = .false.
      i1Ptr(1) % isDecomposed = .true.
      i1Ptr(1) % hasTimeDimension = .true.
      i1Ptr(1) % isPersistent = .true.
      i1Ptr(1) % isActive = .false.
! Setting up dimensions
      i1Ptr(1) % dimNames(1) = 'nParticles'
      i1Ptr(1) % defaultValue = 0
      allocate(i1Ptr(1) % attLists(1))
      allocate(i1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'long_name', 'flag to specify how many times the particle was reset')
      i1Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i1Ptr(1) % block => block

      if (lagrPartTrackAMPKGActive) then
         i1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'numTimesReset', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'numTimesReset', i1Ptr)

! Define variable verticalTreatment
      allocate(i1Ptr(1))

! Setting up time level 1
      i1Ptr(1) % fieldName = 'verticalTreatment'
      i1Ptr(1) % isVarArray = .false.
      i1Ptr(1) % isDecomposed = .true.
      i1Ptr(1) % hasTimeDimension = .true.
      i1Ptr(1) % isPersistent = .true.
      i1Ptr(1) % isActive = .false.
! Setting up dimensions
      i1Ptr(1) % dimNames(1) = 'nParticles'
      i1Ptr(1) % defaultValue = 0
      allocate(i1Ptr(1) % attLists(1))
      allocate(i1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'long_name', 'select type of vertical treatment to be used, with '&
//'possible_values=''indexLevel'',''fixedZLevel'',''passiveFloat'',''buoyancySurface'',''argoFloat'' (ENUM)')
      i1Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i1Ptr(1) % block => block

      if (lagrPartTrackAMPKGActive) then
         i1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'verticalTreatment', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'verticalTreatment', i1Ptr)

! Define variable indexLevel
      allocate(i1Ptr(1))

! Setting up time level 1
      i1Ptr(1) % fieldName = 'indexLevel'
      i1Ptr(1) % isVarArray = .false.
      i1Ptr(1) % isDecomposed = .true.
      i1Ptr(1) % hasTimeDimension = .true.
      i1Ptr(1) % isPersistent = .true.
      i1Ptr(1) % isActive = .false.
! Setting up dimensions
      i1Ptr(1) % dimNames(1) = 'nParticles'
      i1Ptr(1) % defaultValue = 0
      allocate(i1Ptr(1) % attLists(1))
      allocate(i1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'long_name', '0 if particle is fixed, or index level if particle is '&
//'free-floating')
      i1Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i1Ptr(1) % block => block

      if (lagrPartTrackAMPKGActive) then
         i1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'indexLevel', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'indexLevel', i1Ptr)

! Define variable dtParticle
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'dtParticle'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nParticles'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 's')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Any positive real value, but limited by CFL condition.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (lagrPartTrackAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'dtParticle', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'dtParticle', r1Ptr)

! Define variable buoyancyParticle
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'buoyancyParticle'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nParticles'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'kg m^{-3}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'buoyancy values for particle, currently proxy for density')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (lagrPartTrackAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'buoyancyParticle', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'buoyancyParticle', r1Ptr)

! Define variable transfered
      allocate(i1Ptr(1))

! Setting up time level 1
      i1Ptr(1) % fieldName = 'transfered'
      i1Ptr(1) % isVarArray = .false.
      i1Ptr(1) % isDecomposed = .true.
      i1Ptr(1) % hasTimeDimension = .true.
      i1Ptr(1) % isPersistent = .true.
      i1Ptr(1) % isActive = .false.
! Setting up dimensions
      i1Ptr(1) % dimNames(1) = 'nParticles'
      i1Ptr(1) % defaultValue = 0
      allocate(i1Ptr(1) % attLists(1))
      allocate(i1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'long_name', 'flag to monitor if the particle was transfered')
      i1Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i1Ptr(1) % block => block

      if (lagrPartTrackAMPKGActive) then
         i1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'transfered', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'transfered', i1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_pool_lagrPartTrackHalo


   subroutine ocn_generate_pool_lagrPartTrackScratch(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'lagrPartTrackScratch', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'lagrPartTrackScratch', newSubPool)

! Define variable ucReconstructX
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ucReconstructX'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'reconstructed cell center velocity- x component')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (lagrPartTrackAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ucReconstructX', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ucReconstructX', r2Ptr)

! Define variable ucReconstructY
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ucReconstructY'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'reconstructed cell center velocity- y component')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (lagrPartTrackAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ucReconstructY', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ucReconstructY', r2Ptr)

! Define variable ucReconstructZ
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ucReconstructZ'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'reconstructed cell center velocity- z component')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (lagrPartTrackAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ucReconstructZ', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ucReconstructZ', r2Ptr)

! Define variable ucTemp
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ucTemp'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'cell velocity')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (lagrPartTrackAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ucTemp', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ucTemp', r2Ptr)

! Define variable ucX
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ucX'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'cell velocity- x component')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (lagrPartTrackAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ucX', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ucX', r2Ptr)

! Define variable ucY
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ucY'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'cell velocity- y component')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (lagrPartTrackAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ucY', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ucY', r2Ptr)

! Define variable ucZ
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ucZ'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'cell velocity- z component')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (lagrPartTrackAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ucZ', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ucZ', r2Ptr)

! Define variable uvX
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'uvX'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nVertices'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'vertex velocity- x component')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (lagrPartTrackAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'uvX', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'uvX', r2Ptr)

! Define variable uvY
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'uvY'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nVertices'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'vertex velocity- y component')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (lagrPartTrackAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'uvY', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'uvY', r2Ptr)

! Define variable uvZ
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'uvZ'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nVertices'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'vertex velocity- z component')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (lagrPartTrackAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'uvZ', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'uvZ', r2Ptr)

! Define variable ucReconstructMeridional
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ucReconstructMeridional'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'reconstructed cell center velocity- meridional component')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (lagrPartTrackAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ucReconstructMeridional', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ucReconstructMeridional', r2Ptr)

! Define variable ucReconstructZonal
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ucReconstructZonal'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'reconstructed cell center velocity- zonal component')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (lagrPartTrackAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ucReconstructZonal', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ucReconstructZonal', r2Ptr)

! Define variable boundaryVertexGlobal
      allocate(i2Ptr(1))

! Setting up time level 1
      i2Ptr(1) % fieldName = 'boundaryVertexGlobal'
      i2Ptr(1) % isVarArray = .false.
      i2Ptr(1) % isDecomposed = .true.
      i2Ptr(1) % hasTimeDimension = .false.
      i2Ptr(1) % isPersistent = .true.
      i2Ptr(1) % isActive = .false.
! Setting up dimensions
      i2Ptr(1) % dimNames(1) = 'nVertLevels'
      i2Ptr(1) % dimNames(2) = 'nVertices'
      i2Ptr(1) % defaultValue = 0
      allocate(i2Ptr(1) % attLists(1))
      allocate(i2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'long_name', 'Mask for determining boundary vertices, but global. A '&
//'boundary vertex has at least one inactive cell neighboring it.')
      i2Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i2Ptr(1) % block => block

      if (lagrPartTrackAMPKGActive) then
         i2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'boundaryVertexGlobal', i2Ptr)
      call mpas_pool_add_field(block % allFields, 'boundaryVertexGlobal', i2Ptr)

! Define variable boundaryCellGlobal
      allocate(i2Ptr(1))

! Setting up time level 1
      i2Ptr(1) % fieldName = 'boundaryCellGlobal'
      i2Ptr(1) % isVarArray = .false.
      i2Ptr(1) % isDecomposed = .true.
      i2Ptr(1) % hasTimeDimension = .false.
      i2Ptr(1) % isPersistent = .true.
      i2Ptr(1) % isActive = .false.
! Setting up dimensions
      i2Ptr(1) % dimNames(1) = 'nVertLevels'
      i2Ptr(1) % dimNames(2) = 'nCells'
      i2Ptr(1) % defaultValue = 0
      allocate(i2Ptr(1) % attLists(1))
      allocate(i2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'long_name', 'Mask for determining boundary cells, but global. A '&
//'boundary cell has at least one inactive cell neighboring it.')
      i2Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i2Ptr(1) % block => block

      if (lagrPartTrackAMPKGActive) then
         i2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'boundaryCellGlobal', i2Ptr)
      call mpas_pool_add_field(block % allFields, 'boundaryCellGlobal', i2Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_pool_lagrPartTrackScratch


   subroutine ocn_generate_pool_eliassenPalmAM(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'eliassenPalmAM', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'eliassenPalmAM', newSubPool)

! Define variable potentialDensityMidRef
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'potentialDensityMidRef'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .false.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'kg m^{-3}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Potential density target values of buoyancy coordinate '&
//'layers')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (eliassenPalmAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'potentialDensityMidRef', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'potentialDensityMidRef', r1Ptr)

! Define variable potentialDensityTopRef
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'potentialDensityTopRef'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .false.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'kg m^{-3}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Potential density at top of buoyancy coordinate layers')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (eliassenPalmAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'potentialDensityTopRef', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'potentialDensityTopRef', r1Ptr)

! Define variable buoyancyMidRef
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'buoyancyMidRef'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .false.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-2}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Buoyancy of buoyancy coordinate layers')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (eliassenPalmAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'buoyancyMidRef', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'buoyancyMidRef', r1Ptr)

! Define variable buoyancyInterfaceRef
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'buoyancyInterfaceRef'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .false.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nBuoyancyLayersP1'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm s^{-2}')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Buoyancy at interfaces of buoyancy coordinate layers')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (eliassenPalmAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'buoyancyInterfaceRef', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'buoyancyInterfaceRef', r1Ptr)

! Define variable buoyancyMaskEA
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'buoyancyMaskEA'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', '-')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'ensemble average of the buoyancy mask')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (eliassenPalmAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'buoyancyMaskEA', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'buoyancyMaskEA', r2Ptr)

! Define variable sigmaEA
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'sigmaEA'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 's^{-2}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Inverse of the derivative of buoyancy wrt z, or thickness '&
//'per unit buoyancy, aka thickness, in buoyancy coordinates, ensemble average')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (eliassenPalmAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'sigmaEA', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'sigmaEA', r2Ptr)

! Define variable nSamplesEA
      allocate(i0Ptr(1))

! Setting up time level 1
      i0Ptr(1) % fieldName = 'nSamplesEA'
      i0Ptr(1) % isVarArray = .false.
      i0Ptr(1) % isDecomposed = .false.
      i0Ptr(1) % hasTimeDimension = .true.
      i0Ptr(1) % defaultValue = 0
      i0Ptr(1) % scalar = 0
      allocate(i0Ptr(1) % attLists(1))
      allocate(i0Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i0Ptr(1) % attLists(1) % attList, 'units', '-')
      call mpas_add_att(i0Ptr(1) % attLists(1) % attList, 'long_name', 'Number of samples used in the ensamble average')
      i0Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i0Ptr(1) % block => block

      if (eliassenPalmAMPKGActive) then
         i0Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'nSamplesEA', i0Ptr)
      call mpas_pool_add_field(block % allFields, 'nSamplesEA', i0Ptr)

! Define variable heightMidBuoyCoorEA
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'heightMidBuoyCoorEA'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'z-coordinate of each buoyancy layer, ensemble average')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (eliassenPalmAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'heightMidBuoyCoorEA', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'heightMidBuoyCoorEA', r2Ptr)

! Define variable montgPotGradZonalEA
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'montgPotGradZonalEA'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Zonal gradient of montgomery potential at cell center in '&
//'buoyancy coordinates, ensemble average')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (eliassenPalmAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'montgPotGradZonalEA', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'montgPotGradZonalEA', r2Ptr)

! Define variable montgPotGradMeridEA
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'montgPotGradMeridEA'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Meridional gradient of montgomery potential at cell center '&
//'in buoyancy coordinates, ensemble average')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (eliassenPalmAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'montgPotGradMeridEA', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'montgPotGradMeridEA', r2Ptr)

! Define variable heightMidBuoyCoorSqEA
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'heightMidBuoyCoorSqEA'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm^2')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'z-coordinate of each buoyancy layer, squared, ensemble '&
//'average')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (eliassenPalmAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'heightMidBuoyCoorSqEA', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'heightMidBuoyCoorSqEA', r2Ptr)

! Define variable montgPotBuoyCoorEA
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'montgPotBuoyCoorEA'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm^2 s^{-2}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Montgomery potential in buoyancy coordinates, ensemble '&
//'average')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (eliassenPalmAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'montgPotBuoyCoorEA', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'montgPotBuoyCoorEA', r2Ptr)

! Define variable heightMGradZonalEA
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'heightMGradZonalEA'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm^2 s^{-2}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Height times zonal gradient of Montgomery potential in '&
//'buoyancy coordinates, ensemble average')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (eliassenPalmAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'heightMGradZonalEA', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'heightMGradZonalEA', r2Ptr)

! Define variable heightMGradMeridEA
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'heightMGradMeridEA'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm^2 s^{-2}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Height times meridional gradient of Montgomery potential '&
//'in buoyancy coordinates, ensemble average')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (eliassenPalmAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'heightMGradMeridEA', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'heightMGradMeridEA', r2Ptr)

! Define variable usigmaEA
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'usigmaEA'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm^2 s^{-2}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Zonal velocity times sigma, ensemble average')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (eliassenPalmAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'usigmaEA', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'usigmaEA', r2Ptr)

! Define variable vsigmaEA
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'vsigmaEA'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm^2 s^{-2}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Meridional velocity times sigma, ensemble average')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (eliassenPalmAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'vsigmaEA', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'vsigmaEA', r2Ptr)

! Define variable varpisigmaEA
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'varpisigmaEA'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Vertical velocity in buoyancy coordinates times sigma, '&
//'ensemble average')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (eliassenPalmAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'varpisigmaEA', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'varpisigmaEA', r2Ptr)

! Define variable uusigmaEA
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'uusigmaEA'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm^2 s^{-2}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Zonal velocity times zonal velocity times sigma, ensemble '&
//'average')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (eliassenPalmAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'uusigmaEA', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'uusigmaEA', r2Ptr)

! Define variable vvsigmaEA
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'vvsigmaEA'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm^2 s^{-2}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Meridional velocity times meridional velocity times sigma, '&
//'ensemble average')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (eliassenPalmAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'vvsigmaEA', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'vvsigmaEA', r2Ptr)

! Define variable uvsigmaEA
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'uvsigmaEA'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm^2 s^{-2}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Zonal velocity times meridional velocity times sigma, '&
//'ensemble average')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (eliassenPalmAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'uvsigmaEA', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'uvsigmaEA', r2Ptr)

! Define variable uvarpisigmaEA
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'uvarpisigmaEA'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm^2 s^{-2}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Zonal velocity times vertical velocity in buoyancy '&
//'coordinates times sigma, ensemble average')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (eliassenPalmAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'uvarpisigmaEA', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'uvarpisigmaEA', r2Ptr)

! Define variable vvarpisigmaEA
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'vvarpisigmaEA'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm^2 s^{-2}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Meridional velocity times vertical velocity in buoyancy '&
//'coordinates times sigma, ensemble average')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (eliassenPalmAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'vvarpisigmaEA', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'vvarpisigmaEA', r2Ptr)

! Define variable uTWA
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'uTWA'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Zonal velocity, thickness weighted')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (eliassenPalmAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'uTWA', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'uTWA', r2Ptr)

! Define variable vTWA
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'vTWA'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Meridional velocity, thickness weighted')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (eliassenPalmAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'vTWA', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'vTWA', r2Ptr)

! Define variable varpiTWA
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'varpiTWA'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-3}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Vertical velocity, thickness weighted')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (eliassenPalmAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'varpiTWA', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'varpiTWA', r2Ptr)

! Define variable duTWAdz
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'duTWAdz'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 's^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Derivative of thickness weighted zonal velocity with '&
//'respect to z (vertical coordinate).')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (eliassenPalmAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'duTWAdz', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'duTWAdz', r2Ptr)

! Define variable dvTWAdz
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'dvTWAdz'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 's^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Derivative of thickness weighted meridional velocity with '&
//'respect to z (vertical coordinate).')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (eliassenPalmAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'dvTWAdz', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'dvTWAdz', r2Ptr)

! Define variable EPFT
      allocate(r4Ptr(1))

! Setting up time level 1
      r4Ptr(1) % fieldName = 'EPFT'
      r4Ptr(1) % isVarArray = .false.
      r4Ptr(1) % isDecomposed = .true.
      r4Ptr(1) % hasTimeDimension = .true.
      r4Ptr(1) % isPersistent = .true.
      r4Ptr(1) % isActive = .false.
! Setting up dimensions
      r4Ptr(1) % dimNames(1) = 'R3'
      r4Ptr(1) % dimNames(2) = 'R3'
      r4Ptr(1) % dimNames(3) = 'nBuoyancyLayers'
      r4Ptr(1) % dimNames(4) = 'nCells'
      r4Ptr(1) % defaultValue = 0.0
      allocate(r4Ptr(1) % attLists(1))
      allocate(r4Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r4Ptr(1) % attLists(1) % attList, 'units', 'm^2 s^{-2}')
      call mpas_add_att(r4Ptr(1) % attLists(1) % attList, 'long_name', 'Eliassen-Palm flux tensor')
      r4Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r4Ptr(1) % block => block

      if (eliassenPalmAMPKGActive) then
         r4Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'EPFT', r4Ptr)
      call mpas_pool_add_field(block % allFields, 'EPFT', r4Ptr)

! Define variable uuTWACorr
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'uuTWACorr'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm^2 s^{-2}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Thickness-weighted averaged eddy u-u correlation.')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (eliassenPalmAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'uuTWACorr', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'uuTWACorr', r2Ptr)

! Define variable vvTWACorr
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'vvTWACorr'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm^2 s^{-2}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Thickness-weighted averaged eddy v-v correlation.')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (eliassenPalmAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'vvTWACorr', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'vvTWACorr', r2Ptr)

! Define variable uvTWACorr
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'uvTWACorr'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm^2 s^{-2}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Thickness-weighted averaged eddy u-v correlation.')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (eliassenPalmAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'uvTWACorr', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'uvTWACorr', r2Ptr)

! Define variable epeTWA
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'epeTWA'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm^2 s^{-2}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Thickness-weighted averaged eddy potential energy.')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (eliassenPalmAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'epeTWA', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'epeTWA', r2Ptr)

! Define variable eddyFormDragZonal
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'eddyFormDragZonal'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm^2 s^{-2}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Thickness-weighted averaged eddy form drag in x')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (eliassenPalmAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'eddyFormDragZonal', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'eddyFormDragZonal', r2Ptr)

! Define variable eddyFormDragMerid
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'eddyFormDragMerid'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm^2 s^{-2}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Thickness-weighted averaged eddy form drag in y')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (eliassenPalmAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'eddyFormDragMerid', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'eddyFormDragMerid', r2Ptr)

! Define variable divEPFT
      allocate(r3Ptr(1))

! Setting up time level 1
      r3Ptr(1) % fieldName = 'divEPFT'
      r3Ptr(1) % isVarArray = .false.
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.
! Setting up dimensions
      r3Ptr(1) % dimNames(1) = 'R3'
      r3Ptr(1) % dimNames(2) = 'nBuoyancyLayers'
      r3Ptr(1) % dimNames(3) = 'nCells'
      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(1))
      allocate(r3Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'units', 'm s^{-2}')
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'long_name', 'Divergence of the Eliassen-Palm flux tensor, in buoyancy '&
//'coordinates')
      r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r3Ptr(1) % block => block

      if (eliassenPalmAMPKGActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'divEPFT', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'divEPFT', r3Ptr)

! Define variable divEPFT1
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'divEPFT1'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-2}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'First component of the divergence of the Eliassen-Palm '&
//'flux tensor, in buoyancy coordinates')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (eliassenPalmAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'divEPFT1', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'divEPFT1', r2Ptr)

! Define variable divEPFT2
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'divEPFT2'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-2}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Second component of the divergence of the Eliassen-Palm '&
//'flux tensor, in buoyancy coordinates')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (eliassenPalmAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'divEPFT2', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'divEPFT2', r2Ptr)

! Define variable divEPFTshear1
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'divEPFTshear1'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-2}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'First component of divergence of shear components of the '&
//'Eliassen-Palm flux tensor, in buoyancy coordinates')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (eliassenPalmAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'divEPFTshear1', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'divEPFTshear1', r2Ptr)

! Define variable divEPFTshear2
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'divEPFTshear2'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-2}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Second component of divergence of shear components of the '&
//'Eliassen-Palm flux tensor, in buoyancy coordinates')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (eliassenPalmAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'divEPFTshear2', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'divEPFTshear2', r2Ptr)

! Define variable divEPFTdrag1
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'divEPFTdrag1'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-2}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'First component of divergence of form drag components of '&
//'the Eliassen-Palm flux tensor, in buoyancy coordinates')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (eliassenPalmAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'divEPFTdrag1', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'divEPFTdrag1', r2Ptr)

! Define variable divEPFTdrag2
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'divEPFTdrag2'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-2}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Second component of divergence of form drag components of '&
//'the Eliassen-Palm flux tensor, in buoyancy coordinates')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (eliassenPalmAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'divEPFTdrag2', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'divEPFTdrag2', r2Ptr)

! Define variable ErtelPVFlux
      allocate(r3Ptr(1))

! Setting up time level 1
      r3Ptr(1) % fieldName = 'ErtelPVFlux'
      r3Ptr(1) % isVarArray = .false.
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.
! Setting up dimensions
      r3Ptr(1) % dimNames(1) = 'R3'
      r3Ptr(1) % dimNames(2) = 'nBuoyancyLayers'
      r3Ptr(1) % dimNames(3) = 'nCells'
      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(1))
      allocate(r3Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'units', 'm s^{-4}')
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'long_name', 'Ertel potential vorticity flux in buoyancy coordinates')
      r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r3Ptr(1) % block => block

      if (eliassenPalmAMPKGActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ErtelPVFlux', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'ErtelPVFlux', r3Ptr)

! Define variable ErtelPVFlux1
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ErtelPVFlux1'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-4}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'First component of the Ertel potential vorticity flux in '&
//'buoyancy coordinates')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (eliassenPalmAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ErtelPVFlux1', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ErtelPVFlux1', r2Ptr)

! Define variable ErtelPVFlux2
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ErtelPVFlux2'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-4}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Second component of the Ertel potential vorticity flux in '&
//'buoyancy coordinates')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (eliassenPalmAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ErtelPVFlux2', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ErtelPVFlux2', r2Ptr)

! Define variable ErtelPVTendency
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ErtelPVTendency'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 's^{-4}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Tendency of Ertel PV due to divergence of eddy PV fluxes')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (eliassenPalmAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ErtelPVTendency', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ErtelPVTendency', r2Ptr)

! Define variable ErtelPV
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ErtelPV'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 's^{-3}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Ertel PV on buoyancy surfaces')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (eliassenPalmAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ErtelPV', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ErtelPV', r2Ptr)

! Define variable ErtelPVGradZonal
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ErtelPVGradZonal'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm^{-1} s^{-3}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Ertel PV on buoyancy surfaces')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (eliassenPalmAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ErtelPVGradZonal', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ErtelPVGradZonal', r2Ptr)

! Define variable ErtelPVGradMerid
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ErtelPVGradMerid'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm^{-1} s^{-3}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Ertel PV on buoyancy surfaces')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (eliassenPalmAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'ErtelPVGradMerid', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ErtelPVGradMerid', r2Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_pool_eliassenPalmAM


   subroutine ocn_generate_pool_eliassenPalmAMPKGScratch(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'eliassenPalmAMPKGScratch', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'eliassenPalmAMPKGScratch', newSubPool)

! Define variable firstLayerBuoyCoor
      allocate(i1Ptr(1))

! Setting up time level 1
      i1Ptr(1) % fieldName = 'firstLayerBuoyCoor'
      i1Ptr(1) % isVarArray = .false.
      i1Ptr(1) % isDecomposed = .true.
      i1Ptr(1) % hasTimeDimension = .true.
      i1Ptr(1) % isPersistent = .true.
      i1Ptr(1) % isActive = .false.
! Setting up dimensions
      i1Ptr(1) % dimNames(1) = 'nCells'
      i1Ptr(1) % defaultValue = 0
      allocate(i1Ptr(1) % attLists(1))
      allocate(i1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'units', '-')
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'long_name', 'index, in buoyancy coordinates, of the first layer in '&
//'column for a given cell')
      i1Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i1Ptr(1) % block => block

      i1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'firstLayerBuoyCoor', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'firstLayerBuoyCoor', i1Ptr)

! Define variable lastLayerBuoyCoor
      allocate(i1Ptr(1))

! Setting up time level 1
      i1Ptr(1) % fieldName = 'lastLayerBuoyCoor'
      i1Ptr(1) % isVarArray = .false.
      i1Ptr(1) % isDecomposed = .true.
      i1Ptr(1) % hasTimeDimension = .true.
      i1Ptr(1) % isPersistent = .true.
      i1Ptr(1) % isActive = .false.
! Setting up dimensions
      i1Ptr(1) % dimNames(1) = 'nCells'
      i1Ptr(1) % defaultValue = 0
      allocate(i1Ptr(1) % attLists(1))
      allocate(i1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'units', '-')
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'long_name', 'index, in buoyancy coordinates, of the last layer in '&
//'column for a given cell')
      i1Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i1Ptr(1) % block => block

      i1Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'lastLayerBuoyCoor', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'lastLayerBuoyCoor', i1Ptr)

! Define variable heightMidBuoyCoor
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'heightMidBuoyCoor'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Height (z-coordinate) of buoyancy layer')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'heightMidBuoyCoor', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'heightMidBuoyCoor', r2Ptr)

! Define variable heightTopBuoyCoor
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'heightTopBuoyCoor'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Height (z-coordinate) at top of buoyancy layer')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'heightTopBuoyCoor', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'heightTopBuoyCoor', r2Ptr)

! Define variable heightInterfaceBuoyCoor
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'heightInterfaceBuoyCoor'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayersP1'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Height (z-coordinate) of the interfaces of buoyancy layer')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'heightInterfaceBuoyCoor', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'heightInterfaceBuoyCoor', r2Ptr)

! Define variable sigma
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'sigma'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 's^{-2}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Inverse of the derivative of buoyancy wrt z, aka '&
//'thickness, in buoyancy coordinates')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'sigma', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'sigma', r2Ptr)

! Define variable montgPotBuoyCoor
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'montgPotBuoyCoor'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm^2 s^{-2}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Montgomery potential in buoyancy coordinates')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'montgPotBuoyCoor', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'montgPotBuoyCoor', r2Ptr)

! Define variable montgPotNormalGradOnEdge
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'montgPotNormalGradOnEdge'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nEdges'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-2}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Normal gradient of the montgomery potential in buoyancy '&
//'coordinates')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'montgPotNormalGradOnEdge', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'montgPotNormalGradOnEdge', r2Ptr)

! Define variable uMidBuoyCoor
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'uMidBuoyCoor'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Longitudinal velocity at middle of layers in buoyancy '&
//'coordinates')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'uMidBuoyCoor', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'uMidBuoyCoor', r2Ptr)

! Define variable vMidBuoyCoor
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'vMidBuoyCoor'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Meridional velocity at the middle of layers in buoyancy '&
//'coordinates')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'vMidBuoyCoor', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'vMidBuoyCoor', r2Ptr)

! Define variable densityMidBuoyCoor
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'densityMidBuoyCoor'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'In-situ density at middle of layers in buoyancy '&
//'coordinates')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'densityMidBuoyCoor', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'densityMidBuoyCoor', r2Ptr)

! Define variable densityTopBuoyCoor
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'densityTopBuoyCoor'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'In-situ density at top of layers in buoyancy coordinates')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'densityTopBuoyCoor', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'densityTopBuoyCoor', r2Ptr)

! Define variable buoyancyMask
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'buoyancyMask'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', '-')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'mask in buoyancy coordinates, ocean cells are 1')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'buoyancyMask', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'buoyancyMask', r2Ptr)

! Define variable montgPotGradX
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'montgPotGradX'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-2}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'x component of gradient of montgomery potential at cell '&
//'center in buoyancy coordinates')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'montgPotGradX', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'montgPotGradX', r2Ptr)

! Define variable montgPotGradY
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'montgPotGradY'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-2}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'y component of gradient of montgomery potential at cell '&
//'center in buoyancy coordinates')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'montgPotGradY', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'montgPotGradY', r2Ptr)

! Define variable montgPotGradZ
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'montgPotGradZ'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-2}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'z component of gradient of montgomery potential at cell '&
//'center in buoyancy coordinates')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'montgPotGradZ', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'montgPotGradZ', r2Ptr)

! Define variable montgPotGradZonal
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'montgPotGradZonal'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-2}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Zonal component of gradient of montgomery potential at '&
//'cell center in buoyancy coordinates')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'montgPotGradZonal', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'montgPotGradZonal', r2Ptr)

! Define variable montgPotGradMerid
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'montgPotGradMerid'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-2}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Meridional component of gradient of montgomery potential '&
//'at cell center in buoyancy coordinates')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'montgPotGradMerid', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'montgPotGradMerid', r2Ptr)

! Define variable wrk3DnVertLevelsP1
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'wrk3DnVertLevelsP1'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevelsP1'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'work array')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'wrk3DnVertLevelsP1', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'wrk3DnVertLevelsP1', r2Ptr)

! Define variable wrk3DnVertLevels
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'wrk3DnVertLevels'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'work array')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'wrk3DnVertLevels', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'wrk3DnVertLevels', r2Ptr)

! Define variable wrk3DBuoyCoor
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'wrk3DBuoyCoor'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'work array')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'wrk3DBuoyCoor', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'wrk3DBuoyCoor', r2Ptr)

! Define variable ErtelPVNormalGradOnEdge
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ErtelPVNormalGradOnEdge'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nEdges'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 's^{-4}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Normal gradient of EPV in buoyancy coordinates')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'ErtelPVNormalGradOnEdge', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ErtelPVNormalGradOnEdge', r2Ptr)

! Define variable ErtelPVGradX
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ErtelPVGradX'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 's^{-4}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'X component of gradient of EPV in buoyancy coordinates')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'ErtelPVGradX', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ErtelPVGradX', r2Ptr)

! Define variable ErtelPVGradY
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ErtelPVGradY'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 's^{-4}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Y component of gradient of EPV in buoyancy coordinates')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'ErtelPVGradY', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ErtelPVGradY', r2Ptr)

! Define variable ErtelPVGradZ
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'ErtelPVGradZ'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 's^{-4}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Z component of gradient of EPV in buoyancy coordinates')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'ErtelPVGradZ', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'ErtelPVGradZ', r2Ptr)

! Define variable wrkVector
      allocate(r3Ptr(1))

! Setting up time level 1
      r3Ptr(1) % fieldName = 'wrkVector'
      r3Ptr(1) % isVarArray = .false.
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .false.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.
! Setting up dimensions
      r3Ptr(1) % dimNames(1) = 'R3'
      r3Ptr(1) % dimNames(2) = 'nBuoyancyLayers'
      r3Ptr(1) % dimNames(3) = 'nCells'
      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(1))
      allocate(r3Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'long_name', 'Work vector array')
      r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r3Ptr(1) % block => block

      r3Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'wrkVector', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'wrkVector', r3Ptr)

! Define variable wrkTensor
      allocate(r4Ptr(1))

! Setting up time level 1
      r4Ptr(1) % fieldName = 'wrkTensor'
      r4Ptr(1) % isVarArray = .false.
      r4Ptr(1) % isDecomposed = .true.
      r4Ptr(1) % hasTimeDimension = .false.
      r4Ptr(1) % isPersistent = .true.
      r4Ptr(1) % isActive = .false.
! Setting up dimensions
      r4Ptr(1) % dimNames(1) = 'R3'
      r4Ptr(1) % dimNames(2) = 'R3'
      r4Ptr(1) % dimNames(3) = 'nBuoyancyLayers'
      r4Ptr(1) % dimNames(4) = 'nCells'
      r4Ptr(1) % defaultValue = 0.0
      allocate(r4Ptr(1) % attLists(1))
      allocate(r4Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r4Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r4Ptr(1) % attLists(1) % attList, 'long_name', 'Work tensor array')
      r4Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r4Ptr(1) % block => block

      r4Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'wrkTensor', r4Ptr)
      call mpas_pool_add_field(block % allFields, 'wrkTensor', r4Ptr)

! Define variable array1_3D
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'array1_3D'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', '-')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'test array 1, in depth coordinates')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'array1_3D', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'array1_3D', r2Ptr)

! Define variable array2_3D
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'array2_3D'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', '-')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'test array 2, in depth coordinates')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'array2_3D', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'array2_3D', r2Ptr)

! Define variable array3_3D
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'array3_3D'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', '-')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'test array 3, in depth coordinates')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'array3_3D', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'array3_3D', r2Ptr)

! Define variable array1_3Dbuoy
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'array1_3Dbuoy'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', '-')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'test array 1, in buoyancy coordinates')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'array1_3Dbuoy', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'array1_3Dbuoy', r2Ptr)

! Define variable array2_3Dbuoy
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'array2_3Dbuoy'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', '-')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'test array 2, in buoyancy coordinates')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'array2_3Dbuoy', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'array2_3Dbuoy', r2Ptr)

! Define variable PVMidBuoyCoor
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'PVMidBuoyCoor'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', '-')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Potential vorticity at cell center, in buoyancy '&
//'coordinates')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'PVMidBuoyCoor', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'PVMidBuoyCoor', r2Ptr)

! Define variable PVMidBuoyCoorEA
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'PVMidBuoyCoorEA'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', '-')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Potential vorticity at cell center, in buoyancy '&
//'coordinates, ensemble average')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'PVMidBuoyCoorEA', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'PVMidBuoyCoorEA', r2Ptr)

! Define variable uMidBuoyCoorEA
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'uMidBuoyCoorEA'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', '-')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Zonal velocity at cell center, in buoyancy coordinates, '&
//'ensemble average')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'uMidBuoyCoorEA', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'uMidBuoyCoorEA', r2Ptr)

! Define variable vMidBuoyCoorEA
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'vMidBuoyCoorEA'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', '-')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Meridional velocity at cell center, in buoyancy '&
//'coordinates, ensemble average')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'vMidBuoyCoorEA', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'vMidBuoyCoorEA', r2Ptr)

! Define variable uPVMidBuoyCoorEA
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'uPVMidBuoyCoorEA'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', '-')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Zonal velocity times Potential vorticity at cell center, '&
//'in buoyancy coordinates, ensemble average')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'uPVMidBuoyCoorEA', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'uPVMidBuoyCoorEA', r2Ptr)

! Define variable vPVMidBuoyCoorEA
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'vPVMidBuoyCoorEA'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nBuoyancyLayers'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', '-')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Meridional velocity times Potential vorticity at cell '&
//'center, in buoyancy coordinates, ensemble average')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      r2Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'vPVMidBuoyCoorEA', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'vPVMidBuoyCoorEA', r2Ptr)

! Define variable PVFluxTest
      allocate(r3Ptr(1))

! Setting up time level 1
      r3Ptr(1) % fieldName = 'PVFluxTest'
      r3Ptr(1) % isVarArray = .false.
      r3Ptr(1) % isDecomposed = .true.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.
! Setting up dimensions
      r3Ptr(1) % dimNames(1) = 'TWO'
      r3Ptr(1) % dimNames(2) = 'nBuoyancyLayers'
      r3Ptr(1) % dimNames(3) = 'nCells'
      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(1))
      allocate(r3Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'units', '-')
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'long_name', 'Potential vorticity flux test vector, in buoyancy '&
//'coordinates')
      r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r3Ptr(1) % block => block

      r3Ptr(1) % isActive = .true.
      call mpas_pool_add_field(newSubPool, 'PVFluxTest', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'PVFluxTest', r3Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_pool_eliassenPalmAMPKGScratch


   subroutine ocn_generate_pool_mixedLayerDepthsAM(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'mixedLayerDepthsAM', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'mixedLayerDepthsAM', newSubPool)

! Define variable tThreshMLD
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'tThreshMLD'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'mixed layer depth based on temperature threshold')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (mixedLayerDepthsAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'tThreshMLD', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'tThreshMLD', r1Ptr)

! Define variable dThreshMLD
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'dThreshMLD'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'mixed layer depth based on density threshold')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (mixedLayerDepthsAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'dThreshMLD', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'dThreshMLD', r1Ptr)

! Define variable tGradMLD
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'tGradMLD'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'mixed layer depth based on gradient of temperature')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (mixedLayerDepthsAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'tGradMLD', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'tGradMLD', r1Ptr)

! Define variable dGradMLD
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'dGradMLD'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'mixed layer depth based on gradient of density')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (mixedLayerDepthsAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'dGradMLD', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'dGradMLD', r1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_pool_mixedLayerDepthsAM


   subroutine ocn_generate_pool_regionalStatsAM(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'regionalStatsAM', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'regionalStatsAM', newSubPool)

! Define variable regionalStatsOneString
      allocate(c0Ptr(1))

! Setting up time level 1
      c0Ptr(1) % fieldName = 'regionalStatsOneString'
      c0Ptr(1) % isVarArray = .false.
      c0Ptr(1) % isDecomposed = .false.
      c0Ptr(1) % hasTimeDimension = .true.
      c0Ptr(1) % defaultValue = ''
      c0Ptr(1) % scalar = ''
      allocate(c0Ptr(1) % attLists(1))
      allocate(c0Ptr(1) % attLists(1) % attList)
      call mpas_add_att(c0Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(c0Ptr(1) % attLists(1) % attList, 'long_name', 'a placeholder string so that regionalStats has a memory to '&
//'duplicate per instance')
      c0Ptr(1) % missingValue = MPAS_CHAR_FILLVAL
      c0Ptr(1) % block => block

      if (regionalStatsDailyAMPKGActive .or. regionalStatsWeeklyAMPKGActive .or. regionalStatsMonthlyAMPKGActive .or. &
regionalStatsCustomAMPKGActive) then
         c0Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'regionalStatsOneString', c0Ptr)
      call mpas_pool_add_field(block % allFields, 'regionalStatsOneString', c0Ptr)

! Define variable regionalStatsOneInteger
      allocate(i0Ptr(1))

! Setting up time level 1
      i0Ptr(1) % fieldName = 'regionalStatsOneInteger'
      i0Ptr(1) % isVarArray = .false.
      i0Ptr(1) % isDecomposed = .false.
      i0Ptr(1) % hasTimeDimension = .true.
      i0Ptr(1) % defaultValue = 0
      i0Ptr(1) % scalar = 0
      allocate(i0Ptr(1) % attLists(1))
      allocate(i0Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i0Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i0Ptr(1) % attLists(1) % attList, 'long_name', 'a placeholder integer so that regionalStats has a memory '&
//'to duplicate per instance')
      i0Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i0Ptr(1) % block => block

      if (regionalStatsDailyAMPKGActive .or. regionalStatsWeeklyAMPKGActive .or. regionalStatsMonthlyAMPKGActive .or. &
regionalStatsCustomAMPKGActive) then
         i0Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'regionalStatsOneInteger', i0Ptr)
      call mpas_pool_add_field(block % allFields, 'regionalStatsOneInteger', i0Ptr)

! Define variable regionalStatsOneReal
      allocate(r0Ptr(1))

! Setting up time level 1
      r0Ptr(1) % fieldName = 'regionalStatsOneReal'
      r0Ptr(1) % isVarArray = .false.
      r0Ptr(1) % isDecomposed = .false.
      r0Ptr(1) % hasTimeDimension = .true.
      r0Ptr(1) % defaultValue = 0.0
      r0Ptr(1) % scalar = 0.0
      allocate(r0Ptr(1) % attLists(1))
      allocate(r0Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r0Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r0Ptr(1) % attLists(1) % attList, 'long_name', 'a placeholder real so that regionalStats has a memory to '&
//'duplicate per instance')
      r0Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r0Ptr(1) % block => block

      if (regionalStatsDailyAMPKGActive .or. regionalStatsWeeklyAMPKGActive .or. regionalStatsMonthlyAMPKGActive .or. &
regionalStatsCustomAMPKGActive) then
         r0Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'regionalStatsOneReal', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'regionalStatsOneReal', r0Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_pool_regionalStatsAM


   subroutine ocn_generate_pool_timeSeriesStatsAM(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'timeSeriesStatsAM', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'timeSeriesStatsAM', newSubPool)

! Define variable timeSeriesStatsOneString
      allocate(c0Ptr(1))

! Setting up time level 1
      c0Ptr(1) % fieldName = 'timeSeriesStatsOneString'
      c0Ptr(1) % isVarArray = .false.
      c0Ptr(1) % isDecomposed = .false.
      c0Ptr(1) % hasTimeDimension = .true.
      c0Ptr(1) % defaultValue = ''
      c0Ptr(1) % scalar = ''
      allocate(c0Ptr(1) % attLists(1))
      allocate(c0Ptr(1) % attLists(1) % attList)
      call mpas_add_att(c0Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      c0Ptr(1) % missingValue = MPAS_CHAR_FILLVAL
      c0Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         c0Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'timeSeriesStatsOneString', c0Ptr)
      call mpas_pool_add_field(block % allFields, 'timeSeriesStatsOneString', c0Ptr)

! Define variable timeSeriesStatsOneInteger
      allocate(i0Ptr(1))

! Setting up time level 1
      i0Ptr(1) % fieldName = 'timeSeriesStatsOneInteger'
      i0Ptr(1) % isVarArray = .false.
      i0Ptr(1) % isDecomposed = .false.
      i0Ptr(1) % hasTimeDimension = .true.
      i0Ptr(1) % defaultValue = 0
      i0Ptr(1) % scalar = 0
      allocate(i0Ptr(1) % attLists(1))
      allocate(i0Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i0Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      i0Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i0Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         i0Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'timeSeriesStatsOneInteger', i0Ptr)
      call mpas_pool_add_field(block % allFields, 'timeSeriesStatsOneInteger', i0Ptr)

! Define variable timeSeriesStatsOneReal
      allocate(r0Ptr(1))

! Setting up time level 1
      r0Ptr(1) % fieldName = 'timeSeriesStatsOneReal'
      r0Ptr(1) % isVarArray = .false.
      r0Ptr(1) % isDecomposed = .false.
      r0Ptr(1) % hasTimeDimension = .true.
      r0Ptr(1) % defaultValue = 0.0
      r0Ptr(1) % scalar = 0.0
      allocate(r0Ptr(1) % attLists(1))
      allocate(r0Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r0Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      r0Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r0Ptr(1) % block => block

      if (forwardModeActive .or. analysisModeActive) then
         r0Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'timeSeriesStatsOneReal', r0Ptr)
      call mpas_pool_add_field(block % allFields, 'timeSeriesStatsOneReal', r0Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_pool_timeSeriesStatsAM


   subroutine ocn_generate_pool_transectTransportAM(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'transectTransportAM', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'transectTransportAM', newSubPool)

! Define variable transectEdgeMasksMax
      allocate(i1Ptr(1))

! Setting up time level 1
      i1Ptr(1) % fieldName = 'transectEdgeMasksMax'
      i1Ptr(1) % isVarArray = .false.
      i1Ptr(1) % isDecomposed = .false.
      i1Ptr(1) % hasTimeDimension = .false.
      i1Ptr(1) % isPersistent = .true.
      i1Ptr(1) % isActive = .false.
! Setting up dimensions
      i1Ptr(1) % dimNames(1) = 'nTransects'
      i1Ptr(1) % defaultValue = 0
      allocate(i1Ptr(1) % attLists(1))
      allocate(i1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'units', 'NA')
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'long_name', 'max of transectEdgeMasks for this processor.')
      i1Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i1Ptr(1) % block => block

      if (transectTransportAMPKGActive) then
         i1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'transectEdgeMasksMax', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'transectEdgeMasksMax', i1Ptr)

! Define variable transectVolumeTransport
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'transectVolumeTransport'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .false.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nTransects'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'Sv')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Transport through transect of edges.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (transectTransportAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'transectVolumeTransport', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'transectVolumeTransport', r1Ptr)

! Define variable transectVolumeTransportZ
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'transectVolumeTransportZ'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .false.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nTransects'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'Sv')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Transport through transect of edges, with depth '&
//'coordinate.')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (transectTransportAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'transectVolumeTransportZ', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'transectVolumeTransportZ', r2Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_pool_transectTransportAM


   subroutine ocn_generate_pool_eddyProductVariablesAM(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'eddyProductVariablesAM', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'eddyProductVariablesAM', newSubPool)

! Define variable SSHSquared
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'SSHSquared'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .true.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm^2')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'cell-wise square of sea surface height')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (eddyProductVariablesAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'SSHSquared', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'SSHSquared', r1Ptr)

! Define variable velocityZonalSquared
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'velocityZonalSquared'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm^2 s^{-2}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'cell-wise square of component of horizontal velocity in '&
//'the eastward direction')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (eddyProductVariablesAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'velocityZonalSquared', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'velocityZonalSquared', r2Ptr)

! Define variable velocityMeridionalSquared
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'velocityMeridionalSquared'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm^2 s^{-2}')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'cell-wise square of component of horizontal velocity in '&
//'the northward direction')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (eddyProductVariablesAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'velocityMeridionalSquared', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'velocityMeridionalSquared', r2Ptr)

! Define variable velocityZonalTimesTemperature
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'velocityZonalTimesTemperature'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1} C')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'cell-wise product of component of horizontal velocity in '&
//'the eastward direction and temperature')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (eddyProductVariablesAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'velocityZonalTimesTemperature', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'velocityZonalTimesTemperature', r2Ptr)

! Define variable velocityMeridionalTimesTemperature
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'velocityMeridionalTimesTemperature'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .true.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nVertLevels'
      r2Ptr(1) % dimNames(2) = 'nCells'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'm s^{-1} C')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'cell-wise product of component of horizontal velocity in '&
//'the northward direction and temperature')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (eddyProductVariablesAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'velocityMeridionalTimesTemperature', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'velocityMeridionalTimesTemperature', r2Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_pool_eddyProductVariablesAM


   subroutine ocn_generate_pool_mocStreamfunctionAM(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'mocStreamfunctionAM', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'mocStreamfunctionAM', newSubPool)

! Define variable mocStreamvalLatAndDepth
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'mocStreamvalLatAndDepth'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .false.
      r2Ptr(1) % hasTimeDimension = .true.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'nMocStreamfunctionBinsP1'
      r2Ptr(1) % dimNames(2) = 'nVertLevels'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'sverdrups')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'The value of the MOC streamfunction for each latitude-bin '&
//'(first dimension) and depth (second dimension)')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (mocStreamfunctionAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'mocStreamvalLatAndDepth', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'mocStreamvalLatAndDepth', r2Ptr)

! Define variable mocStreamvalLatAndDepthRegion
      allocate(r3Ptr(1))

! Setting up time level 1
      r3Ptr(1) % fieldName = 'mocStreamvalLatAndDepthRegion'
      r3Ptr(1) % isVarArray = .false.
      r3Ptr(1) % isDecomposed = .false.
      r3Ptr(1) % hasTimeDimension = .true.
      r3Ptr(1) % isPersistent = .true.
      r3Ptr(1) % isActive = .false.
! Setting up dimensions
      r3Ptr(1) % dimNames(1) = 'nMocStreamfunctionBinsP1'
      r3Ptr(1) % dimNames(2) = 'nVertLevels'
      r3Ptr(1) % dimNames(3) = 'R3'
      r3Ptr(1) % defaultValue = 0.0
      allocate(r3Ptr(1) % attLists(1))
      allocate(r3Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'units', 'sverdrups')
      call mpas_add_att(r3Ptr(1) % attLists(1) % attList, 'long_name', 'The value of the MOC streamfunction for each latitude-bin '&
//'(first dimension) and depth (second dimension)')
      r3Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r3Ptr(1) % block => block

      if (mocStreamfunctionAMPKGActive) then
         r3Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'mocStreamvalLatAndDepthRegion', r3Ptr)
      call mpas_pool_add_field(block % allFields, 'mocStreamvalLatAndDepthRegion', r3Ptr)

! Define variable binBoundaryMocStreamfunction
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'binBoundaryMocStreamfunction'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .false.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nMocStreamfunctionBinsP1'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'varies')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Coordinate of southern edge of meridional heat transport '&
//'bin, either in latitude or y, for plotting.')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (mocStreamfunctionAMPKGActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'binBoundaryMocStreamfunction', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'binBoundaryMocStreamfunction', r1Ptr)

! Define variable minMaxLatRegion
      allocate(r2Ptr(1))

! Setting up time level 1
      r2Ptr(1) % fieldName = 'minMaxLatRegion'
      r2Ptr(1) % isVarArray = .false.
      r2Ptr(1) % isDecomposed = .false.
      r2Ptr(1) % hasTimeDimension = .false.
      r2Ptr(1) % isPersistent = .true.
      r2Ptr(1) % isActive = .false.
! Setting up dimensions
      r2Ptr(1) % dimNames(1) = 'TWO'
      r2Ptr(1) % dimNames(2) = 'R3'
      r2Ptr(1) % defaultValue = 0.0
      allocate(r2Ptr(1) % attLists(1))
      allocate(r2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'units', 'varies')
      call mpas_add_att(r2Ptr(1) % attLists(1) % attList, 'long_name', 'Coordinates of the southern and northern boundaries of '&
//'each region (for drawing).')
      r2Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r2Ptr(1) % block => block

      if (mocStreamfunctionAMPKGActive) then
         r2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'minMaxLatRegion', r2Ptr)
      call mpas_pool_add_field(block % allFields, 'minMaxLatRegion', r2Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_pool_mocStreamfunctionAM


   subroutine ocn_generate_pool_landIceInit(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'landIceInit', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'landIceInit', newSubPool)

! Define variable landIceDraftObserved
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'landIceDraftObserved'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'z-coordinate of land ice bottom, read in from data file')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (landIceInitActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'landIceDraftObserved', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'landIceDraftObserved', r1Ptr)

! Define variable landIceThkObserved
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'landIceThkObserved'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Thickness of land ice, read in from data file')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (landIceInitActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'landIceThkObserved', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'landIceThkObserved', r1Ptr)

! Define variable landIceFracObserved
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'landIceFracObserved'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Fraction of land ice, read in from data file')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (landIceInitActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'landIceFracObserved', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'landIceFracObserved', r1Ptr)

! Define variable landIceGroundedFracObserved
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'landIceGroundedFracObserved'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .true.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nCells'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Fraction of grounded land ice, read in from data file')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (landIceInitActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'landIceGroundedFracObserved', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'landIceGroundedFracObserved', r1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_pool_landIceInit


   subroutine ocn_generate_pool_criticalPassages(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_pool_routines
      use mpas_io_units
      use mpas_io, only : MPAS_REAL_FILLVAL, MPAS_INT_FILLVAL, MPAS_CHAR_FILLVAL
      implicit none
      type (block_type), intent(inout), pointer :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      type (field0DReal), dimension(:), pointer :: r0Ptr
      type (field1DReal), dimension(:), pointer :: r1Ptr
      type (field2DReal), dimension(:), pointer :: r2Ptr
      type (field3DReal), dimension(:), pointer :: r3Ptr
      type (field4DReal), dimension(:), pointer :: r4Ptr
      type (field5DReal), dimension(:), pointer :: r5Ptr
      type (field0DInteger), dimension(:), pointer :: i0Ptr
      type (field1DInteger), dimension(:), pointer :: i1Ptr
      type (field2DInteger), dimension(:), pointer :: i2Ptr
      type (field3DInteger), dimension(:), pointer :: i3Ptr
      type (field0DChar), dimension(:), pointer :: c0Ptr
      type (field1DChar), dimension(:), pointer :: c1Ptr

      type (mpas_pool_type), pointer :: newSubPool
      integer :: group_counter
      logical :: group_started
      integer :: group_start
      integer :: index_counter
      integer, pointer :: const_index

      logical, pointer :: timeVaryingAtmosphericForcingPKGActive
      logical, pointer :: timeVaryingLandIceForcingPKGActive
      logical, pointer :: variableShortwaveActive
      logical, pointer :: splitTimeIntegratorActive
      logical, pointer :: thicknessFilterActive
      logical, pointer :: windStressBulkPKGActive
      logical, pointer :: variableBottomDragPKGActive
      logical, pointer :: thicknessBulkPKGActive
      logical, pointer :: landIcePressurePKGActive
      logical, pointer :: landIceFluxesPKGActive
      logical, pointer :: landIceCouplingPKGActive
      logical, pointer :: frazilIceActive
      logical, pointer :: tidalForcingActive
      logical, pointer :: inSituEOSActive
      logical, pointer :: forwardModeActive
      logical, pointer :: analysisModeActive
      logical, pointer :: initModeActive
      logical, pointer :: cullCellsActive
      logical, pointer :: tracerBudgetActive
      logical, pointer :: gmActive
      logical, pointer :: tidalPotentialForcingPKGActive
      logical, pointer :: activeTracersPKGActive
      logical, pointer :: activeTracersBulkRestoringPKGActive
      logical, pointer :: activeTracersSurfaceRestoringPKGActive
      logical, pointer :: activeTracersInteriorRestoringPKGActive
      logical, pointer :: activeTracersExponentialDecayPKGActive
      logical, pointer :: activeTracersIdealAgePKGActive
      logical, pointer :: activeTracersTTDPKGActive
      logical, pointer :: debugTracersPKGActive
      logical, pointer :: debugTracersBulkRestoringPKGActive
      logical, pointer :: debugTracersSurfaceRestoringPKGActive
      logical, pointer :: debugTracersInteriorRestoringPKGActive
      logical, pointer :: debugTracersExponentialDecayPKGActive
      logical, pointer :: debugTracersIdealAgePKGActive
      logical, pointer :: debugTracersTTDPKGActive
      logical, pointer :: ecosysTracersPKGActive
      logical, pointer :: ecosysTracersBulkRestoringPKGActive
      logical, pointer :: ecosysTracersSurfaceRestoringPKGActive
      logical, pointer :: ecosysTracersInteriorRestoringPKGActive
      logical, pointer :: ecosysTracersExponentialDecayPKGActive
      logical, pointer :: ecosysTracersIdealAgePKGActive
      logical, pointer :: ecosysTracersTTDPKGActive
      logical, pointer :: DMSTracersPKGActive
      logical, pointer :: DMSTracersBulkRestoringPKGActive
      logical, pointer :: DMSTracersSurfaceRestoringPKGActive
      logical, pointer :: DMSTracersInteriorRestoringPKGActive
      logical, pointer :: DMSTracersExponentialDecayPKGActive
      logical, pointer :: DMSTracersIdealAgePKGActive
      logical, pointer :: DMSTracersTTDPKGActive
      logical, pointer :: MacroMoleculesTracersPKGActive
      logical, pointer :: MacroMoleculesTracersBulkRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersSurfaceRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersInteriorRestoringPKGActive
      logical, pointer :: MacroMoleculesTracersExponentialDecayPKGActive
      logical, pointer :: MacroMoleculesTracersIdealAgePKGActive
      logical, pointer :: MacroMoleculesTracersTTDPKGActive
      logical, pointer :: globalStatsAMPKGActive
      logical, pointer :: surfaceAreaWeightedAveragesAMPKGActive
      logical, pointer :: waterMassCensusAMPKGActive
      logical, pointer :: layerVolumeWeightedAverageAMPKGActive
      logical, pointer :: zonalMeanAMPKGActive
      logical, pointer :: okuboWeissAMPKGActive
      logical, pointer :: meridionalHeatTransportAMPKGActive
      logical, pointer :: testComputeIntervalAMPKGActive
      logical, pointer :: highFrequencyOutputAMPKGActive
      logical, pointer :: timeFiltersAMPKGActive
      logical, pointer :: lagrPartTrackAMPKGActive
      logical, pointer :: eliassenPalmAMPKGActive
      logical, pointer :: mixedLayerDepthsAMPKGActive
      logical, pointer :: regionalStatsDailyAMPKGActive
      logical, pointer :: regionalStatsWeeklyAMPKGActive
      logical, pointer :: regionalStatsMonthlyAMPKGActive
      logical, pointer :: regionalStatsCustomAMPKGActive
      logical, pointer :: timeSeriesStatsDailyAMPKGActive
      logical, pointer :: timeSeriesStatsMonthlyAMPKGActive
      logical, pointer :: timeSeriesStatsClimatologyAMPKGActive
      logical, pointer :: timeSeriesStatsCustomAMPKGActive
      logical, pointer :: pointwiseStatsAMPKGActive
      logical, pointer :: debugDiagnosticsAMPKGActive
      logical, pointer :: rpnCalculatorAMPKGActive
      logical, pointer :: transectTransportAMPKGActive
      logical, pointer :: eddyProductVariablesAMPKGActive
      logical, pointer :: mocStreamfunctionAMPKGActive
      logical, pointer :: landIceInitActive
      logical, pointer :: criticalPassagesActive


      integer :: numConstituents

      nullify(newSubPool)
      group_counter = -1
      group_started = .false.
      group_start = -1
      call mpas_pool_get_package(packagePool, 'timeVaryingAtmosphericForcingPKGActive', timeVaryingAtmosphericForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'timeVaryingLandIceForcingPKGActive', timeVaryingLandIceForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'variableShortwaveActive', variableShortwaveActive)
      call mpas_pool_get_package(packagePool, 'splitTimeIntegratorActive', splitTimeIntegratorActive)
      call mpas_pool_get_package(packagePool, 'thicknessFilterActive', thicknessFilterActive)
      call mpas_pool_get_package(packagePool, 'windStressBulkPKGActive', windStressBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'variableBottomDragPKGActive', variableBottomDragPKGActive)
      call mpas_pool_get_package(packagePool, 'thicknessBulkPKGActive', thicknessBulkPKGActive)
      call mpas_pool_get_package(packagePool, 'landIcePressurePKGActive', landIcePressurePKGActive)
      call mpas_pool_get_package(packagePool, 'landIceFluxesPKGActive', landIceFluxesPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceCouplingPKGActive', landIceCouplingPKGActive)
      call mpas_pool_get_package(packagePool, 'frazilIceActive', frazilIceActive)
      call mpas_pool_get_package(packagePool, 'tidalForcingActive', tidalForcingActive)
      call mpas_pool_get_package(packagePool, 'inSituEOSActive', inSituEOSActive)
      call mpas_pool_get_package(packagePool, 'forwardModeActive', forwardModeActive)
      call mpas_pool_get_package(packagePool, 'analysisModeActive', analysisModeActive)
      call mpas_pool_get_package(packagePool, 'initModeActive', initModeActive)
      call mpas_pool_get_package(packagePool, 'cullCellsActive', cullCellsActive)
      call mpas_pool_get_package(packagePool, 'tracerBudgetActive', tracerBudgetActive)
      call mpas_pool_get_package(packagePool, 'gmActive', gmActive)
      call mpas_pool_get_package(packagePool, 'tidalPotentialForcingPKGActive', tidalPotentialForcingPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersPKGActive', activeTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersBulkRestoringPKGActive', activeTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersSurfaceRestoringPKGActive', activeTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersInteriorRestoringPKGActive', activeTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersExponentialDecayPKGActive', activeTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersIdealAgePKGActive', activeTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'activeTracersTTDPKGActive', activeTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersPKGActive', debugTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersBulkRestoringPKGActive', debugTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersSurfaceRestoringPKGActive', debugTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersInteriorRestoringPKGActive', debugTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersExponentialDecayPKGActive', debugTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersIdealAgePKGActive', debugTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'debugTracersTTDPKGActive', debugTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersPKGActive', ecosysTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersBulkRestoringPKGActive', ecosysTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersSurfaceRestoringPKGActive', ecosysTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersInteriorRestoringPKGActive', ecosysTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersExponentialDecayPKGActive', ecosysTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersIdealAgePKGActive', ecosysTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'ecosysTracersTTDPKGActive', ecosysTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersPKGActive', DMSTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersBulkRestoringPKGActive', DMSTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersSurfaceRestoringPKGActive', DMSTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersInteriorRestoringPKGActive', DMSTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersExponentialDecayPKGActive', DMSTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersIdealAgePKGActive', DMSTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'DMSTracersTTDPKGActive', DMSTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersPKGActive', MacroMoleculesTracersPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersBulkRestoringPKGActive', &
MacroMoleculesTracersBulkRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersSurfaceRestoringPKGActive', &
MacroMoleculesTracersSurfaceRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersInteriorRestoringPKGActive', &
MacroMoleculesTracersInteriorRestoringPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersExponentialDecayPKGActive', &
MacroMoleculesTracersExponentialDecayPKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersIdealAgePKGActive', MacroMoleculesTracersIdealAgePKGActive)
      call mpas_pool_get_package(packagePool, 'MacroMoleculesTracersTTDPKGActive', MacroMoleculesTracersTTDPKGActive)
      call mpas_pool_get_package(packagePool, 'globalStatsAMPKGActive', globalStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'surfaceAreaWeightedAveragesAMPKGActive', surfaceAreaWeightedAveragesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'waterMassCensusAMPKGActive', waterMassCensusAMPKGActive)
      call mpas_pool_get_package(packagePool, 'layerVolumeWeightedAverageAMPKGActive', layerVolumeWeightedAverageAMPKGActive)
      call mpas_pool_get_package(packagePool, 'zonalMeanAMPKGActive', zonalMeanAMPKGActive)
      call mpas_pool_get_package(packagePool, 'okuboWeissAMPKGActive', okuboWeissAMPKGActive)
      call mpas_pool_get_package(packagePool, 'meridionalHeatTransportAMPKGActive', meridionalHeatTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'testComputeIntervalAMPKGActive', testComputeIntervalAMPKGActive)
      call mpas_pool_get_package(packagePool, 'highFrequencyOutputAMPKGActive', highFrequencyOutputAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeFiltersAMPKGActive', timeFiltersAMPKGActive)
      call mpas_pool_get_package(packagePool, 'lagrPartTrackAMPKGActive', lagrPartTrackAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eliassenPalmAMPKGActive', eliassenPalmAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mixedLayerDepthsAMPKGActive', mixedLayerDepthsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsDailyAMPKGActive', regionalStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsWeeklyAMPKGActive', regionalStatsWeeklyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsMonthlyAMPKGActive', regionalStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'regionalStatsCustomAMPKGActive', regionalStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsDailyAMPKGActive', timeSeriesStatsDailyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsMonthlyAMPKGActive', timeSeriesStatsMonthlyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsClimatologyAMPKGActive', timeSeriesStatsClimatologyAMPKGActive)
      call mpas_pool_get_package(packagePool, 'timeSeriesStatsCustomAMPKGActive', timeSeriesStatsCustomAMPKGActive)
      call mpas_pool_get_package(packagePool, 'pointwiseStatsAMPKGActive', pointwiseStatsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'debugDiagnosticsAMPKGActive', debugDiagnosticsAMPKGActive)
      call mpas_pool_get_package(packagePool, 'rpnCalculatorAMPKGActive', rpnCalculatorAMPKGActive)
      call mpas_pool_get_package(packagePool, 'transectTransportAMPKGActive', transectTransportAMPKGActive)
      call mpas_pool_get_package(packagePool, 'eddyProductVariablesAMPKGActive', eddyProductVariablesAMPKGActive)
      call mpas_pool_get_package(packagePool, 'mocStreamfunctionAMPKGActive', mocStreamfunctionAMPKGActive)
      call mpas_pool_get_package(packagePool, 'landIceInitActive', landIceInitActive)
      call mpas_pool_get_package(packagePool, 'criticalPassagesActive', criticalPassagesActive)

      allocate(newSubPool)
      call mpas_pool_create_pool(newSubPool)
      call mpas_pool_add_subpool(structPool, 'criticalPassages', newSubPool)
      call mpas_pool_add_subpool(block % allStructs, 'criticalPassages', newSubPool)

! Define variable transectCellMasks
      allocate(i2Ptr(1))

! Setting up time level 1
      i2Ptr(1) % fieldName = 'transectCellMasks'
      i2Ptr(1) % isVarArray = .false.
      i2Ptr(1) % isDecomposed = .true.
      i2Ptr(1) % hasTimeDimension = .false.
      i2Ptr(1) % isPersistent = .true.
      i2Ptr(1) % isActive = .false.
! Setting up dimensions
      i2Ptr(1) % dimNames(1) = 'nTransects'
      i2Ptr(1) % dimNames(2) = 'nCells'
      i2Ptr(1) % defaultValue = 0
      allocate(i2Ptr(1) % attLists(1))
      allocate(i2Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i2Ptr(1) % attLists(1) % attList, 'long_name', 'Masks for transects describing critical passages')
      i2Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i2Ptr(1) % block => block

      if (criticalPassagesActive) then
         i2Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'transectCellMasks', i2Ptr)
      call mpas_pool_add_field(block % allFields, 'transectCellMasks', i2Ptr)

! Define variable depthTransects
      allocate(r1Ptr(1))

! Setting up time level 1
      r1Ptr(1) % fieldName = 'depthTransects'
      r1Ptr(1) % isVarArray = .false.
      r1Ptr(1) % isDecomposed = .false.
      r1Ptr(1) % hasTimeDimension = .false.
      r1Ptr(1) % isPersistent = .true.
      r1Ptr(1) % isActive = .false.
! Setting up dimensions
      r1Ptr(1) % dimNames(1) = 'nTransects'
      r1Ptr(1) % defaultValue = 0.0
      allocate(r1Ptr(1) % attLists(1))
      allocate(r1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'units', 'm')
      call mpas_add_att(r1Ptr(1) % attLists(1) % attList, 'long_name', 'Minimum depth of critical passages')
      r1Ptr(1) % missingValue = MPAS_REAL_FILLVAL
      r1Ptr(1) % block => block

      if (criticalPassagesActive) then
         r1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'depthTransects', r1Ptr)
      call mpas_pool_add_field(block % allFields, 'depthTransects', r1Ptr)

! Define variable criticalPassageLevel
      allocate(i1Ptr(1))

! Setting up time level 1
      i1Ptr(1) % fieldName = 'criticalPassageLevel'
      i1Ptr(1) % isVarArray = .false.
      i1Ptr(1) % isDecomposed = .false.
      i1Ptr(1) % hasTimeDimension = .false.
      i1Ptr(1) % isPersistent = .true.
      i1Ptr(1) % isActive = .false.
! Setting up dimensions
      i1Ptr(1) % dimNames(1) = 'nTransects'
      i1Ptr(1) % defaultValue = 0
      allocate(i1Ptr(1) % attLists(1))
      allocate(i1Ptr(1) % attLists(1) % attList)
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'units', 'unitless')
      call mpas_add_att(i1Ptr(1) % attLists(1) % attList, 'long_name', 'the vertical level corresponding to the depth of the '&
//'critical passage')
      i1Ptr(1) % missingValue = MPAS_INT_FILLVAL
      i1Ptr(1) % block => block

      if (criticalPassagesActive) then
         i1Ptr(1) % isActive = .true.
      end if
      call mpas_pool_add_field(newSubPool, 'criticalPassageLevel', i1Ptr)
      call mpas_pool_add_field(block % allFields, 'criticalPassageLevel', i1Ptr)



      if (associated(newSubPool)) then
         call mpas_pool_add_config(newSubPool, 'on_a_sphere', block % domain % on_a_sphere)
         call mpas_pool_add_config(newSubPool, 'sphere_radius', block % domain % sphere_radius)
         call mpas_pool_add_config(newSubPool, 'is_periodic', block % domain % is_periodic)
         call mpas_pool_add_config(newSubPool, 'x_period', block % domain % x_period)
         call mpas_pool_add_config(newSubPool, 'y_period', block % domain % y_period)
      end if

   end subroutine ocn_generate_pool_criticalPassages


   subroutine ocn_generate_structs(block, structPool, dimensionPool, packagePool)
      use mpas_derived_types
      use mpas_io_units
      implicit none
      type (block_type), pointer, intent(inout) :: block
      type (mpas_pool_type), intent(inout) :: structPool
      type (mpas_pool_type), intent(inout) :: dimensionPool
      type (mpas_pool_type), intent(in) :: packagePool

      call ocn_generate_pool_state(block, structPool, dimensionPool, packagePool)

      call ocn_generate_pool_mesh(block, structPool, dimensionPool, packagePool)

      call ocn_generate_pool_verticalMesh(block, structPool, dimensionPool, packagePool)

      call ocn_generate_pool_tend(block, structPool, dimensionPool, packagePool)

      call ocn_generate_pool_diagnostics(block, structPool, dimensionPool, packagePool)

      call ocn_generate_pool_shortwave(block, structPool, dimensionPool, packagePool)

      call ocn_generate_pool_forcing(block, structPool, dimensionPool, packagePool)

      call ocn_generate_pool_timeVaryingForcing(block, structPool, dimensionPool, packagePool)

      call ocn_generate_pool_scratch(block, structPool, dimensionPool, packagePool)

      call ocn_generate_pool_pointLocations(block, structPool, dimensionPool, packagePool)

      call ocn_generate_pool_regions(block, structPool, dimensionPool, packagePool)

      call ocn_generate_pool_transects(block, structPool, dimensionPool, packagePool)

      call ocn_generate_pool_surfaceSalinityMonthlyForcing(block, structPool, dimensionPool, packagePool)

      call ocn_generate_pool_ecosysMonthlyForcing(block, structPool, dimensionPool, packagePool)

      call ocn_generate_pool_globalStatsAM(block, structPool, dimensionPool, packagePool)

      call ocn_generate_pool_surfaceAreaWeightedAveragesAM(block, structPool, dimensionPool, packagePool)

      call ocn_generate_pool_surfaceAreaWeightedAveragesAMScratch(block, structPool, dimensionPool, packagePool)

      call ocn_generate_pool_waterMassCensusAM(block, structPool, dimensionPool, packagePool)

      call ocn_generate_pool_layerVolumeWeightedAverageAM(block, structPool, dimensionPool, packagePool)

      call ocn_generate_pool_layerVolumeWeightedAverageAMScratch(block, structPool, dimensionPool, packagePool)

      call ocn_generate_pool_zonalMeanAM(block, structPool, dimensionPool, packagePool)

      call ocn_generate_pool_okuboWeissScratch(block, structPool, dimensionPool, packagePool)

      call ocn_generate_pool_okuboWeissAM(block, structPool, dimensionPool, packagePool)

      call ocn_generate_pool_meridionalHeatTransportAM(block, structPool, dimensionPool, packagePool)

      call ocn_generate_pool_testComputeIntervalAM(block, structPool, dimensionPool, packagePool)

      call ocn_generate_pool_highFrequencyOutputAM(block, structPool, dimensionPool, packagePool)

      call ocn_generate_pool_timeFiltersAM(block, structPool, dimensionPool, packagePool)

      call ocn_generate_pool_lagrPartTrackRegions(block, structPool, dimensionPool, packagePool)

      call ocn_generate_pool_lagrPartTrackScalars(block, structPool, dimensionPool, packagePool)

      call ocn_generate_pool_lagrPartTrackFields(block, structPool, dimensionPool, packagePool)

      call ocn_generate_pool_lagrPartTrackCells(block, structPool, dimensionPool, packagePool)

      call ocn_generate_pool_lagrPartTrackHalo(block, structPool, dimensionPool, packagePool)

      call ocn_generate_pool_lagrPartTrackScratch(block, structPool, dimensionPool, packagePool)

      call ocn_generate_pool_eliassenPalmAM(block, structPool, dimensionPool, packagePool)

      call ocn_generate_pool_eliassenPalmAMPKGScratch(block, structPool, dimensionPool, packagePool)

      call ocn_generate_pool_mixedLayerDepthsAM(block, structPool, dimensionPool, packagePool)

      call ocn_generate_pool_regionalStatsAM(block, structPool, dimensionPool, packagePool)

      call ocn_generate_pool_timeSeriesStatsAM(block, structPool, dimensionPool, packagePool)

      call ocn_generate_pool_transectTransportAM(block, structPool, dimensionPool, packagePool)

      call ocn_generate_pool_eddyProductVariablesAM(block, structPool, dimensionPool, packagePool)

      call ocn_generate_pool_mocStreamfunctionAM(block, structPool, dimensionPool, packagePool)

      call ocn_generate_pool_landIceInit(block, structPool, dimensionPool, packagePool)

      call ocn_generate_pool_criticalPassages(block, structPool, dimensionPool, packagePool)

   end subroutine ocn_generate_structs
